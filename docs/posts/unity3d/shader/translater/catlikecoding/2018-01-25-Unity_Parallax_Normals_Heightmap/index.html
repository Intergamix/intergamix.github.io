<!doctypehtml><html class=no-js lang=zh><meta charset=utf-8><meta content=on http-equiv=x-dns-prefetch-control><link href=//www.damonc.top rel=dns-prefetch><link href=//search.www.damonc.top rel=dns-prefetch><link href=//api.github.com rel=dns-prefetch><link href=//www.google-analytics.com rel=dns-prefetch><meta content=width=device-width,initial-scale=1 name=viewport><meta content=由于视角的原因，当调整摄像机位置时，观察到的事物的相对位置会发生变化，这种视觉现象称为视差。在坐火车高速行驶看窗外的景物，附近的物体看起来很大并且移动很快，而远处的背景看起来很小并且移动较慢。渲染时，相机使用透视模式时，也会出现视差。 name=description><meta content=catlikecoding name=author><link href=https://www.damonc.top/posts/unity3d/shader/translater/catlikecoding/2018-01-25-Unity_Parallax_Normals_Heightmap/ rel=canonical><link href=../../../../../../favicon.ico rel=icon><meta content="mkdocs-1.4.2, mkdocs-material-8.5.11"name=generator><title>视差和法线、高度图回顾(翻译二十) - 银河揽月</title><link href=../../../../../../assets/stylesheets/main.31645160.min.css rel=stylesheet><link href=../../../../../../assets/stylesheets/palette.2505c338.min.css rel=stylesheet><link href=../../../../../../extension/css/extra.css rel=stylesheet><link crossorigin href=https://fonts.gstatic.com rel=preconnect><link href=https://fonts.googleapis.com/css?family=Fira+Sans:300,300i,400,400i,700,700i%7CFira+Mono:400,400i,700,700i&display=fallback rel=stylesheet><style>:root{--md-text-font:"Fira Sans";--md-code-font:"Fira Mono"}@font-face {font-family:'Fira Sans';font-style:normal;font-weight:300;src:local('Fira Sans'),local('FiraSans-Normal'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-300.eot?#iefix) format('embedded-opentype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-300.woff2) format('woff2'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-300.woff) format('woff'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-300.ttf) format('truetype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-300.svg#FiraSans) format('svg')}@font-face {font-family:'Fira Sans';font-style:normal;font-weight:regular;src:local('Fira Sans'),local('FiraSans-Normal'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-regular.eot?#iefix) format('embedded-opentype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-regular.woff2) format('woff2'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-regular.woff) format('woff'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-regular.ttf) format('truetype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-regular.svg#FiraSans) format('svg')}@font-face {font-family:'Fira Sans';font-style:italic;font-weight:regular;src:local('Fira Sans'),local('FiraSans-Italic'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-italic.eot?#iefix) format('embedded-opentype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-italic.woff2) format('woff2'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-italic.woff) format('woff'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-italic.ttf) format('truetype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-italic.svg#FiraSans) format('svg')}@font-face {font-family:'Fira Sans';font-style:normal;font-weight:700;src:local('Fira Sans'),local('FiraSans-Normal'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-700.eot?#iefix) format('embedded-opentype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-700.woff2) format('woff2'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-700.woff) format('woff'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-700.ttf) format('truetype'),url(//lib.baomitu.com/fonts/fira-sans/fira-sans-700.svg#FiraSans) format('svg')}@font-face {font-family:'Fira Mono';font-style:normal;font-weight:regular;src:local('Fira Mono'),local('FiraMono-Normal'),url(//lib.baomitu.com/fonts/fira-mono/fira-mono-regular.eot?#iefix) format('embedded-opentype'),url(//lib.baomitu.com/fonts/fira-mono/fira-mono-regular.woff2) format('woff2'),url(//lib.baomitu.com/fonts/fira-mono/fira-mono-regular.woff) format('woff'),url(//lib.baomitu.com/fonts/fira-mono/fira-mono-regular.ttf) format('truetype'),url(//lib.baomitu.com/fonts/fira-mono/fira-mono-regular.svg#FiraMono) format('svg')}</style><script>__md_scope=new URL("../../../../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script><script>"undefined"!=typeof __md_analytics&&__md_analytics()</script></head><body data-md-color-accent=red data-md-color-primary=white data-md-color-scheme=default dir=ltr><script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script><input autocomplete=off class=md-toggle data-md-toggle=drawer id=__drawer type=checkbox><input autocomplete=off class=md-toggle data-md-toggle=search id=__search type=checkbox><label class=md-overlay for=__drawer></label><div data-md-component=skip><a class=md-skip href=#视差纹理> 跳转至 </a></div><div data-md-component=announce></div><header class=md-header data-md-component=header><nav class="md-header__inner md-grid"aria-label=页眉><a class="md-header__button md-logo"aria-label=银河揽月 data-md-component=logo href=../../../../../.. title=银河揽月> <img alt=logo src=../../../../../../images/homepage.png> </a><label class="md-header__button md-icon"for=__drawer><svg viewbox="0 0 24 24"xmlns=http://www.w3.org/2000/svg><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg></label><div class=md-header__title data-md-component=header-title><div class=md-header__ellipsis><div class=md-header__topic><span class=md-ellipsis> 银河揽月 </span></div><div class=md-header__topic data-md-component=header-topic><span class=md-ellipsis> 视差和法线、高度图回顾(翻译二十) </span></div></div></div><form class=md-header__option data-md-component=palette><input aria-label="Switch to dark mode"data-md-color-media="(prefers-color-scheme: light)"class=md-option data-md-color-accent=red data-md-color-primary=white data-md-color-scheme=default id=__palette_1 name=__palette type=radio><label class="md-header__button md-icon"title="Switch to dark mode"for=__palette_2 hidden><svg viewbox="0 0 24 24"xmlns=http://www.w3.org/2000/svg><path d="M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0-7 2.39 3.42C13.65 5.15 12.84 5 12 5c-.84 0-1.65.15-2.39.42L12 2M3.34 7l4.16-.35A7.2 7.2 0 0 0 5.94 8.5c-.44.74-.69 1.5-.83 2.29L3.34 7m.02 10 1.76-3.77a7.131 7.131 0 0 0 2.38 4.14L3.36 17M20.65 7l-1.77 3.79a7.023 7.023 0 0 0-2.38-4.15l4.15.36m-.01 10-4.14.36c.59-.51 1.12-1.14 1.54-1.86.42-.73.69-1.5.83-2.29L20.64 17M12 22l-2.41-3.44c.74.27 1.55.44 2.41.44.82 0 1.63-.17 2.37-.44L12 22Z"/></svg></label><input aria-label="Switch to light mode"data-md-color-media="(prefers-color-scheme: dark)"class=md-option data-md-color-accent=slate data-md-color-primary=slate data-md-color-scheme=slate id=__palette_2 name=__palette type=radio><label class="md-header__button md-icon"title="Switch to light mode"for=__palette_1 hidden><svg viewbox="0 0 24 24"xmlns=http://www.w3.org/2000/svg><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3 3.19.09m3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95 2.06.05m-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31Z"/></svg></label></form><label class="md-header__button md-icon"for=__search><svg viewbox="0 0 24 24"xmlns=http://www.w3.org/2000/svg><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg></label><div class=md-search data-md-component=search role=dialog><label class=md-search__overlay for=__search></label><div class=md-search__inner role=search><form class=md-search__form name=search><input aria-label=搜索 autocapitalize=off autocomplete=off autocorrect=off class=md-search__input data-md-component=search-query name=query placeholder=搜索 required spellcheck=false><label class="md-search__icon md-icon"for=__search><svg viewbox="0 0 24 24"xmlns=http://www.w3.org/2000/svg><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> <svg viewbox="0 0 24 24"xmlns=http://www.w3.org/2000/svg><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg></label><nav aria-label=查找 class=md-search__options><button class="md-search__icon md-icon"aria-label=清空当前内容 tabindex=-1 title=清空当前内容 type=reset><svg viewbox="0 0 24 24"xmlns=http://www.w3.org/2000/svg><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg></button></nav></form><div class=md-search__output><div class=md-search__scrollwrap data-md-scrollfix><div class=md-search-result data-md-component=search-result><div class=md-search-result__meta>正在初始化搜索引擎</div><ol class=md-search-result__list></ol></div></div></div></div></div><div class=md-header__source><a class=md-source data-md-component=source href=https://github.com/damonc-top/damonc-top.github.io title=前往仓库> <div class="md-source__icon md-icon"><svg viewbox="0 0 448 512"xmlns=http://www.w3.org/2000/svg><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg></div> <div class=md-source__repository>damonc-top</div> </a></div></nav></header><div class=md-container data-md-component=container><nav aria-label=标签 class=md-tabs data-md-component=tabs><div class="md-tabs__inner md-grid"><ul class=md-tabs__list><li class=md-tabs__item><a class=md-tabs__link href=../../../../../..> 首页 </a></li><li class=md-tabs__item><a class=md-tabs__link href=../../../../il2cpp/> Unity3D引擎 </a></li></ul></div></nav><main class=md-main data-md-component=main><div class="md-main__inner md-grid"><div class="md-sidebar md-sidebar--primary"data-md-component=sidebar data-md-type=navigation><div class=md-sidebar__scrollwrap><div class=md-sidebar__inner><nav class="md-nav md-nav--primary md-nav--lifted"aria-label=导航栏 data-md-level=0><label class=md-nav__title for=__drawer><a class="md-nav__button md-logo"aria-label=银河揽月 data-md-component=logo href=../../../../../.. title=银河揽月> <img alt=logo src=../../../../../../images/homepage.png> </a> 银河揽月</label><div class=md-nav__source><a class=md-source data-md-component=source href=https://github.com/damonc-top/damonc-top.github.io title=前往仓库> <div class="md-source__icon md-icon"><svg viewbox="0 0 448 512"xmlns=http://www.w3.org/2000/svg><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg></div> <div class=md-source__repository>damonc-top</div> </a></div><ul class=md-nav__list data-md-scrollfix><li class="md-nav__item md-nav__item--nested"><input class="md-nav__toggle md-toggle"data-md-toggle=__nav_1 id=__nav_1 type=checkbox> <label class=md-nav__link for=__nav_1>首页 <span class="md-nav__icon md-icon"></span></label> <nav aria-label=首页 class=md-nav data-md-level=1><label class=md-nav__title for=__nav_1><span class="md-nav__icon md-icon"></span> 首页</label><ul class=md-nav__list data-md-scrollfix><li class=md-nav__item><a class=md-nav__link href=../../../../../..> 简介 </a></li><li class=md-nav__item><a class=md-nav__link href=../../../../../home/learn/> 记录 </a></li></ul></nav></li><li class="md-nav__item md-nav__item--nested"><input class="md-nav__toggle md-toggle"data-md-toggle=__nav_2 id=__nav_2 type=checkbox> <label class=md-nav__link for=__nav_2>Unity3D引擎 <span class="md-nav__icon md-icon"></span></label> <nav aria-label=Unity3D引擎 class=md-nav data-md-level=1><label class=md-nav__title for=__nav_2><span class="md-nav__icon md-icon"></span> Unity3D引擎</label><ul class=md-nav__list data-md-scrollfix><li class="md-nav__item md-nav__item--nested"><input class="md-nav__toggle md-toggle"data-md-toggle=__nav_2_1 id=__nav_2_1 type=checkbox> <label class=md-nav__link for=__nav_2_1>il2cpp <span class="md-nav__icon md-icon"></span></label> <nav aria-label=il2cpp class=md-nav data-md-level=2><label class=md-nav__title for=__nav_2_1><span class="md-nav__icon md-icon"></span> il2cpp</label><ul class=md-nav__list data-md-scrollfix><li class=md-nav__item><a class=md-nav__link href=../../../../il2cpp/> il2cpp简介 </a></li></ul></nav></li><li class="md-nav__item md-nav__item--nested"><input class="md-nav__toggle md-toggle"data-md-toggle=__nav_2_2 id=__nav_2_2 type=checkbox> <label class=md-nav__link for=__nav_2_2>Shader <span class="md-nav__icon md-icon"></span></label> <nav aria-label=Shader class=md-nav data-md-level=2><label class=md-nav__title for=__nav_2_2><span class="md-nav__icon md-icon"></span> Shader</label><ul class=md-nav__list data-md-scrollfix><li class="md-nav__item md-nav__item--nested"><input class="md-nav__toggle md-toggle"data-md-toggle=__nav_2_2_1 id=__nav_2_2_1 type=checkbox> <label class=md-nav__link for=__nav_2_2_1>翻译CatlikeCoding <span class="md-nav__icon md-icon"></span></label> <nav aria-label=翻译CatlikeCoding class=md-nav data-md-level=3><label class=md-nav__title for=__nav_2_2_1><span class="md-nav__icon md-icon"></span> 翻译CatlikeCoding</label><ul class=md-nav__list data-md-scrollfix><li class=md-nav__item><a class=md-nav__link href=../> Catlikecoding简介 </a></li><li class=md-nav__item><a class=md-nav__link href=../unity_matrix_transform/> 一UnityShader变换矩阵 </a></li><li class=md-nav__item><a class=md-nav__link href=../unity_shader_fundamentals/> 二UnityShader基本语法 </a></li><li class=md-nav__item><a class=md-nav__link href=../unity_combine_texture/> 三UnityShader纹理融合 </a></li><li class=md-nav__item><a class=md-nav__link href=../unity_base_light/> 四UnityShader基础光照 </a></li></ul></nav></li></ul></nav></li></ul></nav></li></ul></nav></div></div></div><div class="md-sidebar md-sidebar--secondary"data-md-component=sidebar data-md-type=toc><div class=md-sidebar__scrollwrap><div class=md-sidebar__inner><nav class="md-nav md-nav--secondary"aria-label=目录><label class=md-nav__title for=__toc><span class="md-nav__icon md-icon"></span> 目录</label><ul class=md-nav__list data-md-component=toc data-md-scrollfix><li class=md-nav__item><a class=md-nav__link href=#视差纹理> 视差纹理 </a> <nav aria-label=视差纹理 class=md-nav><ul class=md-nav__list><li class=md-nav__item><a class=md-nav__link href=#法线贴图效果回顾> 法线贴图效果回顾 </a></li><li class=md-nav__item><a class=md-nav__link href=#shader参数> Shader参数 </a></li><li class=md-nav__item><a class=md-nav__link href=#坐标匹配> 坐标匹配 </a></li><li class=md-nav__item><a class=md-nav__link href=#随视角方向移动> 随视角方向移动 </a></li><li class=md-nav__item><a class=md-nav__link href=#基于高度滑动> 基于高度滑动 </a></li><li class=md-nav__item><a class=md-nav__link href=#偏移视差映射算法> 偏移视差映射算法 </a></li><li class=md-nav__item><a class=md-nav__link href=#parallax-configuration> Parallax Configuration </a></li><li class=md-nav__item><a class=md-nav__link href=#detail-uv> Detail UV </a></li></ul></nav></li><li class=md-nav__item><a class=md-nav__link href=#ray-marching-光线步进> Ray Marching-光线步进 </a> <nav aria-label="Ray Marching-光线步进"class=md-nav><ul class=md-nav__list><li class=md-nav__item><a class=md-nav__link href=#自定义视差函数> 自定义视差函数 </a></li><li class=md-nav__item><a class=md-nav__link href=#相交计算> 相交计算 </a></li><li class=md-nav__item><a class=md-nav__link href=#更多步进> 更多步进 </a></li><li class=md-nav__item><a class=md-nav__link href=#步长之间插值> 步长之间插值 </a></li><li class=md-nav__item><a class=md-nav__link href=#步长搜索> 步长搜索 </a></li><li class=md-nav__item><a class=md-nav__link href=#缩放对象和动态批处理> 缩放对象和动态批处理 </a></li></ul></nav></li></ul></nav></div></div></div><div class=md-content data-md-component=content><article class="md-content__inner md-typeset"><a class="md-content__button md-icon"href=https://github.com/damonc-top/damonc-top.github.io/discussions/posts/unity3d/shader/translater/catlikecoding/2018-01-25-Unity_Parallax_Normals_Heightmap.md title=编辑此页> <svg viewbox="0 0 24 24"xmlns=http://www.w3.org/2000/svg><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25Z"/></svg> </a><h1>视差和法线、高度图回顾(翻译二十)</h1><p>由于视角的原因，当调整摄像机位置时，观察到的事物的相对位置会发生变化，这种视觉现象称为视差。在坐火车高速行驶看窗外的景物，附近的物体看起来很大并且移动很快，而远处的背景看起来很小并且移动较慢。渲染时，相机使用透视模式时，也会出现视差。</p><h2 id=视差纹理>视差纹理<a title="Permanent link"class=headerlink href=#视差纹理></a></h2><p>之前翻译使用过法线贴图将表面不规则感添加到平滑表面。 它会影响照明，但不会影响表面的实际形状。 因此，该效果视差不明显，通过实现法线贴图基于视野深度的幻觉有许多限制。这一篇的目的就是解决该限制。</p><h3 id=法线贴图效果回顾>法线贴图效果回顾<a title="Permanent link"class=headerlink href=#法线贴图效果回顾></a></h3><p>下面给出许多albedo map 和 normal map差异对比：</p><p>{% include img-picture.html url1="posts/2018/month1/catRender20/1692664-20200615181223145-1229624244.png" url2="posts/2018/month1/catRender20/1692664-20200615181223966-473200226.png" des="albedo map 和 normal map" width="250" %}</p><p>如果没有法线贴图，表面看起来很平坦。 添加法线贴图会使它看起来好像具有不规则的表面。 但是，高度海拔差异看起来不明显。 当从入射视角与表面的夹角越趋于0，高度差越不明显。如果高程差异较大，则表面特征的相对视觉位置应由于视差而发生很大变化，但不会发生变化。 我们看到的视差是平坦的表面。</p><p>{% include img-picture.html url1="posts/2018/month1/catRender20/1692664-20200616191420845-1957506928.png" des="平坦的视角" width="250" %}</p><p>虽然可以增加法线贴图的强度，但这不会改变视差。同样，当法线贴图变得太强时，它会看起来很奇怪。它影响了平坦表面的光线的明暗变换，而视差效果它们确实是平的。所以法线贴图只适用于小的变化，但不会表现出明显的视差。</p><p>{% include img-picture.html url1="posts/2018/month1/catRender20/1692664-20200616191421654-712293996.png" des="法线贴图的光线变化" width="250" %}</p><p>要获得真正的深度视差感，<strong>首先</strong>需要确定深度应该是多少。法线贴图不包含这些信息。所以我们需要一个高度图。这样，我们就可以创建一个基于高度信息的假视差效果，就像法线贴图创建一个假斜率一样。下面的贴图也称它是灰度图，黑色代表最低点，白色代表最高点。因为我们将使用这个贴图来创建一个视差效果，也称为视差图。</p><p>{% include img-picture.html url1="posts/2018/month1/catRender20/1692664-20200616191422519-1710373191.png" des="高度图" width="250" %}</p><p>确保在导入时禁用sRGB(颜色纹理)，这样在使用线性空间渲染时数据就不会被弄乱</p><h3 id=shader参数>Shader参数<a title="Permanent link"class=headerlink href=#shader参数></a></h3><p>为了能够使用视差贴图，我们必须为它添加一个属性到着色器。也会给它一个强度参数来缩放效果。因为视差效果相当强，我们将其范围设置为(0 , 0.1)。</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span></pre></div></td><td class=code><div><pre><span></span><code><span class=p>[</span><span class=n>NoScaleOffset</span><span class=p>]</span><span class=w> </span><span class=n>_ParallaxMap</span><span class=w> </span><span class=p>(</span><span class=s>"Parallax"</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=n>D</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>"black"</span><span class=w> </span><span class=p>{}</span><span class=w></span>
<span class=n>_ParallaxStrength</span><span class=w> </span><span class=p>(</span><span class=s>"Parallax Strength"</span><span class=p>,</span><span class=w> </span><span class=n>Range</span><span class=p>(</span><span class=mo>0</span><span class=p>,</span><span class=w> </span><span class=mf>0.1</span><span class=p>))</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mo>0</span><span class=w></span>

<span class=p>[</span><span class=n>NoScaleOffset</span><span class=p>]</span><span class=w> </span><span class=n>_OcclusionMap</span><span class=w> </span><span class=p>(</span><span class=s>"Occlusion"</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=n>D</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>"white"</span><span class=w> </span><span class=p>{}</span><span class=w></span>
<span class=n>_OcclusionStrength</span><span class=w> </span><span class=p>(</span><span class=s>"Occlusion Strength"</span><span class=p>,</span><span class=w> </span><span class=n>Range</span><span class=p>(</span><span class=mo>0</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>))</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=w></span>
</code></pre></div></td></tr></table></div><p>视差贴图是一个着色器特性，我们将启用__PARALLAX_MAP_关键字。将必需的编译器指令添加到base pass、additive pass和deferred pass。</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span></pre></div></td><td class=code><div><pre><span></span><code><span class=cp>#pragma shader_feature _NORMAL_MAP</span><span class=w></span>
<span class=cp>#pragma shader_feature _PARALLAX_MAP</span><span class=w></span>
</code></pre></div></td></tr></table></div><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span></pre></div></td><td class=code><div><pre><span></span><code>为什么不在ShadowCaster增加视差贴图？
当使用albedo贴图的alpha通道的透明度时，视差贴图只会影响阴影。即使是这样，在阴影贴图中的视差效果也很难被注意到。所以它通常不值得额外的计算时间。但是如果愿意，也可以将它添加到阴影施法者通道中。
</code></pre></div></td></tr></table></div><p>为了访问新的属性，给我的照明添加相应的变量</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span></pre></div></td><td class=code><div><pre><span></span><code><span class=n>sampler2D</span><span class=w> </span><span class=n>_ParallaxMap</span><span class=p>;</span><span class=w></span>
<span class=kt>float</span><span class=w> </span><span class=n>_ParallaxStrength</span><span class=p>;</span><span class=w></span>

<span class=n>sampler2D</span><span class=w> </span><span class=n>_OcclusionMap</span><span class=p>;</span><span class=w></span>
<span class=kt>float</span><span class=w> </span><span class=n>_OcclusionStrength</span><span class=p>;</span><span class=w></span>
</code></pre></div></td></tr></table></div><p>为了能够自定义配置材质，在Extend ShaderGUI扩展中增加相应Enable与Disanble key的方法。</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>void</span><span class=w> </span><span class=nf>DoParallax</span><span class=w> </span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w></span>
<span class=w>    </span><span class=n>MaterialProperty</span><span class=w> </span><span class=n>map</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=n>FindProperty</span><span class=p>(</span><span class=s>"_ParallaxMap"</span><span class=p>);</span><span class=w></span>
<span class=w>    </span><span class=n>Texture</span><span class=w> </span><span class=n>tex</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=n>map</span><span class=p>.</span><span class=n>textureValue</span><span class=p>;</span><span class=w></span>
<span class=w>    </span><span class=n>EditorGUI</span><span class=p>.</span><span class=n>BeginChangeCheck</span><span class=p>();</span><span class=w></span>
<span class=w>    </span><span class=n>editor</span><span class=p>.</span><span class=n>TexturePropertySingleLine</span><span class=w></span>
<span class=w>    </span><span class=p>(</span><span class=w></span>
<span class=w>        </span><span class=n>MakeLabel</span><span class=p>(</span><span class=n>map</span><span class=p>,</span><span class=w> </span><span class=s>"Parallax (G)"</span><span class=p>),</span><span class=w> </span><span class=n>map</span><span class=p>,</span><span class=w></span>
<span class=w>        </span><span class=n>tex</span><span class=w> </span><span class=p>?</span><span class=w> </span><span class=n>FindProperty</span><span class=p>(</span><span class=s>"_ParallaxStrength"</span><span class=p>)</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=k>null</span><span class=w></span>
<span class=w>    </span><span class=p>);</span><span class=w></span>
<span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>EditorGUI</span><span class=p>.</span><span class=n>EndChangeCheck</span><span class=p>()</span><span class=w> </span><span class=p>&&</span><span class=w> </span><span class=n>tex</span><span class=w> </span><span class=p>!=</span><span class=w> </span><span class=n>map</span><span class=p>.</span><span class=n>textureValue</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w></span>
<span class=w>        </span><span class=n>SetKeyword</span><span class=p>(</span><span class=s>"_PARALLAX_MAP"</span><span class=p>,</span><span class=w> </span><span class=n>map</span><span class=p>.</span><span class=n>textureValue</span><span class=p>);</span><span class=w></span>
<span class=w>    </span><span class=p>}</span><span class=w></span>
<span class=p>}</span><span class=w></span>
</code></pre></div></td></tr></table></div><p>{% include img-picture.html url1="posts/2018/month1/catRender20/1692664-20200616191423089-347056836.png" width="250" %}</p><h3 id=坐标匹配>坐标匹配<a title="Permanent link"class=headerlink href=#坐标匹配></a></h3><p>通过在fragment程序中调整纹理坐标，让平坦表面的某些部分看起来高低交错。创建一个应用视差函数，给它一个inout插值器参数。</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span></pre></div></td><td class=code><div><pre><span></span><code><span class=kt>void</span><span class=w> </span><span class=n>ApplyParallax</span><span class=w> </span><span class=p>(</span><span class=k>inout</span><span class=w> </span><span class=n>Interpolators</span><span class=w> </span><span class=n>i</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w></span>
<span class=p>}</span><span class=w></span>
</code></pre></div></td></tr></table></div><p>在fragment程序使用插入的数据之前调用视差函数。_会有点异常是LOD衰落，_因为这取决于屏幕位置。先不调整这些坐标。</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span></pre></div></td><td class=code><div><pre><span></span><code><span class=n>FragmentOutput</span><span class=w> </span><span class=n>MyFragmentProgram</span><span class=w> </span><span class=p>(</span><span class=n>Interpolators</span><span class=w> </span><span class=n>i</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w></span>
<span class=w>    </span><span class=n>UNITY_SETUP_INSTANCE_ID</span><span class=p>(</span><span class=n>i</span><span class=p>);</span><span class=w></span>
<span class=w>    </span><span class=err>#</span><span class=k>if</span><span class=w> </span><span class=o>defined</span><span class=p>(</span><span class=n>LOD_FADE_CROSSFADE</span><span class=p>)</span><span class=w></span>
<span class=w>        </span><span class=n>UnityApplyDitherCrossFade</span><span class=p>(</span><span class=n>i</span><span class=p>.</span><span class=n>vpos</span><span class=p>);</span><span class=w></span>
<span class=w>    </span><span class=err>#</span><span class=n>endif</span><span class=w></span>

<span class=w>    </span><span class=n>ApplyParallax</span><span class=p>(</span><span class=n>i</span><span class=p>);</span><span class=w></span>

<span class=w>    </span><span class=kt>float</span><span class=w> </span><span class=n>alpha</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>GetAlpha</span><span class=p>(</span><span class=n>i</span><span class=p>);</span><span class=w></span>
<span class=w>    </span><span class=err>#</span><span class=k>if</span><span class=w> </span><span class=o>defined</span><span class=p>(</span><span class=n>_RENDERING_CUTOUT</span><span class=p>)</span><span class=w></span>
<span class=w>        </span><span class=nb>clip</span><span class=p>(</span><span class=n>alpha</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>_Cutoff</span><span class=p>);</span><span class=w></span>
<span class=w>    </span><span class=err>#</span><span class=n>endif</span><span class=w></span>
<span class=p>}</span><span class=w></span>
</code></pre></div></td></tr></table></div><p>通过简单地向U坐标添加视差强度来调整纹理坐标。做一次偏移计算</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span></pre></div></td><td class=code><div><pre><span></span><code><span class=kt>void</span><span class=w> </span><span class=n>ApplyParallax</span><span class=w> </span><span class=p>(</span><span class=k>inout</span><span class=w> </span><span class=n>Interpolators</span><span class=w> </span><span class=n>i</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w></span>
<span class=w>    </span><span class=err>#</span><span class=k>if</span><span class=w> </span><span class=o>defined</span><span class=p>(</span><span class=n>_PARALLAX_MAP</span><span class=p>)</span><span class=w></span>
<span class=w>        </span><span class=n>i</span><span class=p>.</span><span class=n>uv</span><span class=p>.</span><span class=n>x</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>_ParallaxStrength</span><span class=p>;</span><span class=w></span>
<span class=w>    </span><span class=err>#</span><span class=n>endif</span><span class=w></span>
<span class=p>}</span><span class=w></span>
</code></pre></div></td></tr></table></div><p>改变视差强度会导致纹理偏移。增加U坐标会使纹理向负的U方向移动，V坐标同理。这看起来不是视差效果，因为这是一个与视角无关的均匀位移。</p><p>{% include img-picture.html url1="posts/2018/month1/catRender20/1692664-20200618012938981-982216259.gif" des="u坐标移动" width="250" %}</p><h3 id=随视角方向移动>随视角方向移动<a title="Permanent link"class=headerlink href=#随视角方向移动></a></h3><p>视差是由相对于观察者的透视投影，所以必须改变纹理坐标。这意味着必须基于视图的方向来移动坐标，而视图的方向对于表面上每个片段都是不同的。</p><p>{% include img-picture.html url1="posts/2018/month1/catRender20/1692664-20200617192759952-594530144.png" des="varies across a surface" width="250" %}</p><p>纹理坐标存在于切线空间中。为了调整这些坐标，需要知道视图在切线空间中的方向。这需要矩阵乘法对空间进行转换。在fragment-程序已经有了一个切线空间矩阵，但是它是用于从切线空间到世界空间的转换。在本例中，需要从对象空间转到切线空间。</p><p>视图方向向量定义为从表面到摄像机，需要归一化。我们可以在vertex程序中确定这个向量，转换它并将它传递给fragment程序。但是为了最终得到正确的方向，需要推迟归一化，直到插值完成后。添加切线空间视图方向作为一个新的插值成员变量。</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>struct</span><span class=w> </span><span class=n>InterpolatorsVertex</span><span class=w> </span><span class=p>{</span><span class=w></span>
<span class=w>    </span><span class=err>#</span><span class=k>if</span><span class=w> </span><span class=o>defined</span><span class=p>(</span><span class=n>_PARALLAX_MAP</span><span class=p>)</span><span class=w></span>
<span class=w>        </span><span class=kt>float3</span><span class=w> </span><span class=n>tangentViewDir</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>TEXCOORD8</span><span class=p>;</span><span class=w></span>
<span class=w>    </span><span class=err>#</span><span class=n>endif</span><span class=w></span>
<span class=p>};</span><span class=w></span>

<span class=k>struct</span><span class=w> </span><span class=n>Interpolators</span><span class=w> </span><span class=p>{</span><span class=w></span>
<span class=w>    </span><span class=err>#</span><span class=k>if</span><span class=w> </span><span class=o>defined</span><span class=p>(</span><span class=n>_PARALLAX_MAP</span><span class=p>)</span><span class=w></span>
<span class=w>        </span><span class=kt>float3</span><span class=w> </span><span class=n>tangentViewDir</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>TEXCOORD8</span><span class=p>;</span><span class=w></span>
<span class=w>    </span><span class=err>#</span><span class=n>endif</span><span class=w></span>
<span class=p>};</span><span class=w></span>
</code></pre></div></td></tr></table></div><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span></pre></div></td><td class=code><div><pre><span></span><code>寄存器数量限制是多少?
model 1与model 2都只支持8个Texture Coordinate Register ->Texcoord[0-7]。当使用model 3时，可以使用TEXCOORD8。若硬件不支持model 3其机能也就不是很强大，所以不要使用视差映射。
</code></pre></div></td></tr></table></div><p><strong>首先</strong>, 使用mesh网格数据中的原始顶点切向量和法向量，在顶点程序中创建一个从对象空间到切线空间的转换矩阵。因为我们只用它来变换一个向量而不是一个位置我们用一个3×3矩阵就足够了。</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span></pre></div></td><td class=code><div><pre><span></span><code><span class=n>InterpolatorsVertex</span><span class=w> </span><span class=n>MyVertexProgram</span><span class=w> </span><span class=p>(</span><span class=n>VertexData</span><span class=w> </span><span class=n>v</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w></span>
<span class=w>    </span><span class=n>ComputeVertexLightColor</span><span class=p>(</span><span class=n>i</span><span class=p>);</span><span class=w></span>

<span class=w>    </span><span class=err>#</span><span class=k>if</span><span class=w> </span><span class=o>defined</span><span class=w> </span><span class=p>(</span><span class=n>_PARALLAX_MAP</span><span class=p>)</span><span class=w></span>
<span class=w>        </span><span class=kt>float3x3</span><span class=w> </span><span class=n>objectToTangent</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kt>float3x3</span><span class=p>(</span><span class=w></span>
<span class=w>            </span><span class=n>v</span><span class=p>.</span><span class=n>tangent</span><span class=p>.</span><span class=n>xyz</span><span class=p>,</span><span class=w></span>
<span class=w>            </span><span class=nb>cross</span><span class=p>(</span><span class=n>v</span><span class=p>.</span><span class=n>normal</span><span class=p>,</span><span class=w> </span><span class=n>v</span><span class=p>.</span><span class=n>tangent</span><span class=p>.</span><span class=n>xyz</span><span class=p>)</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>v</span><span class=p>.</span><span class=n>tangent</span><span class=p>.</span><span class=n>w</span><span class=p>,</span><span class=w></span>
<span class=w>            </span><span class=n>v</span><span class=p>.</span><span class=n>normal</span><span class=w></span>
<span class=w>        </span><span class=p>);</span><span class=w></span>
<span class=w>    </span><span class=err>#</span><span class=n>endif</span><span class=w></span>

<span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>i</span><span class=p>;</span><span class=w></span>
<span class=p>}</span><span class=w></span>
</code></pre></div></td></tr></table></div><p><strong>然后</strong>，可以使用<code>ObjSpaceViewDir</code>函数得到对象空间中顶点位置的视图方向，再用矩阵变换它我们就得到了我们需要的切线空间下视图方向。</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span>
<span class=normal>6</span>
<span class=normal>7</span>
<span class=normal>8</span>
<span class=normal>9</span></pre></div></td><td class=code><div><pre><span></span><code><span class=cp>#if defined (_PARALLAX_MAP)</span><span class=w></span>
<span class=w>    </span><span class=kt>float3x3</span><span class=w> </span><span class=n>objectToTangent</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kt>float3x3</span><span class=w></span>
<span class=w>    </span><span class=p>(</span><span class=w></span>
<span class=w>        </span><span class=n>v</span><span class=p>.</span><span class=n>tangent</span><span class=p>.</span><span class=n>xyz</span><span class=p>,</span><span class=w></span>
<span class=w>        </span><span class=nb>cross</span><span class=p>(</span><span class=n>v</span><span class=p>.</span><span class=n>normal</span><span class=p>,</span><span class=w> </span><span class=n>v</span><span class=p>.</span><span class=n>tangent</span><span class=p>.</span><span class=n>xyz</span><span class=p>)</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>v</span><span class=p>.</span><span class=n>tangent</span><span class=p>.</span><span class=n>w</span><span class=p>,</span><span class=w></span>
<span class=w>        </span><span class=n>v</span><span class=p>.</span><span class=n>normal</span><span class=w></span>
<span class=w>    </span><span class=p>);</span><span class=w></span>
<span class=w>    </span><span class=n>i</span><span class=p>.</span><span class=n>tangentViewDir</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>mul</span><span class=p>(</span><span class=n>objectToTangent</span><span class=p>,</span><span class=w> </span><span class=n>ObjSpaceViewDir</span><span class=p>(</span><span class=n>v</span><span class=p>.</span><span class=n>vertex</span><span class=p>));</span><span class=w></span>
<span class=cp>#endif</span><span class=w></span>
</code></pre></div></td></tr></table></div><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span>
<span class=normal>6</span>
<span class=normal>7</span>
<span class=normal>8</span></pre></div></td><td class=code><div><pre><span></span><code><span class=c1>//ObjSpaceViewDir内部实现?</span><span class=w></span>
<span class=c1>//ObjSpaceViewDir函数是在UnityCG中定义的。它先将摄像机位置转换到对象空间，然后减去对象空间下顶点位置得到一个从顶点指向摄像机的向量，注意它还没有标准化.</span><span class=w></span>

<span class=k>inline</span><span class=w> </span><span class=kt>float3</span><span class=w> </span><span class=n>ObjSpaceViewDir</span><span class=w> </span><span class=p>(</span><span class=kt>float4</span><span class=w> </span><span class=n>v</span><span class=p>)</span><span class=w></span>
<span class=p>{</span><span class=w></span>
<span class=w>    </span><span class=kt>float3</span><span class=w> </span><span class=n>objSpaceCameraPos</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>mul</span><span class=p>(</span><span class=n>unity_WorldToObject</span><span class=p>,</span><span class=w> </span><span class=kt>float4</span><span class=p>(</span><span class=n>_WorldSpaceCameraPos</span><span class=p>.</span><span class=n>xyz</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>)).</span><span class=n>xyz</span><span class=p>;</span><span class=w></span>
<span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>objSpaceCameraPos</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>v</span><span class=p>.</span><span class=n>xyz</span><span class=p>;</span><span class=w></span>
<span class=p>}</span><span class=w></span>
</code></pre></div></td></tr></table></div><p><strong>最后</strong>，我们可以在ApplyParallax函数使用切线空间视图方向了。首先，对它进行规格化normalize，把它变成一个合适的方向向量。然后，添加它的XY组件到纹理坐标，再由视差强度缩放。</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span>
<span class=normal>6</span></pre></div></td><td class=code><div><pre><span></span><code><span class=kt>void</span><span class=w> </span><span class=n>ApplyParallax</span><span class=w> </span><span class=p>(</span><span class=k>inout</span><span class=w> </span><span class=n>Interpolators</span><span class=w> </span><span class=n>i</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w></span>
<span class=w>    </span><span class=err>#</span><span class=k>if</span><span class=w> </span><span class=o>defined</span><span class=p>(</span><span class=n>_PARALLAX_MAP</span><span class=p>)</span><span class=w></span>
<span class=w>        </span><span class=n>i</span><span class=p>.</span><span class=n>tangentViewDir</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>normalize</span><span class=p>(</span><span class=n>i</span><span class=p>.</span><span class=n>tangentViewDir</span><span class=p>);</span><span class=w></span>
<span class=w>        </span><span class=n>i</span><span class=p>.</span><span class=n>uv</span><span class=p>.</span><span class=n>xy</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>i</span><span class=p>.</span><span class=n>tangentViewDir</span><span class=p>.</span><span class=n>xy</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>_ParallaxStrength</span><span class=p>;</span><span class=w></span>
<span class=w>    </span><span class=err>#</span><span class=n>endif</span><span class=w></span>
<span class=p>}</span><span class=w></span>
</code></pre></div></td></tr></table></div><p>这能有效地将视图方向投影到纹理表面上。当以90度角直视表面时，在切空间中的视图方向等于表面法线(0,0,1)，这不会导致位移。视角越浅，投影越大，位移效果也越大。</p><p>{% include img-picture.html url1="posts/2018/month1/catRender20/1692664-20200617192800432-1757806048.png" des="影视图方向用作UV偏移" width="250" %}</p><p>所有这一切的影响是表面似乎被拉向上的切线空间，看起来比它实际上更高，基于视差强度。</p><p>{% include img-picture.html url1="posts/2018/month1/catRender20/1692664-20200618012940748-384205609.gif" des="随投影视角方向移动UV" width="250" %}</p><h3 id=基于高度滑动>基于高度滑动<a title="Permanent link"class=headerlink href=#基于高度滑动></a></h3><p>在基于高度这一点上，我们可以让表面看起来更高，但它仍然是一个均匀位移。下一步是使用视差贴图来缩放位移。采样贴图，使用它的G通道作为高度，应用视差强度，并使用它来调节位移。</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span></pre></div></td><td class=code><div><pre><span></span><code><span class=n>i</span><span class=p>.</span><span class=n>tangentViewDir</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>normalize</span><span class=p>(</span><span class=n>i</span><span class=p>.</span><span class=n>tangentViewDir</span><span class=p>);</span><span class=w></span>
<span class=kt>float</span><span class=w> </span><span class=n>height</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>tex2D</span><span class=p>(</span><span class=n>_ParallaxMap</span><span class=p>,</span><span class=w> </span><span class=n>i</span><span class=p>.</span><span class=n>uv</span><span class=p>.</span><span class=n>xy</span><span class=p>).</span><span class=n>g</span><span class=p>;</span><span class=w></span>
<span class=n>height</span><span class=w> </span><span class=o>*=</span><span class=w> </span><span class=n>_ParallaxStrength</span><span class=p>;</span><span class=w></span>
<span class=n>i</span><span class=p>.</span><span class=n>uv</span><span class=p>.</span><span class=n>xy</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>i</span><span class=p>.</span><span class=n>tangentViewDir</span><span class=p>.</span><span class=n>xy</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>height</span><span class=p>;</span><span class=w></span>
</code></pre></div></td></tr></table></div><p>{% include img-picture.html url1="posts/2018/month1/catRender20/1692664-20200618012942351-290008046.gif" des="由高度调整的移动" width="250" %}</p><p>低的区域现在保持不变，而高的区域被向上拉。standard shader抵消了这种效果，所以低的区域也向下移动，而在中间的区域保持他们原来的位置。这是通过从原始高度数据中减去差值来实现的。</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span></pre></div></td><td class=code><div><pre><span></span><code><span class=kt>float</span><span class=w> </span><span class=n>height</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>tex2D</span><span class=p>(</span><span class=n>_ParallaxMap</span><span class=p>,</span><span class=w> </span><span class=n>i</span><span class=p>.</span><span class=n>uv</span><span class=p>.</span><span class=n>xy</span><span class=p>).</span><span class=n>g</span><span class=p>;</span><span class=w></span>
<span class=n>height</span><span class=w> </span><span class=o>-=</span><span class=w> </span><span class=mf>0.5</span><span class=p>;</span><span class=w></span>
<span class=n>height</span><span class=w> </span><span class=o>*=</span><span class=w> </span><span class=n>_ParallaxStrength</span><span class=p>;</span><span class=w></span>
</code></pre></div></td></tr></table></div><p>{% include img-picture.html url1="posts/2018/month1/catRender20/1692664-20200618012944095-1997194416.gif" des="视差贴图效果 由合理到过量" width="250" %}</p><p>这就产生了我们想要的视差效果，但它只在低强度下有效。不足的是位移位移变换的很快，会撕裂表面。</p><h3 id=偏移视差映射算法>偏移视差映射算法<a title="Permanent link"class=headerlink href=#偏移视差映射算法></a></h3><p>我们目前使用的视差映射技术被称为带偏移限制的视差映射。我们只是使用了视图方向的XY部分，它的最大长度是1。因此，纹理偏移量是有限的。这种效果不错，但不能代表正确的透视投影。</p><p>一个更精确的计算偏移量的物理方法是将高度场视为几何图形表面下的体积，并通过它拍摄一个视图射线。光线从相机发射到表面，从上面进入高度场体积，并持续发射直到它到达由场定义的表面。</p><p>如果高度场均匀为零，那么射线就会一直持续到体积的底部。它与物体的距离取决于光线进入物体时的角度。它没有限制。角度越浅，越远。最极端的情况是当视角趋于0时，光线射向无穷大。</p><p>{% include img-picture.html url1="posts/2018/month1/catRender20/1692664-20200617192800958-1980748310.png" des="光线投射到底部，有限且正确" width="250" %}</p><p>为了找到合适的偏移量，我们必须缩放视图方向向量，通过除以它自己的Z分量来使它的Z分量变成1。因为我们以后不需要用Z，我们只需要用X和Y除以Z。</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span></pre></div></td><td class=code><div><pre><span></span><code><span class=n>i</span><span class=p>.</span><span class=n>tangentViewDir</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>normalize</span><span class=p>(</span><span class=n>i</span><span class=p>.</span><span class=n>tangentViewDir</span><span class=p>);</span><span class=w></span>
<span class=n>i</span><span class=p>.</span><span class=n>tangentViewDir</span><span class=p>.</span><span class=n>xy</span><span class=w> </span><span class=o>/=</span><span class=w> </span><span class=n>i</span><span class=p>.</span><span class=n>tangentViewDir</span><span class=p>.</span><span class=n>z</span><span class=p>;</span><span class=w></span>
</code></pre></div></td></tr></table></div><p>虽然这样可以得到一个更正确的投影，但它确实会使浅视角的视差效果恶化。standard着色器通过增加0.42偏差到Z减轻浅视角的视差效果恶化，所以它永远不会接近零。这扭曲了透视图，但使工件更易于管理。我们再加上这个偏差.</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span></pre></div></td><td class=code><div><pre><span></span><code><span class=n>i</span><span class=p>.</span><span class=n>tangentViewDir</span><span class=p>.</span><span class=n>xy</span><span class=w> </span><span class=o>/=</span><span class=w> </span><span class=p>(</span><span class=n>i</span><span class=p>.</span><span class=n>tangentViewDir</span><span class=p>.</span><span class=n>z</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mf>0.42</span><span class=p>);</span><span class=w></span>
</code></pre></div></td></tr></table></div><p>{% include img-picture.html url1="posts/2018/month1/catRender20/1692664-20200617192802151-218582125.png" des="视差贴图像标准着色器" width="250" %}</p><p>通过上述多个步骤修正后, 现在我们的着色器与标准着色器支持同样的视差效果。视差映射可以应用于任何表面，投影假设切线空间是均匀的。曲面具有弯曲的切线空间，因此会产生物理上不正确的结果。只要视差强度和曲率很小，你就可以摆脱它。</p><p>{% include img-picture.html url1="posts/2018/month1/catRender20/1692664-20200617192802555-2049613835.png" des="球面视差贴图" width="250" %}</p><p>同样，阴影坐标不会受到这个效果的影响。因此，阴影在强烈的视差的组合下看起来很奇怪，好像漂浮在表面上。</p><p>{% include img-picture.html url1="posts/2018/month1/catRender20/1692664-20200617192803371-1931947503.png" des="阴影不受视差影响" width="250" %}</p><h3 id=parallax-configuration>Parallax Configuration<a title="Permanent link"class=headerlink href=#parallax-configuration></a></h3><p>你不同意Unity使用0.42的偏移值吗?或者你想使用一个不同的值，还是让它保持在0?或者你想用偏移限制代替吗?它是可以配置!</p><p>当你想使用偏移限制，定义<code>PARALLAX_OFFSET_LIMITING</code>在着色器。或者，通过定义PARALLAX_BIAS来设置要使用的偏差。</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span>
<span class=normal>6</span>
<span class=normal>7</span>
<span class=normal>8</span></pre></div></td><td class=code><div><pre><span></span><code><span class=kt>void</span><span class=w> </span><span class=n>ApplyParallax</span><span class=w> </span><span class=p>(</span><span class=k>inout</span><span class=w> </span><span class=n>Interpolators</span><span class=w> </span><span class=n>i</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w></span>
<span class=w>    </span><span class=err>#</span><span class=k>if</span><span class=w> </span><span class=o>defined</span><span class=p>(</span><span class=n>_PARALLAX_MAP</span><span class=p>)</span><span class=w></span>
<span class=w>        </span><span class=n>i</span><span class=p>.</span><span class=n>tangentViewDir</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>normalize</span><span class=p>(</span><span class=n>i</span><span class=p>.</span><span class=n>tangentViewDir</span><span class=p>);</span><span class=w></span>
<span class=w>        </span><span class=err>#</span><span class=k>if</span><span class=w> </span><span class=o>!defined</span><span class=p>(</span><span class=n>PARALLAX_OFFSET_LIMITING</span><span class=p>)</span><span class=w></span>
<span class=w>            </span><span class=n>i</span><span class=p>.</span><span class=n>tangentViewDir</span><span class=p>.</span><span class=n>xy</span><span class=w> </span><span class=o>/=</span><span class=w> </span><span class=p>(</span><span class=n>i</span><span class=p>.</span><span class=n>tangentViewDir</span><span class=p>.</span><span class=n>z</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>PARALLAX_BIAS</span><span class=p>);</span><span class=w></span>
<span class=w>        </span><span class=err>#</span><span class=n>endif</span><span class=w></span>
<span class=w>    </span><span class=err>#</span><span class=n>endif</span><span class=w></span>
<span class=p>}</span><span class=w></span>
</code></pre></div></td></tr></table></div><p>当没有定义时，假设偏差是0.42。在<code>ApplyParallax</code> 中定义它。注意，宏定义不关心函数作用域，它们总是全局的。</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span>
<span class=normal>6</span></pre></div></td><td class=code><div><pre><span></span><code><span class=cp>#if !defined(PARALLAX_OFFSET_LIMITING)</span><span class=w></span>
<span class=w>    </span><span class=err>#</span><span class=k>if</span><span class=w> </span><span class=o>!defined</span><span class=p>(</span><span class=n>PARALLAX_BIAS</span><span class=p>)</span><span class=w></span>
<span class=w>        </span><span class=err>#</span><span class=n>define</span><span class=w> </span><span class=n>PARALLAX_BIAS</span><span class=w> </span><span class=mf>0.42</span><span class=w></span>
<span class=w>    </span><span class=err>#</span><span class=n>endif</span><span class=w></span>
<span class=w>    </span><span class=n>i</span><span class=p>.</span><span class=n>tangentViewDir</span><span class=p>.</span><span class=n>xy</span><span class=w> </span><span class=o>/=</span><span class=w> </span><span class=p>(</span><span class=n>i</span><span class=p>.</span><span class=n>tangentViewDir</span><span class=p>.</span><span class=n>z</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>PARALLAX_BIAS</span><span class=p>);</span><span class=w></span>
<span class=cp>#endif</span><span class=w></span>
</code></pre></div></td></tr></table></div><p>现在我们可以通过着色器的CGINCLUDE块来微调我们的视差效果。添加无偏差和限制偏移的选项，但将它们转换为注释，以坚持默认选项。</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span>
<span class=normal>6</span>
<span class=normal>7</span>
<span class=normal>8</span></pre></div></td><td class=code><div><pre><span></span><code><span class=n>CGINCLUDE</span><span class=w></span>
<span class=w>    </span><span class=err>#</span><span class=n>define</span><span class=w> </span><span class=n>BINORMAL_PER_FRAGMENT</span><span class=w></span>
<span class=w>    </span><span class=err>#</span><span class=n>define</span><span class=w> </span><span class=n>FOG_DISTANCE</span><span class=w></span>

<span class=c1>//  #define PARALLAX_BIAS 0</span><span class=w></span>
<span class=c1>//  #define PARALLAX_OFFSET_LIMITING</span><span class=w></span>

<span class=n>ENDCG</span><span class=w></span>
</code></pre></div></td></tr></table></div><h3 id=detail-uv>Detail UV<a title="Permanent link"class=headerlink href=#detail-uv></a></h3><p>视差贴图可以在主贴图上工作，但是我们还没有注意到副贴图。我们必须应用纹理坐标偏移到细节UV上。</p><p>首先，下面是一个包含网格模式的详细地图。它可以很容易地验证效果是否正确地应用于细节。</p><p>{% include img-picture.html url1="posts/2018/month1/catRender20/1692664-20200617192803893-1797850325.png" des="细节网格纹理" width="250" %}</p><p>使用这个纹理作为材质的细节albedo贴图。设置二级贴图的平铺为10×10。这表明，细节紫外线确实仍然不受影响。</p><p>{% include img-picture.html url1="posts/2018/month1/catRender20/1692664-20200617192804491-290326603.png" url2="posts/2018/month1/catRender20/1692664-20200617192805295-1360127209.png" des="细节UV不受影响" width="250" %}</p><p>Standard也简单地添加了UV偏移到细节UV，这是存储在UV插值器的ZW组件。</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span>
<span class=normal>6</span></pre></div></td><td class=code><div><pre><span></span><code><span class=kt>float</span><span class=w> </span><span class=n>height</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>tex2D</span><span class=p>(</span><span class=n>_ParallaxMap</span><span class=p>,</span><span class=w> </span><span class=n>i</span><span class=p>.</span><span class=n>uv</span><span class=p>.</span><span class=n>xy</span><span class=p>).</span><span class=n>g</span><span class=p>;</span><span class=w></span>
<span class=n>height</span><span class=w> </span><span class=o>-=</span><span class=w> </span><span class=mf>0.5</span><span class=p>;</span><span class=w></span>
<span class=n>height</span><span class=w> </span><span class=o>*=</span><span class=w> </span><span class=n>_ParallaxStrength</span><span class=p>;</span><span class=w></span>
<span class=kt>float2</span><span class=w> </span><span class=n>uvOffset</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>i</span><span class=p>.</span><span class=n>tangentViewDir</span><span class=p>.</span><span class=n>xy</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>height</span><span class=p>;</span><span class=w></span>
<span class=n>i</span><span class=p>.</span><span class=n>uv</span><span class=p>.</span><span class=n>xy</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>uvOffset</span><span class=p>;</span><span class=w></span>
<span class=n>i</span><span class=p>.</span><span class=n>uv</span><span class=p>.</span><span class=n>zw</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>uvOffset</span><span class=p>;</span><span class=w></span>
</code></pre></div></td></tr></table></div><p>细节可能有所变化，但是它们肯定还不匹配视差效果。 那是因为我们平铺了二级纹理。 这样会将细节UV缩放10倍，使视差偏移量变弱十倍。 我们还必须将细节拼贴应用到偏移量。</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span></pre></div></td><td class=code><div><pre><span></span><code><span class=n>i</span><span class=p>.</span><span class=n>uv</span><span class=p>.</span><span class=n>zw</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>uvOffset</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>_DetailTex_ST</span><span class=p>.</span><span class=n>xy</span><span class=p>;</span><span class=w></span>
</code></pre></div></td></tr></table></div><p>实际上，缩放应该相对于主UV平铺，以防它被设置为1×1以外的一些东西。</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span></pre></div></td><td class=code><div><pre><span></span><code><span class=n>i</span><span class=p>.</span><span class=n>uv</span><span class=p>.</span><span class=n>zw</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>uvOffset</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=p>(</span><span class=n>_DetailTex_ST</span><span class=p>.</span><span class=n>xy</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=n>_MainTex_ST</span><span class=p>.</span><span class=n>xy</span><span class=p>);</span><span class=w></span>
</code></pre></div></td></tr></table></div><p>{% include img-picture.html url1="posts/2018/month1/catRender20/1692664-20200617192806533-2106069113.png" des="正确的UV" width="250" %}</p><h2 id=ray-marching-光线步进>Ray Marching-光线步进<a title="Permanent link"class=headerlink href=#ray-marching-光线步进></a></h2><p>然而，除了上述的偏移视差映射还有另外的视差算法：发射射线与高度场体积相交，确定其交点在表面上的位置，然后对该位置采样。 它通过在射线进入体积时的交点，对高度图进行一次采样。 但是，当看向任意一个角度时，这并不能准确告诉射线实际上与高度场相交的高度。</p><p>{% include img-picture.html url1="posts/2018/month1/catRender20/1692664-20200617192807160-2024700857.png" des="实际与预测的高度对比" width="250" %}</p><p>先假设入口点的高度与交点的高度相同，但这实际上只有在入口点和交点具有相同的高度时才是正确的。当偏移量不大且高度场变化不大时，它的效果仍然很好。但是，当偏移量太大或高度变化太快时，该算法就会出现问题，而这很可能是错误的。这就会造成表面撕裂。</p><p>如果我们能算出射线实际到达的高度场的位置，那么总能找到真正的可见表面点。这不能通过单个纹理样本来实现，我们必须沿着视图射线逐步移动，并每次都采样高度场，直到射线到达表面。该技术是RayMarching。</p><p>{% include img-picture.html url1="posts/2018/month1/catRender20/1692664-20200617192807679-1545265192.png" des="随视图射线前进" width="250" %}</p><p>有各种不同的视差贴图使用raymarching。常见的是陡视差映射_Steep Parallax Mapping_、地形映射_Relief Mapping_和视差遮挡映射_Parallax Occlusion Mapping_。与使用单一纹理样本相比，它们能通过高度场来创建更好的视差效果。除此之外，它们还可以应用额外的阴影和技术来改进该算法。当我们做的匹配这些方法时，我会调用它。</p><h3 id=自定义视差函数>自定义视差函数<a title="Permanent link"class=headerlink href=#自定义视差函数></a></h3><p>标准着色器仅支持简单的偏移视差映射。 现在，我们要在自己的着色器中添加对视差光线Ray marching的支持。 但是，我们还要继续支持这种简单方法。 两者都需要采样height字段，因此将采样代码行放在单独的GetParallaxHeight函数中。 而且，两种方法的投影视图方向和偏移量的最终应用都相同。 因此，将偏移量计算也单独为一个函数。 它仅需要原始UV坐标和已处理的视图方向作为参数，结果返回要应用的UV偏移。</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span>
<span class=normal>22</span>
<span class=normal>23</span>
<span class=normal>24</span>
<span class=normal>25</span>
<span class=normal>26</span></pre></div></td><td class=code><div><pre><span></span><code><span class=kt>float</span><span class=w> </span><span class=n>GetParallaxHeight</span><span class=w> </span><span class=p>(</span><span class=kt>float2</span><span class=w> </span><span class=n>uv</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w></span>
<span class=w>    </span><span class=k>return</span><span class=w> </span><span class=nb>tex2D</span><span class=p>(</span><span class=n>_ParallaxMap</span><span class=p>,</span><span class=w> </span><span class=n>uv</span><span class=p>).</span><span class=n>g</span><span class=p>;</span><span class=w></span>
<span class=p>}</span><span class=w></span>

<span class=kt>float2</span><span class=w> </span><span class=n>ParallaxOffset</span><span class=w> </span><span class=p>(</span><span class=kt>float2</span><span class=w> </span><span class=n>uv</span><span class=p>,</span><span class=w> </span><span class=kt>float2</span><span class=w> </span><span class=n>viewDir</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w></span>
<span class=w>    </span><span class=kt>float</span><span class=w> </span><span class=n>height</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>GetParallaxHeight</span><span class=p>(</span><span class=n>uv</span><span class=p>);</span><span class=w></span>
<span class=w>    </span><span class=n>height</span><span class=w> </span><span class=o>-=</span><span class=w> </span><span class=mf>0.5</span><span class=p>;</span><span class=w></span>
<span class=w>    </span><span class=n>height</span><span class=w> </span><span class=o>*=</span><span class=w> </span><span class=n>_ParallaxStrength</span><span class=p>;</span><span class=w></span>
<span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>viewDir</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>height</span><span class=p>;</span><span class=w></span>
<span class=p>}</span><span class=w></span>

<span class=kt>void</span><span class=w> </span><span class=n>ApplyParallax</span><span class=w> </span><span class=p>(</span><span class=k>inout</span><span class=w> </span><span class=n>Interpolators</span><span class=w> </span><span class=n>i</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w></span>
<span class=w>    </span><span class=err>#</span><span class=k>if</span><span class=w> </span><span class=o>defined</span><span class=p>(</span><span class=n>_PARALLAX_MAP</span><span class=p>)</span><span class=w></span>
<span class=w>        </span><span class=n>i</span><span class=p>.</span><span class=n>tangentViewDir</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>normalize</span><span class=p>(</span><span class=n>i</span><span class=p>.</span><span class=n>tangentViewDir</span><span class=p>);</span><span class=w></span>
<span class=w>        </span><span class=err>#</span><span class=k>if</span><span class=w> </span><span class=o>!defined</span><span class=p>(</span><span class=n>PARALLAX_OFFSET_LIMITING</span><span class=p>)</span><span class=w></span>
<span class=w>            </span><span class=err>#</span><span class=k>if</span><span class=w> </span><span class=o>!defined</span><span class=p>(</span><span class=n>PARALLAX_BIAS</span><span class=p>)</span><span class=w></span>
<span class=w>                </span><span class=err>#</span><span class=n>define</span><span class=w> </span><span class=n>PARALLAX_BIAS</span><span class=w> </span><span class=mf>0.42</span><span class=w></span>
<span class=w>            </span><span class=err>#</span><span class=n>endif</span><span class=w></span>
<span class=w>            </span><span class=n>i</span><span class=p>.</span><span class=n>tangentViewDir</span><span class=p>.</span><span class=n>xy</span><span class=w> </span><span class=o>/=</span><span class=w> </span><span class=p>(</span><span class=n>i</span><span class=p>.</span><span class=n>tangentViewDir</span><span class=p>.</span><span class=n>z</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>PARALLAX_BIAS</span><span class=p>);</span><span class=w></span>
<span class=w>        </span><span class=err>#</span><span class=n>endif</span><span class=w></span>

<span class=w>        </span><span class=kt>float2</span><span class=w> </span><span class=n>uvOffset</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ParallaxOffset</span><span class=p>(</span><span class=n>i</span><span class=p>.</span><span class=n>uv</span><span class=p>.</span><span class=n>xy</span><span class=p>,</span><span class=w> </span><span class=n>i</span><span class=p>.</span><span class=n>tangentViewDir</span><span class=p>.</span><span class=n>xy</span><span class=p>);</span><span class=w></span>
<span class=w>        </span><span class=n>i</span><span class=p>.</span><span class=n>uv</span><span class=p>.</span><span class=n>xy</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>uvOffset</span><span class=p>;</span><span class=w></span>
<span class=w>        </span><span class=n>i</span><span class=p>.</span><span class=n>uv</span><span class=p>.</span><span class=n>zw</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>uvOffset</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=p>(</span><span class=n>_DetailTex_ST</span><span class=p>.</span><span class=n>xy</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=n>_MainTex_ST</span><span class=p>.</span><span class=n>xy</span><span class=p>);</span><span class=w></span>
<span class=w>    </span><span class=err>#</span><span class=n>endif</span><span class=w></span>
<span class=p>}</span><span class=w></span>
</code></pre></div></td></tr></table></div><p>现在，我们将应用视差函数宏替换对视差偏移的硬编码调用，从而使视差方法更加灵活。如果没有定义它，我们将它设置为使用偏移量方法。</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span></pre></div></td><td class=code><div><pre><span></span><code><span class=kt>void</span><span class=w> </span><span class=n>ApplyParallax</span><span class=w> </span><span class=p>(</span><span class=k>inout</span><span class=w> </span><span class=n>Interpolators</span><span class=w> </span><span class=n>i</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w></span>
<span class=w>    </span><span class=err>#</span><span class=k>if</span><span class=w> </span><span class=o>defined</span><span class=p>(</span><span class=n>_PARALLAX_MAP</span><span class=p>)</span><span class=w></span>
<span class=w>        </span><span class=c1>//...</span><span class=w></span>
<span class=w>        </span><span class=err>#</span><span class=k>if</span><span class=w> </span><span class=o>!defined</span><span class=p>(</span><span class=n>PARALLAX_FUNCTION</span><span class=p>)</span><span class=w></span>
<span class=w>            </span><span class=err>#</span><span class=n>define</span><span class=w> </span><span class=n>PARALLAX_FUNCTION</span><span class=w> </span><span class=n>ParallaxOffset</span><span class=w></span>
<span class=w>        </span><span class=err>#</span><span class=n>endif</span><span class=w></span>
<span class=w>        </span><span class=kt>float2</span><span class=w> </span><span class=n>uvOffset</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>PARALLAX_FUNCTION</span><span class=p>(</span><span class=n>i</span><span class=p>.</span><span class=n>uv</span><span class=p>.</span><span class=n>xy</span><span class=p>,</span><span class=w> </span><span class=n>i</span><span class=p>.</span><span class=n>tangentViewDir</span><span class=p>.</span><span class=n>xy</span><span class=p>);</span><span class=w></span>
<span class=w>        </span><span class=n>i</span><span class=p>.</span><span class=n>uv</span><span class=p>.</span><span class=n>xy</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>uvOffset</span><span class=p>;</span><span class=w></span>
<span class=w>        </span><span class=n>i</span><span class=p>.</span><span class=n>uv</span><span class=p>.</span><span class=n>zw</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>uvOffset</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=p>(</span><span class=n>_DetailTex_ST</span><span class=p>.</span><span class=n>xy</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=n>_MainTex_ST</span><span class=p>.</span><span class=n>xy</span><span class=p>);</span><span class=w></span>
<span class=w>    </span><span class=err>#</span><span class=n>endif</span><span class=w></span>
<span class=p>}</span><span class=w></span>
</code></pre></div></td></tr></table></div><p>为RayMarching方法创建一个新函数。与ParallaxOffset函数类似的参数和返回类型。</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span>
<span class=normal>6</span>
<span class=normal>7</span></pre></div></td><td class=code><div><pre><span></span><code><span class=kt>float2</span><span class=w> </span><span class=n>ParallaxOffset</span><span class=w> </span><span class=p>(</span><span class=kt>float2</span><span class=w> </span><span class=n>uv</span><span class=p>,</span><span class=w> </span><span class=kt>float2</span><span class=w> </span><span class=n>viewDir</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w></span>
<span class=p>}</span><span class=w></span>

<span class=kt>float2</span><span class=w> </span><span class=n>ParallaxRaymarching</span><span class=w> </span><span class=p>(</span><span class=kt>float2</span><span class=w> </span><span class=n>uv</span><span class=p>,</span><span class=w> </span><span class=kt>float2</span><span class=w> </span><span class=n>viewDir</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w></span>
<span class=w>    </span><span class=kt>float2</span><span class=w> </span><span class=n>uvOffset</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mo>0</span><span class=p>;</span><span class=w></span>
<span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>uvOffset</span><span class=p>;</span><span class=w></span>
<span class=p>}</span><span class=w></span>
</code></pre></div></td></tr></table></div><p>现在可以通过定义_PARALLAX_FUNCTION_来改变着色器中的视差方法。</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span></pre></div></td><td class=code><div><pre><span></span><code><span class=cp>#define PARALLAX_BIAS 0</span><span class=w></span>
<span class=c1>//#define PARALLAX_OFFSET_LIMITING</span><span class=w></span>
<span class=cp>#define PARALLAX_FUNCTION ParallaxRaymarching</span><span class=w></span>
</code></pre></div></td></tr></table></div><h3 id=相交计算>相交计算<a title="Permanent link"class=headerlink href=#相交计算></a></h3><p>为了找到视图射线到达高度场的点，我们需要对射线上的多个点进行采样并计算出在表面下方的位置。第一个采样点在顶部，我们在这里输入高度量，就像使用偏移方法一样。最后一个采样点就是射线到达体积底部的地方。我们会在这些端点之间均匀地添加额外的采样点。</p><p>假设每条射线进行10次采样。这意味着我们将对高度图采样10次而不是一次，所以这不是一个便宜计算方法。因为我们用了10个样本，所以步长是0.1。这是我们沿着视图射线移动的因子，也就是UV偏移增量。</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span>
<span class=normal>6</span></pre></div></td><td class=code><div><pre><span></span><code><span class=kt>float2</span><span class=w> </span><span class=n>ParallaxRaymarching</span><span class=w> </span><span class=p>(</span><span class=kt>float2</span><span class=w> </span><span class=n>uv</span><span class=p>,</span><span class=w> </span><span class=kt>float2</span><span class=w> </span><span class=n>viewDir</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w></span>
<span class=w>    </span><span class=kt>float2</span><span class=w> </span><span class=n>uvOffset</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mo>0</span><span class=p>;</span><span class=w></span>
<span class=w>    </span><span class=kt>float</span><span class=w> </span><span class=n>stepSize</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mf>0.1</span><span class=p>;</span><span class=w></span>
<span class=w>    </span><span class=kt>float2</span><span class=w> </span><span class=n>uvDelta</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>viewDir</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>stepSize</span><span class=p>;</span><span class=w></span>
<span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>uvOffset</span><span class=p>;</span><span class=w></span>
<span class=p>}</span><span class=w></span>
</code></pre></div></td></tr></table></div><p>为了应用视差强度，我们可以调整每一步采样的高度。但是缩放UV delta也有同样的效果，只需要计算一次。</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span></pre></div></td><td class=code><div><pre><span></span><code><span class=kt>float2</span><span class=w> </span><span class=n>uvDelta</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>viewDir</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=p>(</span><span class=n>stepSize</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>_ParallaxStrength</span><span class=p>);</span><span class=w></span>
</code></pre></div></td></tr></table></div><p>通过这种方式，无论视差强度如何，我们都可以继续使用0–1作为高度场的范围。 因此，射线的第一步高度始终为1。低于或高于该高度的表面点的高度由高度场定义。</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span></pre></div></td><td class=code><div><pre><span></span><code><span class=kt>float</span><span class=w> </span><span class=n>stepSize</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mf>0.1</span><span class=p>;</span><span class=c1>//步长</span><span class=w></span>
<span class=kt>float2</span><span class=w> </span><span class=n>uvDelta</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>viewDir</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=p>(</span><span class=n>stepSize</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>_ParallaxStrength</span><span class=p>);</span><span class=w></span>
<span class=kt>float</span><span class=w> </span><span class=n>stepHeight</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=c1>//步高</span><span class=w></span>
<span class=kt>float</span><span class=w> </span><span class=n>surfaceHeight</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>GetParallaxHeight</span><span class=p>(</span><span class=n>uv</span><span class=p>);</span><span class=w></span>
</code></pre></div></td></tr></table></div><p>现在我们要沿着射线迭代。<strong>首先</strong>，每一步我们都会增加UV偏移量。视图向量指向摄像机，但我们是在向表面移动，所以我们需要减去UV delta。<strong>然后</strong>我们用步高来减小步长。<strong>然后</strong>我们再次对高度图采样。使用while循环重复上述步骤，直到采样完毕。</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span>
<span class=normal>6</span>
<span class=normal>7</span>
<span class=normal>8</span>
<span class=normal>9</span></pre></div></td><td class=code><div><pre><span></span><code><span class=kt>float</span><span class=w> </span><span class=n>stepHeight</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w></span>
<span class=kt>float</span><span class=w> </span><span class=n>surfaceHeight</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>GetParallaxHeight</span><span class=p>(</span><span class=n>uv</span><span class=p>);</span><span class=w></span>

<span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>stepHeight</span><span class=w> </span><span class=o>></span><span class=w> </span><span class=n>surfaceHeight</span><span class=p>)</span><span class=w></span>
<span class=p>{</span><span class=w></span>
<span class=w>    </span><span class=n>uvOffset</span><span class=w> </span><span class=o>-=</span><span class=w> </span><span class=n>uvDelta</span><span class=p>;</span><span class=w></span>
<span class=w>    </span><span class=n>stepHeight</span><span class=w> </span><span class=o>-=</span><span class=w> </span><span class=n>stepSize</span><span class=p>;</span><span class=w></span>
<span class=w>    </span><span class=n>surfaceHeight</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>GetParallaxHeight</span><span class=p>(</span><span class=n>uv</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>uvOffset</span><span class=p>);</span><span class=w></span>
<span class=p>}</span><span class=w></span>
</code></pre></div></td></tr></table></div><p>当编译时，会得到一个编译器警告和错误。这个警告告诉我们在循环中使用了梯度指令。这指的是循环中的纹理采样。GPU必须弄清楚使用哪个mipmap级别，它需要比较相邻片段使用的UV坐标。只有当所有片段执行相同的代码时，它才能对比。对于循环来说，这是不可能的，因为它可以提前终止，每个片段都可能不同。因此编译器将展开循环，这意味着它将一直执行所有9个步骤，而不管逻辑是否可以提前停止。相反，它随后使用确定性逻辑选择最终结果。</p><p>编译失败是因为编译器无法确定循环的最大迭代次数。它不知道这个最多是9。通过将while循环转换为执行限制的for循环来明确这一点。</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span>
<span class=normal>6</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o><</span><span class=w> </span><span class=mi>10</span><span class=w> </span><span class=o>&&</span><span class=w> </span><span class=n>stepHeight</span><span class=w> </span><span class=o>></span><span class=w> </span><span class=n>surfaceHeight</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w></span>
<span class=p>{</span><span class=w></span>
<span class=w>    </span><span class=n>uvOffset</span><span class=w> </span><span class=o>-=</span><span class=w> </span><span class=n>uvDelta</span><span class=p>;</span><span class=w></span>
<span class=w>    </span><span class=n>stepHeight</span><span class=w> </span><span class=o>-=</span><span class=w> </span><span class=n>stepSize</span><span class=p>;</span><span class=w></span>
<span class=w>    </span><span class=n>surfaceHeight</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>GetParallaxHeight</span><span class=p>(</span><span class=n>uv</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>uvOffset</span><span class=p>);</span><span class=w></span>
<span class=p>}</span><span class=w></span>
</code></pre></div></td></tr></table></div><p>{% include img-picture.html url1="posts/2018/month1/catRender20/1692664-20200618012945572-448280189.png" des="Raymarching 步进10次 无偏差, 无限制" width="250" %}</p><p>与简单的视差偏移方法相比，视差效果更加明显。较高的区域现在也正确地阻挡了我们后面较低区域的视野。我们还得到了明显的图层，总共10层。</p><h3 id=更多步进>更多步进<a title="Permanent link"class=headerlink href=#更多步进></a></h3><p>这个基本的光线行进方法最适合陡峭的视差贴图。效果的质量是由我们的样本分辨率决定的。一些方法根据视角使用可变的步骤。较浅的角度需要更多的步长，因为光线较长。但我们的样本量是固定的，所以我们不会这样做。</p><p>提高质量的明显方法是增加采样的次数，因此让其可配置。使用_PARALLAX_RAYMARCHING_STEPS_，默认值为10，而不是固定的步长和迭代次数。</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span>
<span class=normal>22</span>
<span class=normal>23</span></pre></div></td><td class=code><div><pre><span></span><code><span class=kt>float2</span><span class=w> </span><span class=n>ParallaxRaymarching</span><span class=w> </span><span class=p>(</span><span class=kt>float2</span><span class=w> </span><span class=n>uv</span><span class=p>,</span><span class=w> </span><span class=kt>float2</span><span class=w> </span><span class=n>viewDir</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w></span>
<span class=w>    </span><span class=err>#</span><span class=k>if</span><span class=w> </span><span class=o>!defined</span><span class=p>(</span><span class=n>PARALLAX_RAYMARCHING_STEPS</span><span class=p>)</span><span class=w></span>
<span class=w>        </span><span class=err>#</span><span class=n>define</span><span class=w> </span><span class=n>PARALLAX_RAYMARCHING_STEPS</span><span class=w> </span><span class=mi>10</span><span class=w></span>
<span class=w>    </span><span class=err>#</span><span class=n>endif</span><span class=w></span>
<span class=w>    </span><span class=kt>float2</span><span class=w> </span><span class=n>uvOffset</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mo>0</span><span class=p>;</span><span class=w></span>
<span class=w>    </span><span class=kt>float</span><span class=w> </span><span class=n>stepSize</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mf>1.0</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=n>PARALLAX_RAYMARCHING_STEPS</span><span class=p>;</span><span class=w></span>
<span class=w>    </span><span class=kt>float2</span><span class=w> </span><span class=n>uvDelta</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>viewDir</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=p>(</span><span class=n>stepSize</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>_ParallaxStrength</span><span class=p>);</span><span class=w></span>

<span class=w>    </span><span class=kt>float</span><span class=w> </span><span class=n>stepHeight</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w></span>
<span class=w>    </span><span class=kt>float</span><span class=w> </span><span class=n>surfaceHeight</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>GetParallaxHeight</span><span class=p>(</span><span class=n>uv</span><span class=p>);</span><span class=w></span>

<span class=w>    </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=w></span>
<span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w></span>
<span class=w>        </span><span class=n>i</span><span class=w> </span><span class=o><</span><span class=w> </span><span class=n>PARALLAX_RAYMARCHING_STEPS</span><span class=w> </span><span class=o>&&</span><span class=w> </span><span class=n>stepHeight</span><span class=w> </span><span class=o>></span><span class=w> </span><span class=n>surfaceHeight</span><span class=p>;</span><span class=w></span>
<span class=w>        </span><span class=n>i</span><span class=o>++</span><span class=w></span>
<span class=w>    </span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w></span>
<span class=w>        </span><span class=n>uvOffset</span><span class=w> </span><span class=o>-=</span><span class=w> </span><span class=n>uvDelta</span><span class=p>;</span><span class=w></span>
<span class=w>        </span><span class=n>stepHeight</span><span class=w> </span><span class=o>-=</span><span class=w> </span><span class=n>stepSize</span><span class=p>;</span><span class=w></span>
<span class=w>        </span><span class=n>surfaceHeight</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>GetParallaxHeight</span><span class=p>(</span><span class=n>uv</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>uvOffset</span><span class=p>);</span><span class=w></span>
<span class=w>    </span><span class=p>}</span><span class=w></span>

<span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>uvOffset</span><span class=p>;</span><span class=w></span>
<span class=p>}</span><span class=w></span>
</code></pre></div></td></tr></table></div><p>现在我们可以在着色器中控制步数。对于真正的高质量，将PARALLAX_RAYMARCHING_STEPS定义为100。</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span></pre></div></td><td class=code><div><pre><span></span><code><span class=cp>#define PARALLAX_BIAS 0</span><span class=w></span>
<span class=c1>//#define PARALLAX_OFFSET_LIMITING</span><span class=w></span>
<span class=cp>#define PARALLAX_RAYMARCHING_STEPS 100</span><span class=w></span>
<span class=cp>#define PARALLAX_FUNCTION ParallaxRaymarching</span><span class=w></span>
</code></pre></div></td></tr></table></div><p>{% include img-picture.html url1="posts/2018/month1/catRender20/1692664-20200618012948054-536464296.png" des="Raymarching 100次采样" width="250" %}</p><p>这让我们知道了它的效果能有多好，但它计算量太大了，一般不适合手机。所以把样本数设为10后，我们仍然可以看到视差效果看起来连续和平滑。然而，由视差遮挡引起的轮廓总是锯齿状的，MSAA并不能消除这一点，因为它只适用于几何图形的边缘，而不是纹理效果。只要不依赖深度缓冲区，后处理抗锯齿技术能解决。</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span></pre></div></td><td class=code><div><pre><span></span><code>不能按片段写入深度缓冲区吗?
这在足够先进的硬件上确实是可能的，使它能够正确地与高度场相交并应用阴影。不过，它计算量太大。
</code></pre></div></td></tr></table></div><p>我们当前的方法是沿着射线步进，直到到达表面以下的点，或者到达射线末端可能的最低点。然后我们用UV偏移处理那个点。但隐藏在表面之下的这个点，很可能会出现错误。这就是导致表面撕裂的原因。</p><p>增加步长数只会减少最大误差。使用足够的步骤，错误会变得更小，以至于我们无法再看到它。所以当一个表面总是从远处看，你可以用更少的步骤。距离越近，视角越小，需要的样本就越多。</p><p>{% include img-picture.html url1="posts/2018/month1/catRender20/1692664-20200618012948690-1598196626.png" des="Raymarching 100次采样" width="250" %}</p><h3 id=步长之间插值>步长之间插值<a title="Permanent link"class=headerlink href=#步长之间插值></a></h3><p>提高质量的一种方法是根据经验预测光线真正到达表面的位置。比如第一步在表面之上，下一步在表面之下。在这两步之间的某个点射线一定到达了表面。</p><p>两个射线点、和两个射线点到表面最近的点，能定义两条线段。因为光线和表面碰撞，这两条线段会相交。所以如果我们跟踪前面的步骤，我们可以在循环之后执行直线交叉。我们可以用这个信息来近似出真正的交点。</p><p>{% include img-picture.html url1="posts/2018/month1/catRender20/1692664-20200618012949277-977122761.png" des="执行直线交叉" width="250" %}</p><p>在for循环内，我们必须跟踪之前的UV偏移量、步长高度和表面高度。一般来说，这些等于循环之前的第一个样本。</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span></pre></div></td><td class=code><div><pre><span></span><code><span class=kt>float2</span><span class=w> </span><span class=n>prevUVOffset</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>uvOffset</span><span class=p>;</span><span class=w></span>
<span class=kt>float</span><span class=w> </span><span class=n>prevStepHeight</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>stepHeight</span><span class=p>;</span><span class=w></span>
<span class=kt>float</span><span class=w> </span><span class=n>prevSurfaceHeight</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>surfaceHeight</span><span class=p>;</span><span class=w></span>
</code></pre></div></td></tr></table></div><p>在循环之后，我们计算这些线的交点。我们可以使用这个插值之间的前点和后点的UV偏移。</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span>
<span class=normal>6</span></pre></div></td><td class=code><div><pre><span></span><code><span class=kt>float</span><span class=w> </span><span class=n>prevDifference</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>prevStepHeight</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>prevSurfaceHeight</span><span class=p>;</span><span class=w></span>
<span class=kt>float</span><span class=w> </span><span class=n>difference</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>surfaceHeight</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>stepHeight</span><span class=p>;</span><span class=w></span>
<span class=kt>float</span><span class=w> </span><span class=n>t</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>prevDifference</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=p>(</span><span class=n>prevDifference</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>difference</span><span class=p>);</span><span class=w></span>
<span class=n>uvOffset</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>lerp</span><span class=p>(</span><span class=n>prevUVOffset</span><span class=p>,</span><span class=w> </span><span class=n>uvOffset</span><span class=p>,</span><span class=w> </span><span class=n>t</span><span class=p>);</span><span class=w></span>

<span class=k>return</span><span class=w> </span><span class=n>uvOffset</span><span class=p>;</span><span class=w></span>
</code></pre></div></td></tr></table></div><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span>
<span class=normal>6</span>
<span class=normal>7</span>
<span class=normal>8</span>
<span class=normal>9</span></pre></div></td><td class=code><div><pre><span></span><code>数学原理：
这两个线段定义在两个样本步骤之间的空间内。我们将这个空间的宽度设置为1。从前一步到最后一步的直线由点(0，a)和点(1，b)定义，其中a是前一步的高度，b是后一步的高度。因此，可以用线性函数'v(t) = a + (b - a)t'来定义视图线。同样地，面线由点(0，c)和(1，d)定义，函数's(t) = hlsl + (d - hlsl)t'。

交点存在于s(t) = v(t)'处。那么t的值是多少?
c + (d - c)t = a + (b - a)t
(d - c)t - (b - a)t = a - c
(a - c + d - b)t = a - c
t = (a - c) / (a - c + d - b)
注意:a - c是在t = 0处直线高度的绝对差。d - b是t = 1处的绝对高度差。
</code></pre></div></td></tr></table></div><p>{% include img-picture.html url1="posts/2018/month1/catRender20/1692664-20200618012950193-51635460.png" des="线段交点" width="250" %}</p><p>实际上，在这种情况下，我们可以使用插值器来缩放我们要添加到上一点上的UV偏移量。它可以归结为相同的东西，只是用了更少的数学。</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span></pre></div></td><td class=code><div><pre><span></span><code><span class=kt>float</span><span class=w> </span><span class=n>t</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>prevDifference</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=p>(</span><span class=n>prevDifference</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>difference</span><span class=p>);</span><span class=w></span>
<span class=n>uvOffset</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>prevUVOffset</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>uvDelta</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>t</span><span class=p>;</span><span class=w></span>
</code></pre></div></td></tr></table></div><p>{% include img-picture.html url1="posts/2018/month1/catRender20/1692664-20200618012951620-360864955.png" width="250" %}</p><p>效果看起来好多了。我们现在假设表面在样本点之间是线性的，这可以防止最明显的分层假象。然而，它不能帮助我们检测我们是否错过了步骤之间的交集。我们仍然需要很多的样本来处理小的特征，轮廓和浅角度。</p><p>有了这个技巧，我们的方法类似于视差遮挡映射。虽然这是一个相对便宜的改进，但通过定义_PARALLAX_RAYMARCHING_INTERPOLATE_，我们让它成为可选的。</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span>
<span class=normal>6</span></pre></div></td><td class=code><div><pre><span></span><code><span class=cp>#if defined(PARALLAX_RAYMARCHING_INTERPOLATE)</span><span class=w></span>
<span class=w>    </span><span class=kt>float</span><span class=w> </span><span class=n>prevDifference</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>prevStepHeight</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>prevSurfaceHeight</span><span class=p>;</span><span class=w></span>
<span class=w>    </span><span class=kt>float</span><span class=w> </span><span class=n>difference</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>surfaceHeight</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>stepHeight</span><span class=p>;</span><span class=w></span>
<span class=w>    </span><span class=kt>float</span><span class=w> </span><span class=n>t</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>prevDifference</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=p>(</span><span class=n>prevDifference</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>difference</span><span class=p>);</span><span class=w></span>
<span class=w>    </span><span class=n>uvOffset</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>prevUVOffset</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>uvDelta</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>t</span><span class=p>;</span><span class=w></span>
<span class=cp>#endif</span><span class=w></span>
</code></pre></div></td></tr></table></div><p>在shader内定义PARALLAX_RAYMARCHING_INTERPOLATE。</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span></pre></div></td><td class=code><div><pre><span></span><code><span class=cp>#define PARALLAX_BIAS 0</span><span class=w></span>
<span class=c1>//#define PARALLAX_OFFSET_LIMITING</span><span class=w></span>
<span class=cp>#define PARALLAX_RAYMARCHING_STEPS 10</span><span class=w></span>
<span class=cp>#define PARALLAX_RAYMARCHING_INTERPOLATE</span><span class=w></span>
<span class=cp>#define PARALLAX_FUNCTION ParallaxRaymarching</span><span class=w></span>
</code></pre></div></td></tr></table></div><h3 id=步长搜索>步长搜索<a title="Permanent link"class=headerlink href=#步长搜索></a></h3><p>通过在两个步长之间进行线性插值，我们假定表面在两个步长之间是笔直的。 但是，通常情况并非如此。 为了更好地处理不规则的高度场，我们必须在两个步长之间搜索实际的交点。 或至少接近它。</p><p>完成循环后，不要使用最后的偏移量，而是将偏移量调整到最后两个步长的中间位置。对该点的高度进行采样。如果我们结束在表面以下，向表面之上方向移动四分之一，并再次采样。如果我们在表面上结束，向表面之下方向移动四分之，并再次采样。不断重复这个过程。</p><p>{% include img-picture.html url1="posts/2018/month1/catRender20/1692664-20200618012952340-10743193.png" des="越来越接近交点" width="250" %}</p><p>上述方法是二分查找的一个应用。它与地形测绘方法最匹配。每走一步，路程减半，直到到达目的地。在我们的例子中，我们将简单地做固定次数，以达到预期的解决方案。一步，得到0.5。两步，得到0.25、0.75。三步，是0.125、0.375、0.625、0.875。注意，从第二步开始，每次采样提升分的辨率将翻倍。</p><p>为了控制是否使用此方法，我们定义_PARALLAX_RAYMARCHING_SEARCH_STEPS_。默认情况下将其设置为零，这意味着我们根本不进行搜索。如果它被定义为大于0，我们将不得不使用另一个循环。注意，这种方法与_PARALLAX_RAYMARCHING_INTERPOLATE_是<strong>不兼容</strong>的，因为我们不能再保证表面是交叉的最后两个步骤。当我们搜索的时候，禁用插值。</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span></pre></div></td><td class=code><div><pre><span></span><code><span class=cp>#if !defined(PARALLAX_RAYMARCHING_SEARCH_STEPS)</span><span class=w></span>
<span class=w>    </span><span class=err>#</span><span class=n>define</span><span class=w> </span><span class=n>PARALLAX_RAYMARCHING_SEARCH_STEPS</span><span class=w> </span><span class=mo>0</span><span class=w></span>
<span class=cp>#endif</span><span class=w></span>
<span class=cp>#if PARALLAX_RAYMARCHING_SEARCH_STEPS > 0</span><span class=w></span>
<span class=w>    </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mo>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o><</span><span class=w> </span><span class=n>PARALLAX_RAYMARCHING_SEARCH_STEPS</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w></span>
<span class=w>    </span><span class=p>}</span><span class=w></span>
<span class=cp>#elif defined(PARALLAX_RAYMARCHING_INTERPOLATE)</span><span class=w></span>
<span class=w>    </span><span class=kt>float</span><span class=w> </span><span class=n>prevDifference</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>prevStepHeight</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>prevSurfaceHeight</span><span class=p>;</span><span class=w></span>
<span class=w>    </span><span class=kt>float</span><span class=w> </span><span class=n>difference</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>surfaceHeight</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>stepHeight</span><span class=p>;</span><span class=w></span>
<span class=w>    </span><span class=kt>float</span><span class=w> </span><span class=n>t</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>prevDifference</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=p>(</span><span class=n>prevDifference</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>difference</span><span class=p>);</span><span class=w></span>
<span class=w>    </span><span class=n>uvOffset</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>prevUVOffset</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>uvDelta</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>t</span><span class=p>;</span><span class=w></span>
<span class=cp>#endif</span><span class=w></span>
</code></pre></div></td></tr></table></div><p>此循环也执行与原始循环相同的基本工作。调整偏移量和步高，然后采样高度字段。</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mo>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o><</span><span class=w> </span><span class=n>PARALLAX_RAYMARCHING_SEARCH_STEPS</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w></span>
<span class=w>    </span><span class=n>uvOffset</span><span class=w> </span><span class=o>-=</span><span class=w> </span><span class=n>uvDelta</span><span class=p>;</span><span class=w></span>
<span class=w>    </span><span class=n>stepHeight</span><span class=w> </span><span class=o>-=</span><span class=w> </span><span class=n>stepSize</span><span class=p>;</span><span class=w></span>
<span class=w>    </span><span class=n>surfaceHeight</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>GetParallaxHeight</span><span class=p>(</span><span class=n>uv</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>uvOffset</span><span class=p>);</span><span class=w></span>
<span class=p>}</span><span class=w></span>
</code></pre></div></td></tr></table></div><p>但每次迭代，UV增量和步长减半。</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span>
<span class=normal>6</span>
<span class=normal>7</span>
<span class=normal>8</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mo>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o><</span><span class=w> </span><span class=n>PARALLAX_RAYMARCHING_SEARCH_STEPS</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w></span>
<span class=p>{</span><span class=w></span>
<span class=w>    </span><span class=n>uvDelta</span><span class=w> </span><span class=o>*=</span><span class=w> </span><span class=mf>0.5</span><span class=p>;</span><span class=w></span>
<span class=w>    </span><span class=n>stepSize</span><span class=w> </span><span class=o>*=</span><span class=w> </span><span class=mf>0.5</span><span class=p>;</span><span class=w></span>
<span class=w>    </span><span class=n>uvOffset</span><span class=w> </span><span class=o>-=</span><span class=w> </span><span class=n>uvDelta</span><span class=p>;</span><span class=w></span>
<span class=w>    </span><span class=n>stepHeight</span><span class=w> </span><span class=o>-=</span><span class=w> </span><span class=n>stepSize</span><span class=p>;</span><span class=w></span>
<span class=w>    </span><span class=n>surfaceHeight</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>GetParallaxHeight</span><span class=p>(</span><span class=n>uv</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>uvOffset</span><span class=p>);</span><span class=w></span>
<span class=p>}</span><span class=w></span>
</code></pre></div></td></tr></table></div><p>同样，如果点在表面之下，我们必须朝相反的方向移动。</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span></pre></div></td><td class=code><div><pre><span></span><code><span class=n>uvDelta</span><span class=w> </span><span class=o>*=</span><span class=w> </span><span class=mf>0.5</span><span class=p>;</span><span class=w></span>
<span class=n>stepSize</span><span class=w> </span><span class=o>*=</span><span class=w> </span><span class=mf>0.5</span><span class=p>;</span><span class=w></span>
<span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>stepHeight</span><span class=w> </span><span class=o><</span><span class=w> </span><span class=n>surfaceHeight</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w></span>
<span class=w>    </span><span class=n>uvOffset</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>uvDelta</span><span class=p>;</span><span class=w></span>
<span class=w>    </span><span class=n>stepHeight</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>stepSize</span><span class=p>;</span><span class=w></span>
<span class=p>}</span><span class=w></span>
<span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w></span>
<span class=w>    </span><span class=n>uvOffset</span><span class=w> </span><span class=o>-=</span><span class=w> </span><span class=n>uvDelta</span><span class=p>;</span><span class=w></span>
<span class=w>    </span><span class=n>stepHeight</span><span class=w> </span><span class=o>-=</span><span class=w> </span><span class=n>stepSize</span><span class=p>;</span><span class=w></span>
<span class=p>}</span><span class=w></span>
<span class=n>surfaceHeight</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>GetParallaxHeight</span><span class=p>(</span><span class=n>uv</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>uvOffset</span><span class=p>);</span><span class=w></span>
</code></pre></div></td></tr></table></div><p>调整着色器，所以它使用三个搜索步骤</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span>
<span class=normal>6</span></pre></div></td><td class=code><div><pre><span></span><code><span class=cp>#define PARALLAX_BIAS 0</span><span class=w></span>
<span class=c1>//#define PARALLAX_OFFSET_LIMITING</span><span class=w></span>
<span class=cp>#define PARALLAX_RAYMARCHING_STEPS 10</span><span class=w></span>
<span class=cp>#define PARALLAX_RAYMARCHING_INTERPOLATE</span><span class=w></span>
<span class=cp>#define PARALLAX_RAYMARCHING_SEARCH_STEPS 3</span><span class=w></span>
<span class=cp>#define PARALLAX_FUNCTION ParallaxRaymarching</span><span class=w></span>
</code></pre></div></td></tr></table></div><p>{% include img-picture.html url1="posts/2018/month1/catRender20/1692664-20200618012953271-1061541462.png" des="10步长加上3个二分查找的最终效果" width="250" %}</p><p>结果看起来相当不错，但仍不完美。二分法搜索可以比简单的插值处理较浅的角度，但仍然需要相当多的搜索步骤，以摆脱分层。所以这是一个试验的问题，找出哪种方法在特定情况下最有效，需要多少步骤。</p><h3 id=缩放对象和动态批处理>缩放对象和动态批处理<a title="Permanent link"class=headerlink href=#缩放对象和动态批处理></a></h3><p>尽管我们的视差映射方法似乎可行，但存在一个隐藏的错误。 而且还把错误显示出来了。它显示了何时使用动态批处理来组合已缩放的对象。 例如，给我们的四边形一个像<span class=arithmatex>\(<span class=arithmatex>\((10,10,10)\)</span>\)</span>的比例，然后复制它，将副本移到它下面一点。 假设在播放器设置中启用了此选项，这将触发Unity动态批处理四边形。</p><p>批处理开始时，视差效果将扭曲。 旋转相机时，这一点非常明显。 但是，这仅发生在游戏视图和构建中，而不发生在场景视图中。 请注意，standard着色器也存在此问题，但是当使用弱偏移视差效果时，您可能不会立即注意到它。</p><p>{% include img-picture.html url1="posts/2018/month1/catRender20/1692664-20200618012954391-1540920343.png" des="动态批处理会产生奇怪的结果" width="250" %}</p><p>在批处理将它们合并到一个单一的网格中之后，Unity不能标准化处理后的几何法向量和切向量。因此顶点数据正确的假设不再成立。</p><p>顶点法向量和切向量没有规范化不是什么大的问题，因为我们在顶点程序中将视图向量转换到切线空间。对于其他所有内容，数据在使用之前都要标准化。</p><p>解决方法是在构造对象转换到切线矩阵之前对向量进行归一化。 因为只有动态批处理的缩放几何才需要此选项，所以根据是否定义了PARALLAX_SUPPORT_SCALED_DYNAMIC_BATCHING，将其设为可选。</p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span></pre></div></td><td class=code><div><pre><span></span><code><span class=cp>#if defined (_PARALLAX_MAP)</span><span class=w></span>
<span class=w>    </span><span class=err>#</span><span class=k>if</span><span class=w> </span><span class=o>defined</span><span class=p>(</span><span class=n>PARALLAX_SUPPORT_SCALED_DYNAMIC_BATCHING</span><span class=p>)</span><span class=w></span>
<span class=w>        </span><span class=n>v</span><span class=p>.</span><span class=n>tangent</span><span class=p>.</span><span class=n>xyz</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>normalize</span><span class=p>(</span><span class=n>v</span><span class=p>.</span><span class=n>tangent</span><span class=p>.</span><span class=n>xyz</span><span class=p>);</span><span class=w></span>
<span class=w>        </span><span class=n>v</span><span class=p>.</span><span class=n>normal</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>normalize</span><span class=p>(</span><span class=n>v</span><span class=p>.</span><span class=n>normal</span><span class=p>);</span><span class=w></span>
<span class=w>    </span><span class=err>#</span><span class=n>endif</span><span class=w></span>
<span class=w>    </span><span class=kt>float3x3</span><span class=w> </span><span class=n>objectToTangent</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kt>float3x3</span><span class=p>(</span><span class=w></span>
<span class=w>        </span><span class=n>v</span><span class=p>.</span><span class=n>tangent</span><span class=p>.</span><span class=n>xyz</span><span class=p>,</span><span class=w></span>
<span class=w>        </span><span class=nb>cross</span><span class=p>(</span><span class=n>v</span><span class=p>.</span><span class=n>normal</span><span class=p>,</span><span class=w> </span><span class=n>v</span><span class=p>.</span><span class=n>tangent</span><span class=p>.</span><span class=n>xyz</span><span class=p>)</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>v</span><span class=p>.</span><span class=n>tangent</span><span class=p>.</span><span class=n>w</span><span class=p>,</span><span class=w></span>
<span class=w>        </span><span class=n>v</span><span class=p>.</span><span class=n>normal</span><span class=w></span>
<span class=w>    </span><span class=p>);</span><span class=w></span>
<span class=w>    </span><span class=n>i</span><span class=p>.</span><span class=n>tangentViewDir</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>mul</span><span class=p>(</span><span class=n>objectToTangent</span><span class=p>,</span><span class=w> </span><span class=n>ObjSpaceViewDir</span><span class=p>(</span><span class=n>v</span><span class=p>.</span><span class=n>vertex</span><span class=p>));</span><span class=w></span>
<span class=cp>#endif</span><span class=w></span>
</code></pre></div></td></tr></table></div><p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span>
<span class=normal>6</span>
<span class=normal>7</span></pre></div></td><td class=code><div><pre><span></span><code><span class=cp>#define PARALLAX_BIAS 0</span><span class=w></span>
<span class=c1>//#define PARALLAX_OFFSET_LIMITING</span><span class=w></span>
<span class=cp>#define PARALLAX_RAYMARCHING_STEPS 10</span><span class=w></span>
<span class=cp>#define PARALLAX_RAYMARCHING_INTERPOLATE</span><span class=w></span>
<span class=cp>#define PARALLAX_RAYMARCHING_SEARCH_STEPS 3</span><span class=w></span>
<span class=cp>#define PARALLAX_FUNCTION ParallaxRaymarching</span><span class=w></span>
<span class=cp>#define PARALLAX_SUPPORT_SCALED_DYNAMIC_BATCHING</span><span class=w></span>
</code></pre></div></td></tr></table></div> {% include img-picture.html url1="posts/2018/month1/catRender20/batched-correct.png" des="动态批量与正确的结果" width="250" %} <hr><blockquote class=page-copyright><span><i class=md-icon><svg viewbox="0 0 24 24"xmlns=http://www.w3.org/2000/svg><path d="m22.7 19-9.1-9.1c.9-2.3.4-5-1.5-6.9-2-2-5-2.4-7.4-1.3L9 6 6 9 1.6 4.7C.4 7.1.9 10.1 2.9 12.1c1.9 1.9 4.6 2.4 6.9 1.5l9.1 9.1c.4.4 1 .4 1.4 0l2.3-2.3c.5-.4.5-1.1.1-1.4Z"/></svg></i>本页面最近更新：</span><span class=facts_modified></span>，<a class=edit_history>更新历史</a><br><span><i class=md-icon><svg viewbox="0 0 24 24"xmlns=http://www.w3.org/2000/svg><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25Z"/></svg></i>发现错误？ <a class=page_edit_url href=https://github.com/damonc-top/damonc-top.github.io/discussions/posts/unity3d/shader/translater/catlikecoding/2018-01-25-Unity_Parallax_Normals_Heightmap.md title=编辑此页>在 GitHub 评论指正！</a></span><br><span><i class=md-icon><svg viewbox="0 0 24 24"xmlns=http://www.w3.org/2000/svg><path d="M16 17v2H2v-2s0-4 7-4 7 4 7 4m-3.5-9.5A3.5 3.5 0 1 0 9 11a3.5 3.5 0 0 0 3.5-3.5m3.44 5.5A5.32 5.32 0 0 1 18 17v2h4v-2s0-3.63-6.06-4M15 4a3.39 3.39 0 0 0-1.93.59 5 5 0 0 1 0 5.82A3.39 3.39 0 0 0 15 11a3.5 3.5 0 0 0 0-7Z"/></svg></i>本文作者：</span><span class=page_contributors>catlikecoding</span><br><span><i class=md-icon><svg viewbox="0 0 24 24"xmlns=http://www.w3.org/2000/svg><path d="M10.08 10.86c.05-.33.16-.62.3-.86.3-.56.81-.85 1.5-.86.45 0 .86.2 1.15.49.28.31.47.74.47 1.17h1.8c-.02-.47-.11-.9-.3-1.3-.15-.38-.38-.72-.68-1-1.45-1.34-4.14-1.15-5.37.37-1.29 1.67-1.32 4.59-.01 6.26 1.21 1.49 3.86 1.7 5.3.37.31-.25.56-.56.76-.92.16-.36.27-.74.28-1.15H13.5c0 .21-.07.4-.16.57-.09.19-.21.34-.34.47-.33.26-.72.4-1.14.4-.36-.01-.66-.08-.89-.23a1.41 1.41 0 0 1-.59-.64c-.5-.9-.42-2.15-.3-3.14M12 2C6.5 2 2 6.5 2 12c.53 13.27 19.5 13.26 20 0 0-5.5-4.5-10-10-10m0 18c-4.41 0-8-3.59-8-8 .44-10.61 15.56-10.61 16 0 0 4.41-3.59 8-8 8Z"/></svg></i>本页面的全部内容在 <strong><a href=https://creativecommons.org/licenses/by-sa/4.0/deed.zh>CC BY-SA 4.0</a> 和 <a href=https://github.com/zTrix/sata-license>SATA</a></strong> 协议之条款下提供，附加条款亦可能应用</span></blockquote><div class=giscus data-no-instant id=__comments></div><div id=__comments_script></div><script>var comments=document.createElement("script"),commentsTheme="slate"===document.body.dataset.mdColorScheme?"dark":"light";Object.entries({async:!0,src:"https://giscus.app/client.js",crossOrigin:"anonymous","data-repo":"damonc-top/damonc-top.github.io","data-repo-id":"R_kgDOHK_iGQ","data-category":"评论","data-category-id":"DIC_kwDOHK_iGc4COonC","data-mapping":"specific","data-term":"视差和法线、高度图回顾(翻译二十)","data-strict":"1","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"top","data-theme":commentsTheme,"data-lang":"zh-CN","data-loading":"lazy"}).forEach(t=>comments.setAttribute(t[0],t[1])),document.getElementById("__comments_script").replaceWith(comments)</script></article></div></div></main><script>function scrollFunction(){20<document.body.scrollTop||20<document.documentElement.scrollTop?document.getElementById("myBtn").style.display="block":document.getElementById("myBtn").style.display="none"}function topFunction(){document.body.scrollTop=0,document.documentElement.scrollTop=0}window.onscroll=function(){scrollFunction()}</script><button class=data-tip-left data-tip=回到顶部 id=myBtn onclick=topFunction()><svg class="Zi Zi--BackToTop data-tip-left"viewbox="0 0 24 24"data-tip=回到顶部 fill=currentColor height=24 width=24><path d="M16.036 19.59a1 1 0 0 1-.997.995H9.032a.996.996 0 0 1-.997-.996v-7.005H5.03c-1.1 0-1.36-.633-.578-1.416L11.33 4.29a1.003 1.003 0 0 1 1.412 0l6.878 6.88c.782.78.523 1.415-.58 1.415h-3.004v7.005z"></path></svg></button><footer class=md-footer><div class="md-footer-meta md-typeset"><div class="md-footer-meta__inner md-grid"><div class=md-copyright><div class=md-copyright__highlight>Copyright © 2016 - 2024 银河揽月</div> Made with <a href=https://squidfunk.github.io/mkdocs-material/ rel=noopener target=_blank> Material for MkDocs <div id=miitbeian></div> </a></div><div class=build_date_utc style=float:right><a href=https://github.com/damonc-top/damonc-top.github.io> 最近更新：6c2a14f, 2024-09-24 </a></div></div></div></footer></div><div class=md-dialog data-md-component=dialog><div class="md-dialog__inner md-typeset"></div></div><script id=__config type=application/json>{"base": "../../../../../..", "features": ["navigation.tabs", "navigation.instant"], "search": "../../../../../../assets/javascripts/workers/search.8e7a41fd.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.config.lang": "ja", "search.config.pipeline": "trimmer, stemmer", "search.config.separator": "[\\s\\-\uff0c\u3002]+", "search.placeholder": "\u641c\u7d22", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version.title": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script><script src=../../../../../../assets/javascripts/bundle.c15c428f.min.js></script><script src=../../../../../../extension/js/math-csr.js?math-csr></script><script src=../../../../../../assets/vendor/mathjax/es5/tex-mml-chtml.js?math-csr></script><script>"use strict";"serviceWorker"in navigator&&navigator.serviceWorker.register("/service-worker.js",{scope:"/"}).then(function(e){console.log("PWA Registration succeeded. Scope is "+e.scope)}).catch(function(e){console.log("PWA Registration failed with "+e)})</script></body></html>