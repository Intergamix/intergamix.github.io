<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content_Type" content="text/html; charset=UTF-8"><meta http-equiv="Cache-Control" content="max-age=7200"><meta http-equiv="Content-Encoding" content="gzip"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Unity光照第一讲(翻译四)" /><meta name="author" content="Jasper Flick" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="本篇摘要 将法线从对象空间转换为世界空间。 使用方向光。 计算光的漫反射和镜面反射。 调整光的能耗强度。 应用金属工作流程。 学习使用Unity的PBS算法。" /><meta property="og:description" content="本篇摘要 将法线从对象空间转换为世界空间。 使用方向光。 计算光的漫反射和镜面反射。 调整光的能耗强度。 应用金属工作流程。 学习使用Unity的PBS算法。" /><link rel="canonical" href="https://www.damonc.top/posts/Unity-First-light/" /><meta property="og:url" content="https://www.damonc.top/posts/Unity-First-light/" /><meta property="og:site_name" content="afeng" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2018-01-03T08:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Unity光照第一讲(翻译四)" /><meta name="twitter:site" content="@" /><meta name="twitter:creator" content="@catlikecoding" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Jasper Flick","url":"https://catlikecoding.com/jasper-flick/"},"dateModified":"2018-01-03T08:00:00+08:00","datePublished":"2018-01-03T08:00:00+08:00","description":"本篇摘要 将法线从对象空间转换为世界空间。 使用方向光。 计算光的漫反射和镜面反射。 调整光的能耗强度。 应用金属工作流程。 学习使用Unity的PBS算法。","headline":"Unity光照第一讲(翻译四)","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.damonc.top/posts/Unity-First-light/"},"url":"https://www.damonc.top/posts/Unity-First-light/"}</script><title> Unity光照第一讲(翻译四) - afeng</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><link rel="mask-icon" href="/assets/img/favicons/safari-pinned-tab.svg" color="#5bbad5"><meta name="apple-mobile-web-app-title" content="afeng`s blog"><meta name="application-name" content="Afeng Blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><link rel="stylesheet" href="/assets/css/APlayer.min.css"> <script src="/assets/js/dist/APlayer.min.js"></script> <script src="/assets/js/dist/Meting.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://damonc-top2.github.io/web-assets/commons/avatar.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-subtitle"><p>思绪来去无影踪</p><p>偶尔会在这里停留</p></div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href=" javascript:location.href = 'mailto:' + ['damonc','126.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href=" /feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>Unity光照第一讲(翻译四)</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Unity光照第一讲(翻译四)</h1><div class="post-meta text-muted"><div class="d-flex"><div> <span> 作者 <em> <a href="https://catlikecoding.com/jasper-flick/">Jasper Flick</a> </em> </span> <span> 发表于 <em class="timeago" data-ts="1514937600" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2018-01-03 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="6886 字"> <em>38 分钟</em>阅读</span></div></div></div><div class="post-content"><p>本篇摘要</p><ul><li>将法线从对象空间转换为世界空间。<li>使用方向光。<li>计算光的漫反射和镜面反射。<li>调整光的能耗强度。<li>应用金属工作流程。<li>学习使用Unity的PBS算法。</ul><h3 id="the-first-light"><span class="mr-2">The First Light</span><a href="#the-first-light" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><hr /><p><img data-src="https://catlikecoding.com/tutorial-image.jpg" alt="" data-proofer-ignore></p><p>It is time to shine a light on things.</p><h2 id="normals"><span class="mr-2">Normals</span><a href="#normals" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>We can see things, because our eyes can detect electromagnetic radiation. Individual quanta of light are known as photons. We can see a part of the electromagnetic spectrum, which is know to us as visible light. The rest of the spectrum is invisible to us.</p><h3 id="whats-the-entire-electromagnetic-spectrum"><span class="mr-2">What’s the entire electromagnetic spectrum?</span><a href="#whats-the-entire-electromagnetic-spectrum" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>The spectrum is split into spectral bands. From low to high frequency, these are known as radio waves, microwaves, infrared, visible light, ultraviolet, X-rays, and gamma rays.</p><p>A light source emits light. Some of this light hits objects. Some of this light bounces off the object. If that light then ends up hitting our eyes – or the camera lens – then we see the object.</p><p>To work this all out, we have to know our object’s surface. We already know its position, but not its orientation. For that, we need the surface normal vectors.</p><h3 id="using-mesh-normals"><span class="mr-2">Using Mesh Normals</span><a href="#using-mesh-normals" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Duplicate our first shader, and use that as our first lighting shader. Create a material with this shader and assign it to some cubes and spheres in the scene. Give the objects different rotations and scales, some non-uniform, to get a varied scene.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>Shader "Custom/My First Lighting Shader" {
	…
}
</pre></table></code></div></div><p><img data-src="https://catlikecoding.com/normals/objects.png" alt="" data-proofer-ignore></p><p>Some cubes and spheres.</p><p>Unity’s cube and sphere meshes contain vertex normals. We can grab them and pass them straight to the fragment shader.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre>			struct VertexData {
				float4 position : POSITION;
				float3 normal : NORMAL;
				float2 uv : TEXCOORD0;
			};
			
			struct Interpolators {
				float4 position : SV\_POSITION;
				float2 uv : TEXCOORD0;
				float3 normal : TEXCOORD1;
			};

			Interpolators MyVertexProgram (VertexData v) {
				Interpolators i;
				i.uv = TRANSFORM\_TEX(v.uv, \_MainTex);
				i.position = mul(UNITY\_MATRIX\_MVP, v.position);
				i.normal = v.normal;
				return i;
			}
</pre></table></code></div></div><p>Now we can visualize the normals in our shader.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>			float4 MyFragmentProgram (Interpolators i) : SV\_TARGET {
				return float4(i.normal \* 0.5 + 0.5, 1);
			}
</pre></table></code></div></div><p><img data-src="https://catlikecoding.com/normals/batching.png" alt="" data-proofer-ignore></p><p>Normal vectors as colors.</p><p>These are the raw normals, directly from the mesh. The faces of the cubes appear flat, because each face is a separate quad with four vertices. The normals of these vertices all point in the same direction. In contrast, the vertex normals of the spheres all point in different directions, resulting in a smooth interpolation.</p><h3 id="dynamic-batching"><span class="mr-2">Dynamic Batching</span><a href="#dynamic-batching" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>There is something strange going on with the cube normals. We’d expect each cube to show the same colors, but this is not the case. Even weirder, the cubes can change color, depending on how we look at them.</p><p>Color-changing cubes.</p><p>This is caused by dynamic batching. Unity dynamically merges small meshes together, to reduce draw calls. The meshes of the spheres are too large for this, so they aren’t affected. But the cubes are fair game.</p><p>To merge meshes, they have to be converted from their local space to world space. Whether and how objects are batched depends, among other things, on how they are sorted for rendering. As this conversion affects the normals as well, this is why we see the colors change.</p><p>If you want to, you can switch dynamic batching off via the player settings.</p><p><img data-src="https://catlikecoding.com/normals/batching-settings.png" alt="" data-proofer-ignore></p><p>Batching settings.</p><p>Besides dynamic batching, Unity can also do static batching. This works differently for static geometry, but also involves a conversion to world space. It happens at build time.</p><p><img data-src="https://catlikecoding.com/normals/no-batching.png" alt="" data-proofer-ignore></p><p>Normals, without dynamic batching.</p><p>While you need to be aware of dynamic batching, it’s nothing to be worried about. In fact, we have to do the same thing for our normals. So you can leave it enabled.</p><h3 id="normals-in-world-space"><span class="mr-2">Normals in World Space</span><a href="#normals-in-world-space" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Except for dynamically batched objects, all our normals are in object space. But we have to know the surface orientation in world space. So we have to transform the normals from object to world space. We need the object’s transformation matrix for that.</p><p>Unity collapses an object’s entire transformation hierarchy into a single transformation matrix, just like we did in <a href="https://catlikecoding.com/unity/tutorials/rendering/part-1">part 1</a>. We could write this as `O = T_1 T_2 T_3 …` where `T` are the individual transformations and `O` is the combined transformation. This matrix is known as the object-to-world matrix.</p><p>Unity makes this matrix available in shaders via a <code class="language-plaintext highlighter-rouge">float4x4 unity_ObjectToWorld</code> variable, which is defined in <em>UnityShaderVariables</em>. Multiply this matrix with the normal in the vertex shader to transform it to world space. And because it’s a direction, repositioning should be ignored. So the fourth homogeneous coordinate must be zero.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>			Interpolators MyVertexProgram (VertexData v) {
				Interpolators i;
				i.position = mul(UNITY\_MATRIX\_MVP, v.position);
				i.normal = mul(unity\_ObjectToWorld, float4(v.normal, 0));
				i.uv = TRANSFORM\_TEX(v.uv, \_MainTex);
				return i;
			}
</pre></table></code></div></div><p>Alternatively, we can multiply with only the 3 by 3 part of the matrix. The compiled code ends up the same, because the compilers will eliminate everything that gets multiplied with the constant zero.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>				i.normal = mul((float3x3)unity\_ObjectToWorld, v.normal);
</pre></table></code></div></div><p><img data-src="https://catlikecoding.com/normals/object-to-world.png" alt="" data-proofer-ignore></p><p>Going from object to world space.</p><p>The normals are now in world space, but some appear brighter than others. That’s because they got scaled as well. So we have to normalize them after the transformation.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>			i.normal = mul(unity\_ObjectToWorld, float4(v.normal, 0));
			i.normal = normalize(i.normal);
</pre></table></code></div></div><p><img data-src="https://catlikecoding.com/normals/normalized.png" alt="" data-proofer-ignore></p><p>Normalized normals.</p><p>While we have normalized vectors again, they look weird for objects that don’t have a uniform scale. That’s because when a surface gets stretched in one dimension, its normals don’t stretch in the same way.</p><p><img data-src="https://catlikecoding.com/normals/scaling-incorrect.png" alt="" data-proofer-ignore></p><p>Scaling X, both vertices and normals by ½.</p><p>When the scale is not uniform, it should be inverted for the normals. That way the normals will match the shape of the deformed surface, after they’ve been normalized again. And it doesn’t make a difference for uniform scales.</p><p><img data-src="https://catlikecoding.com/normals/scaling-correct.png" alt="" data-proofer-ignore></p><p>Scaling X, vertices by ½ and normals by 2.</p><p>So we have to invert the scale, but the rotation should remain the same. How can we do this?</p><p>We described an object’s transformation matrix as `O = T_1 T_2 T_3 …` but we can be more specific than that. We know that each step in the hierarchy combines a scaling, rotating, and positioning. So each `T` can be decomposed into `S R P`.</p><p>This means that `O = S_1 R_1 P_1 S_2 R_2 P_2 S_3 R_3 P_3 …` but let’s just say `O = S_1 R_1 P_1 S_2 R_2 P_2` to keep it short.</p><p>Because normals are direction vectors, we don’t care about repositioning. So we can shorten it further to `O = S_1 R_1 S_2 R_2` and we only have to consider 3 by 3 matrices.</p><p>We want to invert the scaling, but keep the rotations the same. So we want a new matrix `N = S_1^-1 R_1 S_2^-1 R_2`.</p><h3 id="how-do-inverse-matrices-work"><span class="mr-2">How do inverse matrices work?</span><a href="#how-do-inverse-matrices-work" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>The inverse of a matrix `M` is written as `M^-1`. It is a matrix that will undo the operation of another matrix when they are multiplied. Each is the inverse of the other. So `M M^-1 = M^-1 M = I`.</p><p>To undo a sequence of steps, you have to perform the inverse steps in reverse order. The mnemonic for this involves socks and shoes. This means that `(A B)^-1 = B^-1 A^-1`.</p><p>In the case of a single number `x`, its inverse is simply `1/x`, because `x/x = 1`. This also demonstrates that zero has no inverse. Neither does every matrix have an inverse.</p><p>We’re working with scaling, rotating, and repositioning matrices. As long as we’re not scaling by zero, all these matrices can be inverted.</p><p>The inverse of a reposition matrix is made by simply negating the XYZ offset in it’s fourth column.</p><p>`[[1,0,0,x],[0,1,0,y],[0,0,1,z],[0,0,0,1]]^-1 = [[1,0,0,-x],[0,1,0,-y],[0,0,1,-z],[0,0,0,1]]`</p><p>The inverse of a scaling matrix is made by inverting its diagonal. We only need to consider the 3 by 3 matrix.</p><p>`[[x,0,0],[0,y,0],[0,0,z]]^-1 = [[1/x,0,0],[0,1/y,0],[0,0,1/z]]`</p><p>Rotation matrices can be considered one axis at a time, for example around the Z axis. A rotation by `z` radians can be undone by simply rotating by `-z` radians. When you study the sine and cosine waves, you’ll notice that `sin (-z) = -sin z` and `cos (-z) = cos z`. This makes the inverse matrix simple.</p><p>`[[cos z, -sin z, 0],[sin z, cos z, 0],[0,0,1]]^-1 = [[cos z, sin z, 0],[-sin z, cos z, 0],[0,0,1]]`</p><p>Notice that the rotation inverse is the same as the original matrix flipped across its main diagonal. Only the signs of the sine components changed.</p><p>Besides the object-to-world matrix, Unity also provides an object’s world-to-object matrix. These matrices are indeed inverses of each other. So we also have access to `O^-1 = R_2^-1 S_2^-1 R_1^-1 S_1^-1`.</p><p>That gives us the inverse scaling that we need, but also gives us the inverse rotations and a reversed transformation order. Fortunately, we can remove those unwanted effects by transposing the matrix. Then we get `(O^-1)^T = N`.</p><h3 id="what-is-the-transpose-of-a-matrix"><span class="mr-2">What is the transpose of a matrix?</span><a href="#what-is-the-transpose-of-a-matrix" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>The transpose of a matrix `M` is written as `M^T`. You transpose a matrix by flipping its main diagonal. So its rows become columns, and its columns become rows. Note that this means that the diagonal itself is unchanged.</p><p>`[[1,2,3],[4,5,6],[7,8,9]]^T = [[1,4,7],[2,5,8],[3,6,9]]`</p><p>Like inversion, transposing a sequence of matrix multiplications reverses its order. `(A B)^T = B^T A^T`. This makes sense when working with matrices that aren’t square, otherwise you could end up with invalid multiplications. But it’s true in general, and you can look up the proof for it.</p><p>Of course flipping twice gets you back where you started. So `(M^T)^T = M`.</p><h3 id="why-does-transposing-produce-the-correct-matrix"><span class="mr-2">Why does transposing produce the correct matrix?</span><a href="#why-does-transposing-produce-the-correct-matrix" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>First, notice that `R^-1 = R^T`, as observed above.</p><p>This leads to `O^-1 = R_2^-1 S_2^-1 R_1^-1 S_1^-1 = R_2^T S_2^-1 R_1^T S_1^-1`.</p><p>Now let’s transpose `(O^-1)^T = (S_1^-1)^T (R_1^T)^T (S_2^1)^T (R_2^T)^T = (S_1^-1)^T R_1 (S_2^-1)^T R_2`.</p><p>Next, notice that `S^T = S`, because these matrices have zeros everywhere, except along their main diagonal.</p><p>This leads to `(O^-1)^T = S_1^-1 R_1 S_2^-1 R_2 = N`.</p><p>So let’s transpose the world-to-object matrix and multiply that with the vertex normal.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>				i.normal = mul(
					transpose((float3x3)unity\_WorldToObject),
					v.normal
				);
				i.normal = normalize(i.normal);
</pre></table></code></div></div><p><img data-src="https://catlikecoding.com/normals/correct-normals.png" alt="" data-proofer-ignore></p><p>Correct world-space normals.</p><p>Actually, <em>UnityCG</em> contains a handy <code class="language-plaintext highlighter-rouge">UnityObjectToWorldNormal</code> function that does exactly this. So we can use that function. It also does it with explicit multiplications, instead of using <code class="language-plaintext highlighter-rouge">transpose</code>. That should result in better compiled code.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>			Interpolators MyVertexProgram (VertexData v) {
				Interpolators i;
				i.position = mul(UNITY\_MATRIX\_MVP, v.position);
				i.normal = UnityObjectToWorldNormal(v.normal);
				i.uv = TRANSFORM\_TEX(v.uv, \_MainTex);
				return i;
			}
</pre></table></code></div></div><h3 id="what-does-unityobjecttoworldnormal-look-like"><span class="mr-2">What does <code class="language-plaintext highlighter-rouge"><span class="mr-2">UnityObjectToWorldNormal</code> look like?</span><a href="#what-does-unityobjecttoworldnormal-look-like" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Here it is. The <code class="language-plaintext highlighter-rouge">inline</code> keyword doesn’t do anything, in case you’re wondering.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>// Transforms normal from object to world space
inline float3 UnityObjectToWorldNormal( in float3 norm ) {
	// Multiply by transposed inverse matrix,
	// actually using transpose() generates badly optimized code
	return normalize(
		unity\_WorldToObject\[0\].xyz \* norm.x +
		unity\_WorldToObject\[1\].xyz \* norm.y +
		unity\_WorldToObject\[2\].xyz \* norm.z
	);
}
</pre></table></code></div></div><h3 id="renormalizing"><span class="mr-2">Renormalizing</span><a href="#renormalizing" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>After producing correct normals in the vertex program, they are passed through the interpolator. Unfortunately, linearly interpolating between different unit-length vectors does not result in another unit-length vector. It will be shorter.</p><p>So we have to normalize the normals again in the fragment shader.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>			float4 MyFragmentProgram (Interpolators i) : SV\_TARGET {
				i.normal = normalize(i.normal);
				return float4(i.normal \* 0.5 + 0.5, 1);
			}
</pre></table></code></div></div><p><img data-src="https://catlikecoding.com/normals/renormalized.png" alt="" data-proofer-ignore></p><p>Renormalized normals.</p><p>While this produces better results, the error is usually very small. You could decide to not renormalize in the fragment shader, if you value performance more. This is a common optimization for mobile devices.</p><p><img data-src="https://catlikecoding.com/normals/interpolation-error.png" alt="" data-proofer-ignore></p><p>Exaggerated error.</p><p><a href="https://catlikecoding.com/normals/normals.unitypackage">unitypackage</a></p><h2 id="diffuse-shading"><span class="mr-2">Diffuse Shading</span><a href="#diffuse-shading" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>We see objects that aren’t themselves light sources, because they reflect light. There are different ways in which this reflection can happen. Let’s first consider diffuse reflection.</p><p>Diffuse reflection happens because a ray of light doesn’t just bounce off a surface. Instead, it penetrates the surface, bounces around for a bit, gets split up a few times, until it exits the surface again. In reality, the interaction between photons and atoms is more complex than that, but we don’t need to know the real-world physics in that much detail.</p><p>How much light is diffusely refected off a surface depends on the angle at which the light ray hits it. Most light is reflected when the surface is hit head-on, at a 0° angle. As this angle increases, the reflections will decrease. At 90°, no light hits the surface anymore, so it stays dark. The amount of diffused light is directly proportional to the cosine of the angle between the light direction and the surface normal. This is known as Lambert’s cosine law.</p><p><img data-src="https://catlikecoding.com/diffuse-shading/lambert.png" alt="" data-proofer-ignore></p><p>Diffuse reflections.</p><p>We can determine this Lamberterian reflectance factor by computing the dot product of the surface normal and the light direction. We already know the normal, but not yet the light direction. Let’s start with a fixed light direction, coming directly from above.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>			float4 MyFragmentProgram (Interpolators i) : SV\_TARGET {
				i.normal = normalize(i.normal);
				return dot(float3(0, 1, 0), i.normal);
			}
</pre></table></code></div></div><p><img data-src="https://catlikecoding.com/diffuse-shading/lit-from-above-gamma.png" alt="gamma" data-proofer-ignore> <img data-src="https://catlikecoding.com/diffuse-shading/lit-from-above-linear.png" alt="linear" data-proofer-ignore></p><p>Lit from above, in gamma and linear space.</p><h3 id="whats-a-dot-product"><span class="mr-2">What’s a dot product?</span><a href="#whats-a-dot-product" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>The dot product between two vectors is geometrically defined as `A * B = ||A|| ||B|| cos theta`. This means that it is the cosine of the angle between the vectors, multiplied by their lengths. So in the case of two unity vectors, `A * B = cos theta`.</p><p>Algebraically, it is defined as `A * B = sum_(i=1)^n A_i B_i = A_1 B_1 + A_2 B_2 + … + A_n B_n`. This means that you can compute it by multiplying all component pairs and sum them.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>float dotProduct = v1.x \* v2.x + v1.y \* v2.y + v1.z \* v2.z;
</pre></table></code></div></div><p>Visually, this operation projects one vector straight down to the other. As if casting a shadow on it. In doing so, you end up with a right triangle of which the bottom side’s length is the result of the dot product. And if both vectors are unit length, that’s the cosine of their angle.</p><p><img data-src="https://catlikecoding.com/diffuse-shading/dot-product.png" alt="" data-proofer-ignore></p><p>Dot product.</p><h3 id="clamped-lighting"><span class="mr-2">Clamped Lighting</span><a href="#clamped-lighting" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Computing the dot product works when the surface is directed towards the light, but not when it is directed away from it. In that case, the surface would logically be in its own shadow and it should receive no light at all. As the angle between the light direction and the normal must be larger than 90° at this point, its cosine and thus the dot product becomes negative. As we don’t want negative light, we have to clamp the result. We can use the standard <code class="language-plaintext highlighter-rouge">max</code> function for that.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>				return max(0, dot(float3(0, 1, 0), i.normal));
</pre></table></code></div></div><p>Instead of <code class="language-plaintext highlighter-rouge">max</code>, you’ll often see shaders use <code class="language-plaintext highlighter-rouge">saturate</code> instead. This standard function clamps between 0 and 1.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>				return saturate(dot(float3(0, 1, 0), i.normal));
</pre></table></code></div></div><p>This seems unnecessary, as we know that our dot product will never produce a result that is greater than 1. However, in some cases it can actually be more efficient, depending on the hardware. But we shouldn’t worry about such micro optimizations at this point. In fact, we can delegate that to the folks at Unity.</p><p>The <em>UnityStandardBRDF</em> include file defines the convenient <code class="language-plaintext highlighter-rouge">DotClamped</code> function. This function performs a dot product and makes sure it is never negative. This is exactly what we need. It contains a lot of other lighting function as well, and includes other useful files too, which we’ll need later. So let’s use it!</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>			#include "UnityCG.cginc"
			#include "UnityStandardBRDF.cginc"

			…

			float4 MyFragmentProgram (Interpolators i) : SV\_TARGET {
				i.normal = normalize(i.normal);
				return DotClamped(float3(0, 1, 0), i.normal);
			}
</pre></table></code></div></div><h3 id="what-does-dotclamped-look-like"><span class="mr-2">What does <code class="language-plaintext highlighter-rouge"><span class="mr-2">DotClamped</code> look like?</span><a href="#what-does-dotclamped-look-like" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Here it is. Apparently, they decided that it’s better to use <code class="language-plaintext highlighter-rouge">saturate</code> when targeting low-capability shader hardware, and when targeting PS3.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>inline half DotClamped (half3 a, half3 b) {
	#if (SHADER\_TARGET &lt; 30 || defined(SHADER\_API\_PS3))
		return saturate(dot(a, b));
	#else
		return max(0.0h, dot(a, b));
	#endif
}
</pre></table></code></div></div><p>This shader uses half-precision numbers, but you don’t need to worry about numerical precision yet. It only makes a difference for mobile devices.</p><p>Because <em>UnityStandardBRDF</em> already includes <em>UnityCG</em> and some other files, we don’t have to explicitly include it anymore. It is not wrong to do so, but we might as well keep it short.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>~//			#include "UnityCG.cginc"~
			#include "UnityStandardBRDF.cginc"
</pre></table></code></div></div><p><img data-src="https://catlikecoding.com/diffuse-shading/include-files.png" alt="" data-proofer-ignore></p><p>Include file hierarchy, starting at <em>UnityStandardBRDF</em>.</p><h3 id="light-source"><span class="mr-2">Light Source</span><a href="#light-source" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Instead of a hard-coded light direction, we should use the direction of the light that’s in our scene. By default, each Unity scene has a light that represents the sun. It is a directional light, which means that it is considered to be infinitely far away. As a result, all its light rays come from exactly the same direction. Of course this isn’t true in real life, but the sun is so far away that it is a fair approximation.</p><p><img data-src="https://catlikecoding.com/diffuse-shading/default-scene-light.png" alt="" data-proofer-ignore></p><p>Default scene light, moved out of the way.</p><p><em>UnityShaderVariables</em> defines <code class="language-plaintext highlighter-rouge">float4 _WorldSpaceLightPos0</code>, which contains the position of the current light. Or the direction that the light rays are coming from, in case of a directional light. It has four components, because these are homogeneous coordinates. So the fourth component is 0 for our directional light.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>				float3 lightDir = \_WorldSpaceLightPos0.xyz;
				return DotClamped(lightDir, i.normal);
</pre></table></code></div></div><h3 id="light-mode"><span class="mr-2">Light Mode</span><a href="#light-mode" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Before this produces correct result, we have to tell Unity which light data we want to use. We do so by adding a <em>LightMode</em> tag to our shader pass.</p><p>Which light mode we need depends on how we’re rendering the scene. We can either use the forward or the deferred rendering path. There are also two older rendering modes, but we won’t bother with those. You choose the rendering path via the player rendering settings. It sits right above the color space choice. We’re using forward rendering, which is the default.</p><p><img data-src="https://catlikecoding.com/diffuse-shading/rendering-path.png" alt="" data-proofer-ignore></p><p>Rendering path choice.</p><p>We have to use the <em>ForwardBase</em> pass. This is the first pass used when rendering something via the forward rendering path. It gives us access to the main directional light of the scene. It sets up some other things as well, but we’ll cover those later.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre>		Pass {
			Tags {
				"LightMode" = "ForwardBase"
			}

			CGPROGRAM

			…

			ENDCG
		}
</pre></table></code></div></div><p>Diffuse light.</p><h3 id="light-color"><span class="mr-2">Light Color</span><a href="#light-color" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Of course light isn’t always white. Each light source has its own color, which we can get to via the <code class="language-plaintext highlighter-rouge">fixed4 _LightColor0</code> variable, which is defined in <em>UnityLightingCommon</em>.</p><h3 id="what-is-fixed4"><span class="mr-2">What is <code class="language-plaintext highlighter-rouge"><span class="mr-2">fixed4</code>?</span><a href="#what-is-fixed4" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>These are low-precision numbers, which trade precision for speed on mobile devices. On desktops, <code class="language-plaintext highlighter-rouge">fixed</code> is just an alias for <code class="language-plaintext highlighter-rouge">float</code>. Precision optimizations are a subject for later.</p><p>This variable contains the light’s color, multiplied by its intensity. Although it provides all four channels, we only need the RGB components.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>			float4 MyFragmentProgram (Interpolators i) : SV\_TARGET {
				i.normal = normalize(i.normal);
				float3 lightDir = \_WorldSpaceLightPos0.xyz;
				float3 lightColor = \_LightColor0.rgb;
				float3 diffuse = lightColor \* DotClamped(lightDir, i.normal);
				return float4(diffuse, 1);
			}
</pre></table></code></div></div><p><img data-src="https://catlikecoding.com/diffuse-shading/light-color.png" alt="" data-proofer-ignore></p><p>Colored light.</p><h3 id="albedo"><span class="mr-2">Albedo</span><a href="#albedo" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Most materials absorb part of the electromagnetic spectrum. This gives them their color. For example, if all visible red frequencies are absorbed, what escapes will appear cyan.</p><h3 id="what-happens-to-the-light-that-doesnt-escape"><span class="mr-2">What happens to the light that doesn’t escape?</span><a href="#what-happens-to-the-light-that-doesnt-escape" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>The light’s energy gets stored in the object, typically as heat. That’s why black things tend to be warmer than white things.</p><p>The color of the diffuse reflectivity of a material is known as its albedo. Albedo is Latin for whiteness. So it describes how much of the red, green, and blue color channels are diffusely reflected. The rest is absorbed. We can use the material’s texture and tint to define this.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>			float4 MyFragmentProgram (Interpolators i) : SV\_TARGET {
				i.normal = normalize(i.normal);
				float3 lightDir = \_WorldSpaceLightPos0.xyz;
				float3 lightColor = \_LightColor0.rgb;
				float3 albedo = tex2D(\_MainTex, i.uv).rgb \* \_Tint.rgb;
				float3 diffuse =
					albedo \* lightColor \* DotClamped(lightDir, i.normal);
				return float4(diffuse, 1);
			}
</pre></table></code></div></div><p>Let’s also change the label of the main texture to <em>Albedo</em> in the inspector.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>	Properties {
		\_Tint ("Tint", Color) = (1, 1, 1, 1)
		\_MainTex ("Albedo", 2D) = "white" {}
	}

</pre></table></code></div></div><p><img data-src="https://catlikecoding.com/diffuse-shading/albedo-inspector.png" alt="inspector" data-proofer-ignore><br /> <img data-src="https://catlikecoding.com/diffuse-shading/albedo-gamma.png" alt="gamma" data-proofer-ignore> <img data-src="https://catlikecoding.com/diffuse-shading/albedo-linear.png" alt="linear" data-proofer-ignore></p><p>Diffuse shading with albedo, in gamma and linear space.</p><p><a href="https://catlikecoding.com/diffuse-shading/diffuse-shading.unitypackage">unitypackage</a></p><h2 id="specular-shading"><span class="mr-2">Specular Shading</span><a href="#specular-shading" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Besides diffuse reflections, there are also specular reflections. This happens when light doesn’t get diffused after hitting a surface. Instead, the light ray bounces off the surface at and angle equal to the angle at which it hit the surface. This is what causes the reflections that you see in mirrors.</p><p>Unlike with diffuse reflections, the position of the viewer matters for specular reflections. Only light that ends up reflected directly towards you is visible. The rest goes somewhere else, so you won’t see it.</p><p>So we need to know the direction from the surface to the viewer. This requires the world-space positions of the surface and the camera.</p><p>We can determine the world position of the surface in the vertex program, via the object-to-world matrix, then pass it to the fragment program.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre>			struct Interpolators {
				float4 position : SV\_POSITION;
				float2 uv : TEXCOORD0;
				float3 normal : TEXCOORD1;
				float3 worldPos : TEXCOORD2;
			};

			Interpolators MyVertexProgram (VertexData v) {
				Interpolators i;
				i.position = mul(UNITY\_MATRIX\_MVP, v.position);
				i.worldPos = mul(unity\_ObjectToWorld, v.position);
				i.normal = UnityObjectToWorldNormal(v.normal);
				i.uv = TRANSFORM\_TEX(v.uv, \_MainTex);
				return i;
			}
</pre></table></code></div></div><p>The position of the camera can be accessed via <code class="language-plaintext highlighter-rouge">float3 _WorldSpaceCameraPos</code>, which is defined in <em>UnityShaderVariables</em>. We find the view direction subtracting the surface position from this and normalizing.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre>			float4 MyFragmentProgram (Interpolators i) : SV\_TARGET {
				i.normal = normalize(i.normal);
				float3 lightDir = \_WorldSpaceLightPos0.xyz;
				float3 viewDir = normalize(\_WorldSpaceCameraPos - i.worldPos);
				
				float3 lightColor = \_LightColor0.rgb;
				float3 albedo = tex2D(\_MainTex, i.uv).rgb \* \_Tint.rgb;
				float3 diffuse =
					albedo \* lightColor \* DotClamped(lightDir, i.normal);
				return float4(diffuse, 1);
			}
</pre></table></code></div></div><h3 id="dont-unitys-shaders-interpolate-the-view-direction"><span class="mr-2">Don’t Unity’s shaders interpolate the view direction?</span><a href="#dont-unitys-shaders-interpolate-the-view-direction" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Yes. Unity’s shaders compute the view direction in the vertex program and interpolates that. Normalization is done in the fragment program, or in the vertex program for less-capable hardware. Either approach is fine.</p><h3 id="reflecting-light"><span class="mr-2">Reflecting Light</span><a href="#reflecting-light" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>To know where the reflected light goes, we can use the standard <code class="language-plaintext highlighter-rouge">reflect</code> function. It takes the direction of an incoming light ray and reflects it based on a surface normal. So we have to negate our light direction.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>				float3 reflectionDir = reflect(-lightDir, i.normal);

				return float4(reflectionDir \* 0.5 + 0.5, 1);
</pre></table></code></div></div><p><img data-src="https://catlikecoding.com/specular-shading/reflection-directions.png" alt="" data-proofer-ignore></p><p>Reflection directions.</p><h3 id="how-does-reflecting-a-vector-work"><span class="mr-2">How does reflecting a vector work?</span><a href="#how-does-reflecting-a-vector-work" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>You can reflect a direction `D` with a normal `N` by computing `D - 2N (N · D)`.</p><p>In case of a perfectly smooth mirror, we’d only see reflected light where the surface angle is just right. In all other places, the reflected light misses us and the surface would appear black to us. But objects aren’t perfectly smooth. They have lots of microscopic bumps, which means that the surface normal can vary a lot.</p><p>So we could see some of the reflection, even if our view direction doesn’t exactly match the reflection direction. The more we deviate from the reflection direction, the less of it we’ll see. Once again, we can use the clamped dot product to figure out how much light reaches us.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>				return DotClamped(viewDir, reflectionDir);
</pre></table></code></div></div><p><img data-src="https://catlikecoding.com/specular-shading/reflections.png" alt="diagram" data-proofer-ignore> <img data-src="https://catlikecoding.com/specular-shading/phong.png" alt="graphics" data-proofer-ignore></p><p>Specular reflections.</p><h3 id="smoothness"><span class="mr-2">Smoothness</span><a href="#smoothness" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>The size of the highlight produced by this effect depends on the roughness of the material. Smooth materials focus the light better, so they have smaller highlights. We can control this smoothness by making it a material property. It is typically defined as a value between 0 and 1, so let’s make it a slider.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>	Properties {
		\_Tint ("Tint", Color) = (1, 1, 1, 1)
		\_MainTex ("Texture", 2D) = "white" {}
		\_Smoothness ("Smoothness", Range(0, 1)) = 0.5
	}
		
		…

			float \_Smoothness;
</pre></table></code></div></div><p>We narrow the highlight by raising the dot product to a higher power. We use the smoothness value for that, but it has to be much larger than 1 to have the desired effect. So let’s just multiply it by 100.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>				return pow(
					DotClamped(viewDir, reflectionDir),
					\_Smoothness \* 100
				);
</pre></table></code></div></div><p><img data-src="https://catlikecoding.com/specular-shading/smoothness-slider.png" alt="inspector" data-proofer-ignore><br /> <img data-src="https://catlikecoding.com/specular-shading/smoothness.png" alt="smoothness" data-proofer-ignore></p><p>Pretty smooth.</p><h3 id="blinn-phong"><span class="mr-2">Blinn-Phong</span><a href="#blinn-phong" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>We’re currently computing the reflection according to the Blinn reflection model. But the most-often used model is Blinn-Phong. It uses a vector halfway between the light direction and the view direction. The dot product between the normal and the half vector determines the specular contribution.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>~//				float3 reflectionDir = reflect(-lightDir, i.normal);~
				float3 halfVector = normalize(lightDir + viewDir);

				return pow(
					DotClamped(halfVector, i.normal),
					\_Smoothness \* 100
				);

</pre></table></code></div></div><p><img data-src="https://catlikecoding.com/specular-shading/halfway-vector.png" alt="diagram" data-proofer-ignore> <img data-src="https://catlikecoding.com/specular-shading/blinn-phong.png" alt="graphics" data-proofer-ignore></p><p>Blinn-Phong specular.</p><p>This approach produces a larger highlight, but that can be countered by using a higher smoothness value. The result turns out to visually match reality a bit better than Phong, although both methods are still approximations. One big limitation is that it can produce invalid highlights for objects that are lit from behind.</p><p><img data-src="https://catlikecoding.com/specular-shading/specular-error.png" alt="" data-proofer-ignore></p><p>Incorrect specular, with smoothness 0.01.</p><p>These artifacts become noticeable when using low smoothness values. They can be hidden by using shadows, or by fading out the specular based on the light angle. Unity’s legacy shaders have this problem too, so we’ll not worry about it either. We’ll move on to another lighting method soon anyway.</p><h3 id="specular-color"><span class="mr-2">Specular Color</span><a href="#specular-color" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Of course the color of the specular reflection matches that of the light source. So let’s factor it in.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>				float3 halfVector = normalize(lightDir + viewDir);
				float3 specular = lightColor \* pow(
					DotClamped(halfVector, i.normal),
					\_Smoothness \* 100
				);

				return float4(specular, 1);
</pre></table></code></div></div><p>But that is not all. The color of the reflection also depends on the material. This is not the same as the albedo. Metals tend to have very little if any albedo, while having strong and often colored specular reflectivity. In contrast, nonmetals tend to have a distinct albedo, while their specular reflectivity is weaker and not colorized.</p><p>We can add a texture and tint to define the specular color, just as we do for the albedo. But let’s not bother with another texture and just use a tint.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre>	Properties {
		\_Tint ("Tint", Color) = (1, 1, 1, 1)
		\_MainTex ("Albedo", 2D) = "white" {}
		\_SpecularTint ("Specular", Color) = (0.5, 0.5, 0.5)
		\_Smoothness ("Smoothness", Range(0, 1)) = 0.1
	}

	…

			float4 \_SpecularTint;
			float \_Smoothness;

			…

			float4 MyFragmentProgram (Interpolators i) : SV\_TARGET {
				…

				float3 halfVector = normalize(lightDir + viewDir);
				float3 specular = \_SpecularTint.rgb \* lightColor \* pow(
					DotClamped(halfVector, i.normal),
					\_Smoothness \* 100
				);

				return float4(specular, 1);
			}
</pre></table></code></div></div><p>We can control both the colorizing and strength of the specular reflection with a color property.</p><p><img data-src="https://catlikecoding.com/specular-shading/specular-color.png" alt="inspector" data-proofer-ignore><br /> <img data-src="https://catlikecoding.com/specular-shading/colored-specular.png" alt="colored specular" data-proofer-ignore></p><p>Tinted specular reflection.</p><h3 id="cant-we-use-the-tints-alpha-as-smoothness"><span class="mr-2">Can’t we use the tint’s alpha as smoothness?</span><a href="#cant-we-use-the-tints-alpha-as-smoothness" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>That is certainly possible. You can also store specular color and smoothness in a single texture that way.</p><h3 id="diffuse-and-specular"><span class="mr-2">Diffuse and Specular</span><a href="#diffuse-and-specular" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Diffuse and specular reflections are two parts of the lighting puzzle. We can add them together to make our picture more complete.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>				return float4(diffuse + specular, 1);
</pre></table></code></div></div><p><img data-src="https://catlikecoding.com/specular-shading/diffuse-specular-gamma.png" alt="gamma" data-proofer-ignore> <img data-src="https://catlikecoding.com/specular-shading/diffuse-specular-linear.png" alt="linear" data-proofer-ignore></p><p>Diffuse plus specular, in gamma and linear space.</p><p><a href="https://catlikecoding.com/specular-shading/specular-shading.unitypackage">unitypackage</a></p><h2 id="energy-conservation"><span class="mr-2">Energy Conservation</span><a href="#energy-conservation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>There is a problem with just adding the diffuse and specular reflections together. The result can be brighter than the light source. This is very obvious when using a fully white specular combined with low smoothness.</p><p><img data-src="https://catlikecoding.com/energy-conservation/too-bright.png" alt="" data-proofer-ignore></p><p>White specular, 0.1 smoothness. Too bright.</p><p>When light hits a surface, part of it bounces off as specular light. The rest of it penetrates the surface and either comes back out as diffuse light, or is absorbed. But we currently do not take this into consideration. Instead, our light both reflects and diffuses at full strength. So we could end up doubling the light’s energy.</p><p>We have to make sure that the sum of the diffuse and specular parts of our material never exceed 1. That guarantees that we’re not creating light out of nowhere. It is fine if the total is less than 1. That just means that part of the light is absorbed.</p><p>As we’re using a constant specular tint, we can simply adjust the albedo tint by multiplying it by 1 minus the specular. But it is inconvenient to do this manually, especially if we want to use a specific albedo tint. So let’s do this in the shader.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>				float3 albedo = tex2D(\_MainTex, i.uv).rgb \* \_Tint.rgb;
				albedo \*= 1 - \_SpecularTint.rgb;
</pre></table></code></div></div><p><img data-src="https://catlikecoding.com/energy-conservation/not-too-bright.png" alt="" data-proofer-ignore></p><p>No longer too bright.</p><p>The diffuse and specular contributions are now linked. The stronger the specular, the fainter the diffuse part. A black specular tint produces zero reflections, in which case you’ll see the albedo at full strength. A white specular tint results in a perfect mirror, so the albedo is completely eliminated.</p><p>Energy conservation.</p><h3 id="monochrome"><span class="mr-2">Monochrome</span><a href="#monochrome" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>This approach works fine when the specular tint is a grayscale color. But it produces weird results when other colors are used. For example, a red specular tint will only reduce the red component of the diffuse part. As a result, the albedo will be tinted cyan.</p><p><img data-src="https://catlikecoding.com/energy-conservation/red-specular.png" alt="" data-proofer-ignore></p><p>Red specular, cyan albedo.</p><p>To prevent this coloration, we can use monochrome energy conservation. This just means that we use the strongest component of the specular color to reduce the albedo.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>				albedo \*= 1 -
					max(\_SpecularTint.r, max(\_SpecularTint.g, \_SpecularTint.b));

</pre></table></code></div></div><p><img data-src="https://catlikecoding.com/energy-conservation/monochrome-energy-conservation.png" alt="" data-proofer-ignore></p><p>Monochome energy conservation.</p><h3 id="utility-function"><span class="mr-2">Utility Function</span><a href="#utility-function" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>As you might expect, Unity has a utility function to take care of the energy conservation. It is <code class="language-plaintext highlighter-rouge">EnergyConservationBetweenDiffuseAndSpecular</code> and is defined in <em>UnityStandardUtils</em>.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>			#include "UnityStandardBRDF.cginc"
			#include "UnityStandardUtils.cginc"
</pre></table></code></div></div><p><img data-src="https://catlikecoding.com/energy-conservation/include-files.png" alt="" data-proofer-ignore></p><p>Include file hierarchy, starting at UnityStandardUtils.</p><p>This function takes albedo and specular colors as input, and output an adjusted albedo. But it also has a third output parameter, known as one-minus-reflectivity. This is one minus the specular strength, the factor we multiply the albedo with. It is an extra output, because reflectivity is needed for other lighting computations as well.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>				float3 albedo = tex2D(\_MainTex, i.uv).rgb \* \_Tint.rgb;
~//				albedo \*= 1 -~
~//					max(\_SpecularTint.r, max(\_SpecularTint.g, \_SpecularTint.b));~

				float oneMinusReflectivity;
				albedo = EnergyConservationBetweenDiffuseAndSpecular(
					albedo, \_SpecularTint.rgb, oneMinusReflectivity
				);
</pre></table></code></div></div><h3 id="what-does-energyconservationbetweendiffuseandspecular-look-like"><span class="mr-2">What does <code class="language-plaintext highlighter-rouge"><span class="mr-2">EnergyConservationBetweenDiffuseAndSpecular</code> look like?</span><a href="#what-does-energyconservationbetweendiffuseandspecular-look-like" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Here it is. It has three modes, either no conservation, monochrome, or colored. These are controlled with <code class="language-plaintext highlighter-rouge">#define</code> statements. The default is monochrome.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre>half SpecularStrength(half3 specular) {
	#if (SHADER\_TARGET &lt; 30)
		// SM2.0: instruction count limitation
		// SM2.0: simplified SpecularStrength
		// Red channel - because most metals are either monochrome
		// or with redish/yellowish tint
		return specular.r;
	#else
		return max(max(specular.r, specular.g), specular.b);
	#endif
}

// Diffuse/Spec Energy conservation
inline half3 EnergyConservationBetweenDiffuseAndSpecular (
	half3 albedo, half3 specColor, out half oneMinusReflectivity
) {
	oneMinusReflectivity = 1 - SpecularStrength(specColor);
	#if !UNITY\_CONSERVE\_ENERGY
		return albedo;
	#elif UNITY\_CONSERVE\_ENERGY\_MONOCHROME
		return albedo \* oneMinusReflectivity;
	#else
		return albedo \* (half3(1, 1, 1) - specColor);
	#endif
}
</pre></table></code></div></div><h3 id="metallic-workflow"><span class="mr-2">Metallic Workflow</span><a href="#metallic-workflow" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>There are basically two kinds of materials that we are concerned with. There are metals, and there are nonmetals. The latter are also known as dielectric materials. Currently, we can create metals by using a strong specular tint. And we can create dielectrics by using a weak monochrome specular. This is the specular workflow.</p><p>It would be much simpler if we could just toggle between metal and nonmetal. As metals don’t have albedo, we could use that color data for their specular tint instead. And nonmetals don’t have a colored specular anyway, so we don’t need a separate specular tint at all. This is known as the metallic workflow. Let’s go with that.</p><h3 id="which-is-the-better-workflow"><span class="mr-2">Which is the better workflow?</span><a href="#which-is-the-better-workflow" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Both approaches are fine. That’s why Unity has a standard shader for each. The metallic workflow is simpler, because you have only one color source plus a slider. This is sufficient to create realistic materials. The specular workflow can produce the same results, but because you have more control, unrealistic materials are also possible.</p><p>We can use another slider property as a metallic toggle, to replace the specular tint. Typically, it should be set to either 0 or 1, because something is either a metal or not. A value in between represents a material that has a mix of metal and nonmetal components.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre>	Properties {
		\_Tint ("Tint", Color) = (1, 1, 1, 1)
		\_MainTex ("Albedo", 2D) = "white" {}
~//		\_SpecularTint ("Specular", Color) = (0.5, 0.5, 0.5)~
		\_Metallic ("Metallic", Range(0, 1)) = 0
		\_Smoothness ("Smoothness", Range(0, 1)) = 0.1
	}

	…

~//			float4 \_SpecularTint;~
			float \_Metallic;
			float \_Smoothness;
</pre></table></code></div></div><p><img data-src="https://catlikecoding.com/energy-conservation/metallic-slider.png" alt="" data-proofer-ignore></p><p>Metallic slider.</p><p>Now we can derive the specular tint from the albedo and metallic properties. The albedo can then simply be multiplied by one minus the metallic value.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre>				float3 specularTint = albedo \* \_Metallic;
				float oneMinusReflectivity \= 1 - \_Metallic;
~//				albedo = EnergyConservationBetweenDiffuseAndSpecular(~
~//					albedo, \_SpecularTint.rgb, oneMinusReflectivity~
~//				);~
				albedo \*= oneMinusReflectivity;
				
				float3 diffuse =
					albedo \* lightColor \* DotClamped(lightDir, i.normal);

				float3 halfVector = normalize(lightDir + viewDir);
				float3 specular = specularTint \* lightColor \* pow(
					DotClamped(halfVector, i.normal),
					\_Smoothness \* 100
				);
</pre></table></code></div></div><p>However, this is an oversimplification. Even pure dielectrics still have some specular reflection. So the specular strength and reflection values do not exactly match the metallic slider’s value. And this is also influenced by the color space. Fortunately, <em>UnityStandardUtils</em> also has the <code class="language-plaintext highlighter-rouge">DiffuseAndSpecularFromMetallic</code> function, which takes care of this for us.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>				float3 specularTint; ~// = albedo \* \_Metallic;~
				float oneMinusReflectivity; ~// = 1 - \_Metallic;~
~//				albedo \*= oneMinusReflectivity;~
				albedo = DiffuseAndSpecularFromMetallic(
					albedo, \_Metallic, specularTint, oneMinusReflectivity
				);
</pre></table></code></div></div><p>Metallic workflow.</p><h3 id="what-does-diffuseandspecularfrommetallic-look-like"><span class="mr-2">What does <code class="language-plaintext highlighter-rouge"><span class="mr-2">DiffuseAndSpecularFromMetallic</code> look like?</span><a href="#what-does-diffuseandspecularfrommetallic-look-like" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Here it is. Note that it uses the <code class="language-plaintext highlighter-rouge">half4 unity_ColorSpaceDielectricSpec</code> variable, which is set by Unity based on the color space.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre>inline half OneMinusReflectivityFromMetallic(half metallic) {
	// We'll need oneMinusReflectivity, so
	//   1-reflectivity = 1-lerp(dielectricSpec, 1, metallic)
	//                  = lerp(1-dielectricSpec, 0, metallic)
	// store (1-dielectricSpec) in unity\_ColorSpaceDielectricSpec.a, then
	//	 1-reflectivity = lerp(alpha, 0, metallic)
	//                  = alpha + metallic\*(0 - alpha)
	//                  = alpha - metallic \* alpha
	half oneMinusDielectricSpec = unity\_ColorSpaceDielectricSpec.a;
	return oneMinusDielectricSpec - metallic \* oneMinusDielectricSpec;
}

inline half3 DiffuseAndSpecularFromMetallic (
	half3 albedo, half metallic,
	out half3 specColor, out half oneMinusReflectivity
) {
	specColor = lerp(unity\_ColorSpaceDielectricSpec.rgb, albedo, metallic);
	oneMinusReflectivity = OneMinusReflectivityFromMetallic(metallic);
	return albedo \* oneMinusReflectivity;
}
</pre></table></code></div></div><p>One detail is that the metallic slider itself is supposed to be in gamma space. But single values are not automatically gamma corrected by Unity, when rendering in linear space. We can use the <code class="language-plaintext highlighter-rouge">Gamma</code> attribute to tell Unity that it should also apply gamma correction to our metallic slider.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>		\[Gamma\] \_Metallic ("Metallic", Range(0, 1)) = 0
</pre></table></code></div></div><p>Unfortunately, by now the specular reflections have now become rather vague for nonmetals. To improve this, we need a better way to compute the lighting.</p><p><a href="https://catlikecoding.com/energy-conservation/energy-conservation.unitypackage">unitypackage</a></p><h2 id="physically-based-shading"><span class="mr-2">Physically-Based Shading</span><a href="#physically-based-shading" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Blinn-Phong has long been the workhorse of the game industry, but nowadays physically-based shading – known as PBS – is all the rage. And for good reason, because it is a lot more realistic and predictable. Ideally, game engines and modeling tools all use the same shading algorithms. This makes content creation much easier. The industry is slowly converging on a standard PBS implementation.</p><p>Unity’s standard shaders use a PBS approach as well. Unity actually has multiple implementations. It decides which to used based on the target platform, hardware, and API level. The algorithm is accessible via the <code class="language-plaintext highlighter-rouge">UNITY_BRDF_PBS</code> macro, which is defined in <em>UnityPBSLighting</em>. BRDF stands for bidirectional reflectance distribution function.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>~//			#include "UnityStandardBRDF.cginc"~
~//			#include "UnityStandardUtils.cginc"~
			#include "UnityPBSLighting.cginc"
</pre></table></code></div></div><p><img data-src="https://catlikecoding.com/physically-based-shading/include-files.png" alt="" data-proofer-ignore></p><p>Partial include file hierarchy, starting at <em>UnityPBSLighting</em>.</p><h3 id="what-does-unity_brdf_pbs-look-like"><span class="mr-2">What does <code class="language-plaintext highlighter-rouge"><span class="mr-2">UNITY_BRDF_PBS</code> look like?</span><a href="#what-does-unity_brdf_pbs-look-like" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>It defines an alias for one of Unity’s BRDF functions. <code class="language-plaintext highlighter-rouge">UNITY_PBS_USE_BRDF1</code> is set by Unity by default, as a platform define. This will select the best shader, unless the shader target is below 3.0.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre>// Default BRDF to use:
#if !defined (UNITY\_BRDF\_PBS)
	// allow to explicitly override BRDF in custom shader
	// still add safe net for low shader models,
	// otherwise we might end up with shaders failing to compile
	#if SHADER\_TARGET &lt; 30
		#define UNITY\_BRDF\_PBS BRDF3\_Unity\_PBS
	#elif UNITY\_PBS\_USE\_BRDF3
		#define UNITY\_BRDF\_PBS BRDF3\_Unity\_PBS
	#elif UNITY\_PBS\_USE\_BRDF2
		#define UNITY\_BRDF\_PBS BRDF2\_Unity\_PBS
	#elif UNITY\_PBS\_USE\_BRDF1
		#define UNITY\_BRDF\_PBS BRDF1\_Unity\_PBS
	#elif defined(SHADER\_TARGET\_SURFACE\_ANALYSIS)
		// we do preprocess pass during shader analysis and we dont
		// actually care about brdf as we need only inputs/outputs
		#define UNITY\_BRDF\_PBS BRDF1\_Unity\_PBS
	#else
		#error something broke in auto-choosing BRDF
	#endif
#endif
</pre></table></code></div></div><p>I don’t include the actual functions, because they are large. You can see them by downloading Unity’s include files, or by finding the files in your Unity installation. They’re in <em>UnityStandardBRDF</em>.</p><p>These functions are quite math-intensive, so I won’t go into the details. They still compute diffuse and specular reflections, just in a different way than Blinn-Phong. Besides that, there also is a Fresnel reflection component. This adds the reflections that you get when viewing objects at grazing angles. Those will become obvious once we include environmental reflections.</p><p>To make sure that Unity selects the best BRDF function, we have to target at least shader level 3.0. We do this with a pragma statement.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>			CGPROGRAM

			#pragma target 3.0

			#pragma vertex MyVertexProgram
			#pragma fragment MyFragmentProgram
</pre></table></code></div></div><p>Unity’s BRDF functions return an RGBA color, with the alpha component always set to 1. So we can directly have our fragment program return its result.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>~//				float3 diffuse =~
~//					albedo \* lightColor \* DotClamped(lightDir, i.normal);~

~//				float3 halfVector = normalize(lightDir + viewDir);~
~//				float3 specular = specularTint \* lightColor \* pow(~
~//					DotClamped(halfVector, i.normal),~
~//					\_Smoothness \* 100~
~//				);~

				return UNITY\_BRDF\_PBS();
</pre></table></code></div></div><p>Of course we have to invoke it with arguments. The functions each have eight parameters. The first two are the diffuse and specular colors of the material. We already have those.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>				return UNITY\_BRDF\_PBS(
					albedo, specularTint
				);
</pre></table></code></div></div><p>The next two arguments have to be the reflectivity and the roughness. These parameters must be in one-minus form, which is an optimization. We already got <code class="language-plaintext highlighter-rouge">oneMinusReflectivity</code> out of <code class="language-plaintext highlighter-rouge">DiffuseAndSpecularFromMetallic</code>. And smoothness is the opposite of roughness, so we can directly use that.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>				return UNITY\_BRDF\_PBS(
					albedo, specularTint,
					oneMinusReflectivity, \_Smoothness
				);
</pre></table></code></div></div><p>Of course the surface normal and view direction are also required. These become the fifth and sixth arguments.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>				return UNITY\_BRDF\_PBS(
					albedo, specularTint,
					oneMinusReflectivity, \_Smoothness,
					i.normal, viewDir
				);
</pre></table></code></div></div><p>The last two arguments must be the direct and indirect light.</p><h3 id="light-structures"><span class="mr-2">Light Structures</span><a href="#light-structures" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><em>UnityLightingCommon</em> defines a simple <code class="language-plaintext highlighter-rouge">UnityLight</code> structure which Unity shaders use to pass light data around. It contains a light’s color, its direction, and an <code class="language-plaintext highlighter-rouge">ndotl</code> value, which is the diffuse term. Remember, these structures are purely for our convenience. It doesn’t affect the compiled code.</p><p>We have all this information, so all we have to do is put it in a light structure and pass it as the seventh argument.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre>				UnityLight light;
				light.color = lightColor;
				light.dir = lightDir;
				light.ndotl = DotClamped(i.normal, lightDir);
				
				return UNITY\_BRDF\_PBS(
					albedo, specularTint,
					oneMinusReflectivity, \_Smoothness,
					i.normal, viewDir,
					light
				);
</pre></table></code></div></div><h3 id="why-does-the-light-data-include-the-diffuse-term"><span class="mr-2">Why does the light data include the diffuse term?</span><a href="#why-does-the-light-data-include-the-diffuse-term" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>As the BRDF functions have all they need to calculate it themselves, why do we have to provide it? This is the case because the light structure is used in other contexts as well.</p><p>Actually, the GGX BRDF version doesn’t even use ndotl. It computes it on its own, as its fiddles with the normal. As always, the shader compilers will get rid of all unused code. So you don’t have to worry about it.</p><p>The final argument is for the indirect light. We have to use the <code class="language-plaintext highlighter-rouge">UnityIndirect</code> structure for that, which is also defined in <em>UnityLightingCommon</em>. It contains two colors, a diffuse and a specular one. The diffuse color represents the ambient light, while the specular color represents environmental reflections.</p><p>We’ll cover indirect light later, so simply set these colors to black for now.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre>			float4 MyFragmentProgram (Interpolators i) : SV\_TARGET {
				i.normal = normalize(i.normal);
				float3 lightDir = \_WorldSpaceLightPos0.xyz;
				float3 viewDir = normalize(\_WorldSpaceCameraPos - i.worldPos);

				float3 lightColor = \_LightColor0.rgb;
				float3 albedo = tex2D(\_MainTex, i.uv).rgb \* \_Tint.rgb;

				float3 specularTint;
				float oneMinusReflectivity;
				albedo = DiffuseAndSpecularFromMetallic(
					albedo, \_Metallic, specularTint, oneMinusReflectivity
				);
				
				UnityLight light;
				light.color = lightColor;
				light.dir = lightDir;
				light.ndotl = DotClamped(i.normal, lightDir);
				UnityIndirect indirectLight;
				indirectLight.diffuse = 0;
				indirectLight.specular = 0;

				return UNITY\_BRDF\_PBS(
					albedo, specularTint,
					oneMinusReflectivity, \_Smoothness,
					i.normal, viewDir,
					light, indirectLight
				);
			}
</pre></table></code></div></div><p><img data-src="https://catlikecoding.com/physically-based-shading/nonmetal-gamma.png" alt="nonmetal gamma" data-proofer-ignore> <img data-src="https://catlikecoding.com/physically-based-shading/nonmetal-linear.png" alt="nonmetal linear" data-proofer-ignore> <img data-src="https://catlikecoding.com/physically-based-shading/metal-gamma.png" alt="metal gamma" data-proofer-ignore> <img data-src="https://catlikecoding.com/physically-based-shading/metal-linear.png" alt="metal linear" data-proofer-ignore></p><p>Nonmetal and metal, in gamma and linear space.</p><p>The next tutorial is <a href="https://catlikecoding.com/unity/tutorials/rendering/part-5/">Multiple Lights</a>.</p><p><a href="https://catlikecoding.com/physically-based-shading/physically-based-shading.unitypackage">unitypackage</a> <a href="https://catlikecoding.com/Rendering-4.pdf">PDF</a></p><p>本文转自 <a href="https://catlikecoding.com/unity/tutorials/rendering/part-4/">https://catlikecoding.com/unity/tutorials/rendering/part-4/</a>，如有侵权，请联系删除。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E7%BF%BB%E8%AF%91/'>翻译</a>, <a href='/categories/shader/'>Shader</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/unity3d/" class="post-tag no-text-decoration" >Unity3D</a> <a href="/tags/shader/" class="post-tag no-text-decoration" >Shader</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Unity%E5%85%89%E7%85%A7%E7%AC%AC%E4%B8%80%E8%AE%B2%28%E7%BF%BB%E8%AF%91%E5%9B%9B%29+-+afeng&url=https%3A%2F%2Fwww.damonc.top%2Fposts%2FUnity-First-light%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Unity%E5%85%89%E7%85%A7%E7%AC%AC%E4%B8%80%E8%AE%B2%28%E7%BF%BB%E8%AF%91%E5%9B%9B%29+-+afeng&u=https%3A%2F%2Fwww.damonc.top%2Fposts%2FUnity-First-light%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fwww.damonc.top%2Fposts%2FUnity-First-light%2F&text=Unity%E5%85%89%E7%85%A7%E7%AC%AC%E4%B8%80%E8%AE%B2%28%E7%BF%BB%E8%AF%91%E5%9B%9B%29+-+afeng" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="http://service.weibo.com/share/share.php?title=Unity%E5%85%89%E7%85%A7%E7%AC%AC%E4%B8%80%E8%AE%B2%28%E7%BF%BB%E8%AF%91%E5%9B%9B%29+-+afeng&url=https%3A%2F%2Fwww.damonc.top%2Fposts%2FUnity-First-light%2F" data-toggle="tooltip" data-placement="top" title="Weibo" target="_blank" rel="noopener" aria-label="Weibo"> <i class="fa-fw fab fa-weibo"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div><script type="text/javascript"> function DelayLoadGiscus() { const origin = "https://giscus.app"; const iframe = "iframe.giscus-frame"; const lightTheme = "light"; const darkTheme = "dark_dimmed"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } let giscusAttributes = { "src": "https://giscus.app/client.js", "data-repo": "damonc-top/damonc-top.github.io", "data-repo-id": "R_kgDOHK_iGQ", "data-category": "General", "data-category-id": "DIC_kwDOHK_iGc4COonD", "data-mapping": "pathname", "data-strict": "0", "data-reactions-enabled": "1", "data-emit-metadata": "0", "data-loading":"lazy", "data-theme": initTheme, "data-input-position": "top", "data-lang": "zh-CN", "crossorigin": "anonymous", "async": "" }; let giscusScript = document.createElement("script"); giscusScript.async = true; Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value)); document.getElementById("tail-wrapper").appendChild(giscusScript); addEventListener("message", (event) => { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; const theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); const message = { setConfig: { theme: theme } }; const giscus = document.querySelector(iframe).contentWindow; giscus.postMessage({ giscus: message }, origin); } }); } setTimeout(() => { DelayLoadGiscus() }, 10000); </script></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Unity-Matrix&Transform/">Unity Transform&Matrix(翻译一)</a><li><a href="/posts/Unity-Shader-Fundamentals/">Unity Shader Fundamentals(翻译二)</a><li><a href="/posts/Unity-Combine-Texture/">Unity 多纹理融合(翻译三)</a><li><a href="/posts/markdown-cheat-sheet/">Markdown语法集合速查表</a><li><a href="/posts/CG-function-library/">CG函数标准库</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/shader/">Shader</a> <a class="post-tag" href="/tags/unity3d/">Unity3D</a> <a class="post-tag" href="/tags/cg/">CG</a> <a class="post-tag" href="/tags/markdown/">Markdown</a></div></div></div><center> <span> <font size="0.5px" color="#dd0000">音乐会被广告插件拦截</font> </span> </center> <meting-js server='netease' type='song' id='1949917421' autoplay="true" list-max-height="340px" width="100%" preload="auto" volume="0.3" order="random" mini="false" mutex="true" list-folded="true"> </meting-js> <script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 mb-5"><div class="panel-heading pl-1 pt-2 mb-2">文章内容</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Unity-Matrix&Transform/"><div class="card-body"> <em class="timeago small" data-ts="1514768400" > 2018-01-01 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Unity Transform&Matrix(翻译一)</h3><div class="text-muted small"><p> 本篇摘要信息 matrix介绍 matrix推导 模拟transform缩放 旋转 位移功能 可视空间 Unity Shader是怎么知道一个像素该画在哪个位置？下面是先展示一组Cube，一步步分析下去 cube数组. 操控一组3维坐标 创建一组10*10*10的3维Cube数组，并作为UnityMatrices对象的成员变量，接下来显示这...</p></div></div></a></div><div class="card"> <a href="/posts/Unity-Shader-Fundamentals/"><div class="card-body"> <em class="timeago small" data-ts="1514880000" > 2018-01-02 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Unity Shader Fundamentals(翻译二)</h3><div class="text-muted small"><p> 本篇摘要信息 顶点变换 Color pixels shader 属性 从顶点传数据至片元函数 查看编译后的shader代码 场景初始化 新建一个默认场景，新建一个圆球。这个默认场景本身进行了大量复杂的渲染，为了更容易的掌握Unity的渲染过程，我们先做一些简化设置，把默认的某些花里胡哨的东西先剥离掉。 剥离天空盒 打开Window-Lighting，查看光照...</p></div></div></a></div><div class="card"> <a href="/posts/Unity-Combine-Texture/"><div class="card-body"> <em class="timeago small" data-ts="1514894400" > 2018-01-02 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Unity 多纹理融合(翻译三)</h3><div class="text-muted small"><p> 本篇摘要： 采样多个纹理 应用细节纹理 处理线性空间中的颜色 使用 splat 地图 纹理合并 融合多张纹理. 贴图在游戏应用广泛，但它们有局限性。无论以何种尺寸显示，它们都有固定数量的像素。如果需要被渲染到很小网格，可以使用mipmap来保持它们的部分细节。但是当渲染到很大的网格上，会变得模糊。我们也不能无中生有地渲染更多额外的细节。本文...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Unity-Combine-Texture/" class="btn btn-outline-primary" prompt="上一篇"><p>Unity 多纹理融合(翻译三)</p></a> <span class="btn btn-outline-primary disabled" prompt="下一篇"><p>-</p></span></div><div></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> <span>©2016-2022-</span> <span><a href="https://www.damonc.top">阿锋 -</a></span> <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。"> 云上的日子 </span></p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/shader/">Shader</a> <a class="post-tag" href="/tags/unity3d/">Unity3D</a> <a class="post-tag" href="/tags/cg/">CG</a> <a class="post-tag" href="/tags/markdown/">Markdown</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script>
