<!DOCTYPE html><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="baidu-site-verification" content="code-BGVivWGmxV" /><title>Unity 混合光照(翻译十七)</title><meta name="description" content="本篇摘要： 只烘焙间接光 混合烘焙阴影和实时阴影 处理代码的变化和问题 支持消减光照（subtractivelighting）"><link rel="shortcut icon" href="/favicon.ico?" type="image/x-icon"><link rel="icon" href="/favicon.ico?" type="image/x-icon"><link rel="stylesheet" href="/css/main.css "><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href=" /css/font_8v3czwksspqlg14i.css "><link rel="canonical" href="https://www.damonc.top/2018/01/21/Unity_Mix_Lighting/"><link rel="alternate" type="application/rss+xml" title="爱穿拖鞋" href="https://www.damonc.top/feed.xml "> <script type="text/javascript" src=" /js/jquery_3_2_0.min.js " charset="utf-8"></script> <script type="text/javascript" src=" /js/Valine.min.js " charset="utf-8"></script> <script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "//hm.baidu.com/hm.js?8c087101d4768b7aa439cef954b30a8f"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script> <script> (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0], j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src= 'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f); })(window,document,'script','dataLayer','GTM-WN45VXRK'); </script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <scrip type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/js-polyfills/0.1.43/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><body class="custom-background"> <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WN45VXRK" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><header id="top"><div class="wrapper"> <a href="/" class="brand">爱穿拖鞋</a> <small>自由自在🩴</small> <button id="headerMenu" class="menu"><i class="fa fa-bars"></i></button><nav id="headerNav"><ul><li> <a href="/"> <i class="fa fa-home"></i>Home </a><li> <a href="/archive/"> <i class="fa fa-archive"></i>归档 </a><li> <a href="/category/"> <i class="fa fa-th-list"></i>分类 </a><li> <a href="/tag/"> <i class="fa fa-tags"></i>标签 </a><li> <a href="/collection/"> <i class="fa fa-bookmark"></i>收集 </a><li> <a href="/demo/"> <i class="fa fa-play"></i>工具 </a><li> <a href="/about/"> <i class="fa fa-heart"></i>About </a></ul></nav></div></header><div class="home-right-bar"> <button class="anchor"><i class="fa fa-anchor"></i></button><div class="right"><div class="wrap"><div class="side content"><div> 目录</div><ul id="content-side" class="content-ul"><li><a href="#comments">Comments</a></ul></div></div></div></div><div class="page clearfix" post><div class="left"><h1>Unity 混合光照(翻译十七)</h1><div class="label"><div class="label-card"> <i class="fa fa-calendar"></i>2018-01-21</div><div class="label-card"> <i class="fa fa-user"></i>catlikecoding</div><div class="label-card"></div><div class="label-card"> <span class="categories"> <i class="fa fa-th-list"></i> <a href="/category/#翻译" title="Category: 翻译" rel="category">翻译</a> </span></div><div class="label-card"> <span class="pageTag"> <i class="fa fa-tags"></i> <b href="/tag/#Shader" title="Tag: Shader" rel="tag">Shader</b>&nbsp; <b href="/tag/#Unity3d" title="Tag: Unity3d" rel="tag">Unity3d</b> </span></div></div><hr><article itemscope itemtype="http://schema.org/BlogPosting"><ul id="markdown-toc"><li><a href="#烘焙间接光" id="markdown-toc-烘焙间接光">烘焙间接光</a><ul><li><a href="#混合模式" id="markdown-toc-混合模式">混合模式</a><li><a href="#更新着色器" id="markdown-toc-更新着色器">更新着色器</a><li><a href="#手动衰减阴影" id="markdown-toc-手动衰减阴影">手动衰减阴影</a></ul><li><a href="#使用阴影蒙版shadowmask" id="markdown-toc-使用阴影蒙版shadowmask">使用阴影蒙版（Shadowmask）</a><ul><li><a href="#对阴影蒙版采样-sampling-the-shadowmask" id="markdown-toc-对阴影蒙版采样-sampling-the-shadowmask">对阴影蒙版采样-Sampling the Shadowmask**</a><li><a href="#添加一个阴影蒙版g-buffer" id="markdown-toc-添加一个阴影蒙版g-buffer">添加一个阴影蒙版G-Buffer</a><li><a href="#使用阴影蒙版g-缓存" id="markdown-toc-使用阴影蒙版g-缓存">使用阴影蒙版G-缓存</a><li><a href="#阴影蒙版-距离模式-distance-shadowmask" id="markdown-toc-阴影蒙版-距离模式-distance-shadowmask">阴影蒙版-距离模式 DIstance Shadowmask</a><li><a href="#多重光照" id="markdown-toc-多重光照">多重光照</a><li><a href="#支持多个有蒙版的定向光" id="markdown-toc-支持多个有蒙版的定向光">支持多个有蒙版的定向光</a></ul><li><a href="#消减阴影-subtractive-shadows" id="markdown-toc-消减阴影-subtractive-shadows">消减阴影-Subtractive Shadows</a><ul><li><a href="#消减光照" id="markdown-toc-消减光照">消减光照</a><li><a href="#为烘焙光打阴影" id="markdown-toc-为烘焙光打阴影">为烘焙光打阴影</a></ul></ul><p>本篇摘要：</p><ul><li>只烘焙间接光<li>混合烘焙阴影和实时阴影<li>处理代码的变化和问题<li>支持消减光照（subtractivelighting）</ul><h2 id="烘焙间接光">烘焙间接光</h2><p>光照贴图可以提供预计算光照：以纹理内存为代价减少了GPU在实时中的工作量；还加入了间接光。</p><p><strong>限制</strong>：<strong>首先</strong>，高光不能被烘焙；<strong>其次</strong>，烘焙光只通过光照探头影响动态物体；<strong>最后</strong>，烘焙光不产生实时阴影。</p><p>你可以在下面的截图中看到完全实时光照和完全烘焙光照之间的区别。<a href="https://www.damonc.top/2018/01/19/Unity_Static_Lightting/">前一篇</a>教程中的一个场景，唯一的不同是我将所有的球体都设置为动态并重新改变了一些球体的位置。其它一切都是静态的。这是使用前向渲染的方法。</p><center class="half"><img class="fit-picture" loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002309942-1932595350.png" width="250" alt="loading failed, need vpn." /> <img class="fit-picture" loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002311276-1707091650.png" width="250" alt="loading failed, need vpn." /></center> <font size="2.5"> <center><i><a>完全实时和完全烘焙光照.</a></i></center> </font><h3 id="混合模式">混合模式</h3><p>烘焙光照有间接光而没有实时光照，因为间接光需要光照贴图。由于间接光可以为场景加入很大的真实感，如果我们可以将它和实时光照融合在一起就再好不过了。这是可以的，但也意味着着色的开销会增加。我们需要将混合光（Mixed Lighting）的光照模式（Lighting Mode）设置为烘焙间接（Baked Indirect）。</p><center class="half"><img class="fit-picture" loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002312394-324532807.png" width="250" alt="loading failed, need vpn." /></center> <font size="2.5"> <center><i><a>混合光照，烘焙间接.</a></i></center> </font><p>我们已经在<a href="https://www.damonc.top/2018/01/19/Unity_Static_Lightting/">前一篇</a>教程中切换到这个模式了，但是之前我们只使用了完全烘焙光照。虽然表现结果与完全烘焙光照相同，混合光照模式没有任何区别。为了使用混合光照，光源的模式必须要设置为混合。</p><center class="half"><img class="fit-picture" loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002313374-471117722.png" width="250" alt="loading failed, need vpn." /></center> <font size="2.5"> <center><i><a>混合模式的主光源.</a></i></center> </font><p>在将主定向光改为混合光后，两件事会发生：</p><p><strong>首先</strong>，Unity会再次烘焙光照贴图。这一次光照贴图只会存储间接光，所以它会比之前的暗很多。</p><center class="half"><img class="fit-picture" loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002314496-2053721233.png" width="250" alt="loading failed, need vpn." /> <img class="fit-picture" loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002315595-1655913714.png" width="250" alt="loading failed, need vpn." /></center> <font size="2.5"> <center><i><a>完全烘焙的光照贴图 vs 只有间接光的光照贴图.</a></i></center> </font><p><strong>另外</strong>，所有物体都会像主光源被设置为实时那样被照亮。只有一点不同：光照贴图被用来为静态物体添加间接光，而不是球谐光或探头。动态物体的间接光仍要使用光照探头。</p><center class="half"><img class="fit-picture" loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002316908-68636833.png" width="250" alt="loading failed, need vpn." /></center> <font size="2.5"> <center><i><a>混合光照，实时直接光照烘焙间接光.</a></i></center> </font><p>我们不需要改变我们的着色器来支持这点，因为前向基础通道（forward base pass）已经融合了光照贴图数据和主定向光源。和往常一样，额外的光照会得到附加通道（additive pass）。当使用延迟渲染通道时，主光源也会得到一个通道。</p><p><strong>混合光可以在运行时调整吗？</strong><br /> 是的，因为它们被用于实时光照。但是，它们的烘焙数据时静态的。所以在运行时你只能稍微调整光照，比如稍微调整它的强度。更大的变化会使人明显看出烘焙光照和实时光照之间的不同步。_</p><h3 id="更新着色器">更新着色器</h3><p>刚开始一切似乎正常运行。但是，定向光的阴影衰减发生了错误。我们通过极大降低阴影距离观察到阴影被剪掉了。</p><center class="half"><img class="fit-picture" loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002318408-928334072.png" width="250" alt="loading failed, need vpn." /> <img class="fit-picture" loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002319957-145579115.png" width="250" alt="loading failed, need vpn." /></center> <font size="2.5"> <center><i><a>阴影衰减，标准着色器vs我们的着色器.</a></i></center> </font><p>虽然Unity很长一段时间都有混合光照模式，但实际上它在Unity5中就不起作用了。Unity5.6中新加入了一个混合光照模式，即我们现在使用的这个。当该新模式被加入时，_UNITY_LIGHT_ATTENUATION_宏下面的代码发生了变化。我们在使用完全烘焙光照或者实时光照时没有注意到这一点，但是我们必须更新我们的代码以适应混合光照的新方法。由于这是最近的一个巨大的变化，我们必须要注意它所带来的问题。</p><p>我们要改变的第一点是不再使用_SHADOW_COORDS_宏来定义阴影坐标的插值（interpolater）。我们必须使用新的_UNITY_SHADOW_COORDS_宏来代替它。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Interpolators</span>
<span class="p">{</span>
    <span class="c1">//SHADOW_COORDS(5)</span>
    <span class="n">UNITY_SHADOW_COORDS</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="err">｝</span><span class="p">;</span>

</code></pre></div></div><p>同样，<em>TRANSFER_SHADOW_应该替换为_UNITY_TRANSFER_SHADOW</em></p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Interpolators</span> <span class="nf">MyVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//TRANSFER_SHADOW(i);</span>
    <span class="n">UNITY_TRANSFER_SHADOW</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>   
<span class="err">｝</span>

</code></pre></div></div><p>然而，这会产生一个编译错误，因为该宏需要一个额外的参数。从Unity 5.6开始，只有定向阴影的屏幕空间坐标中被放入一个插值。点光源和聚光源的阴影坐标现在在片段程序（fragment program）中进行计算。有个新变化：在一些情况中光照贴图的坐标被用在阴影蒙版（shadow mask）中，我们会在后面讲解这一点。为了该宏能正常工作，我们必须为它提供第二个UV通道中的数据，其中包含光照贴图的坐标。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UNITY_TRANSFER_SHADOW</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">uv1</span><span class="p">);</span>

</code></pre></div></div><p>这样会再次产生一个编译错误。这是因为在一些情况下_UNITY_SHADOW_COORDS_错误地创建了一个插值，尽管实际上并不需要。在这种情况下，_TRANSFER_SHADOW_不会初始化它，因而导致错误。这个问题出现在5.6.0中，一直到5.6.2和2017.1.0beta版本中都有。</p><p>人们通常不会注意到这个问题，因为Unity的标准着色器使用_UNITY_INITIALIZE_OUTPUT_宏来完全地初始化它的插值结构体。因为我们不使用这个宏，所以出现了问题。为了解决它，我们使用_UNITY_INITIALIZE_OUTPUT_宏来初始化我们的插值。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Interpolators</span> <span class="nf">MyVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Interpolators</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">UNITY_INITIALIZE_OUTPUT</span><span class="p">(</span><span class="n">Interpolators</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>  
<span class="err">｝</span>
</code></pre></div></div><p>_UNITY_INITIALIZE_OUTPUT_有什么作用？</p><p>它只是为变量分配数值0，将其转换为正确的类型。至少是当程序支持该宏时会这样，否则它不会做任何事。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Initialize arbitrary structure with zero values.</span>
<span class="c1">// Not supported on some backends</span>
<span class="c1">// (e.g. Cg-based particularly with nested structs).</span>
<span class="c1">// hlsl2glsl would almost support it, except with structs that have</span>
<span class="n">arrays</span>
<span class="c1">// -- so treat as not supported there either :(</span>
<span class="cp">#if defined(UNITY_COMPILER_HLSL) || defined(SHADER_API_PSSL) || \\
</span><span class="n">defined</span><span class="p">(</span><span class="n">UNITY_COMPILER_HLSLCC</span><span class="p">)</span>
    <span class="cp">#define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;
#else
</span>    <span class="cp">#define UNITY_INITIALIZE_OUTPUT(type,name)
#endif
</span></code></pre></div></div><p><strong>通常我们倾向于只使用显式赋值，很少使用这个初始化插值宏。</strong></p><h3 id="手动衰减阴影">手动衰减阴影</h3><p>现在我们正确地使用了新的宏定义，但是主光源的阴影仍然没有按照它们应该的那样衰减。结果我们发现当同时使用定向阴影和光照贴图时，<em>UNITY_LIGHT_ATTENUATION</em> 不会对光源进行衰减。使用混合模式的主定向光源就会产生这个问题。所以我们必须手动设置。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>为什么在这个例子中阴影没有衰减？

1、UNITY_LIGHT_ATTENUATION宏之前是独立使用的，但是自从Unity5. 6它开始和Unity的标准全局光照函数一同使用。我们没有采用同样的方法，因此它不能正常工作。  
2、至于为什么要做这个改动，唯一的线索就是AutoLight中的一段注释：“为了性能的原因以GI函数的深度处理阴影”。由于着色器编译器会随意地移动代码。
</code></pre></div></div><p>对于我们的延迟光照着色器，我们已经有了进行阴影衰减的代码。将相关代码片段从MyDeferredShading中复制到My Lighting中的一个新函数中。唯一实际的区别在于我们必须使用视图向量和视图矩阵构建viewZ。我们只需要Z分量，所以无需进行一次完整的矩阵乘法。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="nf">FadeShadows</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">,</span> <span class="n">float</span> <span class="n">attenuation</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float</span> <span class="n">viewZ</span> <span class="o">=</span> <span class="nb">dot</span><span class="p">(</span><span class="n">_WorldSpaceCameraPos</span> <span class="o">-</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">,</span> <span class="n">UNITY_MATRIX_V</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">xyz</span><span class="p">);</span>
    <span class="n">float</span> <span class="n">shadowFadeDistance</span> <span class="o">=</span> <span class="n">UnityComputeShadowFadeDistance</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">,</span> <span class="n">viewZ</span><span class="p">);</span>
    <span class="n">float</span> <span class="n">shadowFade</span> <span class="o">=</span> <span class="n">UnityComputeShadowFade</span><span class="p">(</span><span class="n">shadowFadeDistance</span><span class="p">);</span>
    <span class="n">attenuation</span> <span class="o">=</span> <span class="nb">saturate</span><span class="p">(</span><span class="n">attenuation</span> <span class="o">+</span> <span class="n">shadowFade</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">attenuation</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><p>该手动衰减必须在使用了_UNITY_LIGHT_ATTENUATION初始化完成_之后。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UnityLight</span> <span class="nf">CreateLight</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    
    <span class="n">UNITY_LIGHT_ATTENUATION</span><span class="p">(</span><span class="n">attenuation</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
    <span class="n">attenuation</span> <span class="o">=</span> <span class="n">FadeShadows</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">attenuation</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><p>只有当 <em>HANDLE_SHADOW_BLENDING_IN_GI</em> 在UnityShadowLibrary.cginc文件中有定义时，FadeShadows才会开始计算。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="nf">FadeShadows</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">,</span> <span class="n">float</span> <span class="n">attenuation</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if HANDLE_SHADOWS_BLENDING_IN_GI
</span>        <span class="c1">// UNITY_LIGHT_ATTENUATION doesn't fade shadows for us.</span>
        <span class="n">float</span> <span class="n">viewZ</span> <span class="o">=</span> <span class="nb">dot</span><span class="p">(</span><span class="n">_WorldSpaceCameraPos</span> <span class="o">-</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">,</span> <span class="n">UNITY_MATRIX_V</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">xyz</span><span class="p">);</span>
        <span class="n">float</span> <span class="n">shadowFadeDistance</span> <span class="o">=</span> <span class="n">UnityComputeShadowFadeDistance</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">,</span> <span class="n">viewZ</span><span class="p">);</span>
        <span class="n">float</span> <span class="n">shadowFade</span> <span class="o">=</span> <span class="n">UnityComputeShadowFade</span><span class="p">(</span><span class="n">shadowFadeDistance</span><span class="p">);</span>
        <span class="n">attenuation</span> <span class="o">=</span> <span class="nb">saturate</span><span class="p">(</span><span class="n">attenuation</span> <span class="o">+</span> <span class="n">shadowFade</span><span class="p">);</span>
    <span class="cp">#endif
</span>    <span class="k">return</span> <span class="n">attenuation</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><p>最后，我们的阴影如它们应该的那样正常衰减了。</p><h2 id="使用阴影蒙版shadowmask">使用阴影蒙版（Shadowmask）</h2><p>烘焙间接光的混合模式成本很高。它们需要实时光照外加间接光的光照贴图那么大的工作量。它和完全烘焙光照相比最重要的是加入了实时阴影。幸运的是，有一个方法仍可以将阴影烘焙到光照贴图中，将其和实时阴影综合起来。为了开启这个功能，我们将混合光照模式改为Shadowmask。</p><center class="half"><img class="fit-picture" loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002321275-2134383138.png" width="250" alt="loading failed, need vpn." /></center> <font size="2.5"> <center><i><a>Shadowmask模式.</a></i></center> </font><p>在这个模式中，混合光照的间接光和阴影衰减都存储在了光照贴图中。阴影被存储在一张额外的贴图（即阴影蒙版）。当只有主定向光源时，红色的阴影蒙版决定是否过滤被照亮的物体。红色是因为阴影信息被存储在纹理的R通道中。事实上，贴图中至多可以储存四个光照的阴影，因为它只有四个通道。</p><center class="half"><img class="fit-picture" loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002322323-849349388.png" width="250" alt="loading failed, need vpn." /></center> <font size="2.5"> <center><i><a>烘焙的强度以及阴影蒙版.</a></i></center> </font><p>在Unity创建了阴影蒙版后，静态物体的阴影投射会消失。只有光照探头仍会处理它们。动态物体的阴影不受影响。</p><center class="half"><img class="fit-picture" loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002323536-1775535799.png" width="250" alt="loading failed, need vpn." /></center> <font size="2.5"> <center><i><a>没有烘焙阴影.</a></i></center> </font><h3 id="对阴影蒙版采样-sampling-the-shadowmask">对阴影蒙版采样-Sampling the Shadowmask**</h3><p>为了重新得到烘焙阴影，我们必须对阴影蒙版采样样。Unity的宏已经对点光源和聚光源进行了取样，不过我们必须也要将它包含在我们的FadeShadows函数中。为此我们可以使用UnityShadowLibrary中的UnitySampleBakedOcclusions函数。它需要光照贴图的UV坐标和世界位置作为输入参数。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="nf">FadeShadows</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">,</span> <span class="n">float</span> <span class="n">attenuation</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cp">#if HANDLE_SHADOWS_BLENDING_IN_GI
</span>        
        <span class="n">float</span> <span class="n">bakedAttenuation</span> <span class="o">=</span> <span class="n">UnitySampleBakedOcclusion</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">);</span>
        <span class="n">attenuation</span> <span class="o">=</span> <span class="nb">saturate</span><span class="p">(</span><span class="n">attenuation</span> <span class="o">+</span> <span class="n">shadowFade</span><span class="p">);</span>
    <span class="cp">#endif
</span>    <span class="k">return</span> <span class="n">attenuation</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UnitySampleBakedOcclusion是什么样子的？

它使用光照贴图坐标对阴影蒙版取样，然后选择适当的通道。unity_OcclusionMaskSelector变量是一个含有一个分量的向量，该分量被设置为1以匹配当前正在被着色的光源。
</code></pre></div></div><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fixed</span> <span class="nf">UnitySampleBakedOcclusion</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">lightmapUV</span><span class="p">,</span> <span class="kt">float3</span> <span class="n">worldPos</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined (SHADOWS_SHADOWMASK)
</span>        <span class="cp">#if defined(LIGHTMAP_ON)
</span>            <span class="n">fixed4</span> <span class="n">rawOcclusionMask</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_TEX2D_SAMPLER</span><span class="p">(</span>
                <span class="n">unity_ShadowMask</span><span class="p">,</span> <span class="n">unity_Lightmap</span><span class="p">,</span> <span class="n">lightmapUV</span><span class="p">.</span><span class="n">xy</span>
            <span class="p">);</span>
        <span class="cp">#else
</span>            <span class="n">fixed4</span> <span class="n">rawOcclusionMask</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_TEX2D</span><span class="p">(</span><span class="n">unity_ShadowMask</span><span class="p">,</span> <span class="n">lightmapUV</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
        <span class="cp">#endif
</span>        <span class="k">return</span> <span class="nb">saturate</span><span class="p">(</span><span class="nb">dot</span><span class="p">(</span><span class="n">rawOcclusionMask</span><span class="p">,</span> <span class="n">unity_OcclusionMaskSelector</span><span class="p">));</span>
    <span class="cp">#else
</span>        <span class="k">return</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div><p><em>该函数还处理了光照探头代理体积的衰减，但是我们还没有支持这点所以我去掉了那部分的代码。这就是为什么该函数有一个世界位置的参数。</em></p><p>当使用阴影蒙版时，_UnitySampleBakedOcclusions_提供给我们烘焙阴影衰减，在其他情况下它的值都为1。现在我们必须将它和我们已经有的衰减综合起来然后对阴影进行衰减。_UnityMixRealtimeAndBakedShadows_函数为我们实现了这些。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="n">bakedAttenuation</span> <span class="o">=</span> <span class="n">UnitySampleBakedOcclusion</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">);</span>
<span class="c1">//attenuation = saturate(attenuation shadowFade);</span>
<span class="n">attenuation</span> <span class="o">=</span> <span class="n">UnityMixRealtimeAndBakedShadows</span>
<span class="p">(</span>
    <span class="n">attenuation</span><span class="p">,</span> <span class="n">bakedAttenuation</span><span class="p">,</span> <span class="n">shadowFade</span>
<span class="p">);</span>
</code></pre></div></div><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UnityMixRealtimeAndBakedShadows是如何工作的？

它也是UnityShadowLibrary中的一个函数。它还处理光照探头代理体积以及一些其他极端情况。那些情况和我们无关，所以我删除了一些内容。
</code></pre></div></div><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">inline</span> <span class="n">half</span> <span class="nf">UnityMixRealtimeAndBakedShadows</span> <span class="p">(</span>
    <span class="n">half</span> <span class="n">realtimeShadowAttenuation</span><span class="p">,</span> <span class="n">half</span> <span class="n">bakedShadowAttenuation</span><span class="p">,</span> <span class="n">half</span> <span class="n">fade</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if !defined(SHADOWS_DEPTH) &amp;&amp; !defined(SHADOWS_SCREEN) &amp;&amp; \\
</span>        <span class="o">!</span><span class="n">defined</span><span class="p">(</span><span class="n">SHADOWS_CUBE</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bakedShadowAttenuation</span><span class="p">;</span>
    <span class="cp">#endif
</span>
    <span class="cp">#if defined (SHADOWS_SHADOWMASK)
</span>        <span class="cp">#if defined (LIGHTMAP_SHADOW_MIXING)
</span>            <span class="n">realtimeShadowAttenuation</span> <span class="o">=</span> <span class="nb">saturate</span><span class="p">(</span><span class="n">realtimeShadowAttenuation</span> <span class="o">+</span> <span class="n">fade</span><span class="p">);</span>
            <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">realtimeShadowAttenuation</span><span class="p">,</span> <span class="n">bakedShadowAttenuation</span><span class="p">);</span>
        <span class="cp">#else
</span>            <span class="k">return</span> <span class="nb">lerp</span><span class="p">(</span>
                <span class="n">realtimeShadowAttenuation</span><span class="p">,</span> <span class="n">bakedShadowAttenuation</span><span class="p">,</span> <span class="n">fade</span>
            <span class="p">);</span>
        <span class="cp">#endif
</span>    <span class="cp">#else //no shadowmask
</span>        <span class="k">return</span> <span class="nb">saturate</span><span class="p">(</span><span class="n">realtimeShadowAttenuation</span> <span class="o">+</span> <span class="n">fade</span><span class="p">);</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div><p><strong>如果没有动态阴影，那么结果将得到烘焙的衰减。这意味着动态物体没有阴影，以及被映射到光照贴图上的物体没有烘焙阴影。</strong></p><p>当没有使用阴影蒙版时，它会进行原来的衰减。否则，它会根据我们是否做了阴影混合进行表现，我们后面再讲。现在，它只是在实时衰减和烘焙衰减之间进行一个插值。</p><center class="half"><img class="fit-picture" loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002325094-888038969.png" width="250" alt="loading failed, need vpn." /></center> <font size="2.5"> <center><i><a>实时阴影和阴影蒙版阴影.</a></i></center> </font><p>现在静态物体有了实时阴影和烘焙阴影，且它们正确地混合。实时阴影的衰减仍然超过了阴影距离，但是烘焙阴影没有。</p><center class="half"><img class="fit-picture" loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002326606-1972314102.png" width="250" alt="loading failed, need vpn." /></center> <font size="2.5"> <center><i><a>只有实时阴影衰减了.</a></i></center> </font><h3 id="添加一个阴影蒙版g-buffer">添加一个阴影蒙版G-Buffer</h3><p>现在阴影蒙版可用于前向渲染路径，但是我们需要使它也可用于延迟渲染：添加阴影蒙版信息作为一个额外的G-缓存。所以当_SHADOWS_SHADOWMASK_被定义时，在_FragmentOutput_结构体中添加一个缓存。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">FragmentOutput</span> <span class="p">{</span>
    <span class="cp">#if defined(DEFERRED_PASS)
</span>        <span class="kt">float4</span> <span class="n">gBuffer0</span> <span class="o">:</span> <span class="n">SV_Target0</span><span class="p">;</span>
        <span class="kt">float4</span> <span class="n">gBuffer1</span> <span class="o">:</span> <span class="n">SV_Target1</span><span class="p">;</span>
        <span class="kt">float4</span> <span class="n">gBuffer2</span> <span class="o">:</span> <span class="n">SV_Target2</span><span class="p">;</span>
        <span class="kt">float4</span> <span class="n">gBuffer3</span> <span class="o">:</span> <span class="n">SV_Target3</span><span class="p">;</span>

        <span class="cp">#if defined(SHADOWS_SHADOWMASK)
</span>            <span class="kt">float4</span> <span class="n">gBuffer4</span> <span class="o">:</span> <span class="n">SV_Target4</span><span class="p">;</span>
        <span class="cp">#endif
</span>    <span class="cp">#else
</span>        <span class="kt">float4</span> <span class="n">color</span> <span class="o">:</span> <span class="n">SV_Target</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">};</span>
</code></pre></div></div><p>添加的第五个G-缓存，会使显存增大，并不是所有的平台(mobile)都支持它。Unity只在有足够多的渲染目标可用时才支持阴影蒙版，因此我们也应该这样做。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if defined(SHADOWS_SHADOWMASK) &amp;&amp; (UNITY_ALLOWED_MRT_COUNT &gt; 4)
</span>    <span class="kt">float4</span> <span class="n">gBuffer4</span> <span class="o">:</span> <span class="n">SV_Target4</span><span class="p">;</span>
<span class="cp">#endif
</span>
</code></pre></div></div><p>我们只需在G-缓存中存储采样得到的阴影蒙版数据，而且没有一个确切的光照，为此我们可以使用_UnityGetRawBakedOcclusions_函数，它与_UnitySampleBakedOcclusion_相似，唯一不同在于它没有选择某个纹理通道。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">FragmentOutput</span> <span class="n">output</span><span class="p">;</span>
<span class="cp">#if defined(DEFERRED_PASS)
</span>    <span class="cp">#if !defined(UNITY_HDR_ON)
</span>        <span class="n">color</span><span class="p">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="nb">exp2</span><span class="p">(</span><span class="o">-</span><span class="n">color</span><span class="p">.</span><span class="n">rgb</span><span class="p">);</span>
    <span class="cp">#endif
</span>    <span class="n">output</span><span class="p">.</span><span class="n">gBuffer0</span><span class="p">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="n">albedo</span><span class="p">;</span>
    <span class="n">output</span><span class="p">.</span><span class="n">gBuffer0</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">GetOcclusion</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="n">output</span><span class="p">.</span><span class="n">gBuffer1</span><span class="p">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="n">specularTint</span><span class="p">;</span>
    <span class="n">output</span><span class="p">.</span><span class="n">gBuffer1</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">GetSmoothness</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="n">output</span><span class="p">.</span><span class="n">gBuffer2</span> <span class="o">=</span> <span class="kt">float4</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normal</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">output</span><span class="p">.</span><span class="n">gBuffer3</span> <span class="o">=</span> <span class="n">color</span><span class="p">;</span>
    <span class="cp">#if defined(SHADOWS_SHADOWMASK) &amp;&amp; (UNITY_ALLOWED_MRT_COUNT &gt; 4)
</span>        <span class="n">output</span><span class="p">.</span><span class="n">gBuffer4</span> <span class="o">=</span> <span class="n">UnityGetRawBakedOcclusions</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
    <span class="cp">#endif
#else
</span>    <span class="n">output</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">ApplyFog</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="cp">#endif
</span></code></pre></div></div><p>为了可以在没有光照贴图的时候也能成功编译，当光照贴图坐标不可用时我们使用0代替它。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if defined(SHADOWS_SHADOWMASK) &amp;&amp; (UNITY_ALLOWED_MRT_COUNT &gt; 4)
</span>    <span class="kt">float2</span> <span class="n">shadowUV</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="cp">#if defined(LIGHTMAP_ON)
</span>        <span class="n">shadowUV</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span><span class="p">;</span>
    <span class="cp">#endif
</span>    <span class="n">output</span><span class="p">.</span><span class="n">gBuffer4</span> <span class="o">=</span> <span class="n">UnityGetRawBakedOcclusions</span><span class="p">(</span><span class="n">shadowUV</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
<span class="cp">#endif
</span>
</code></pre></div></div><h3 id="使用阴影蒙版g-缓存">使用阴影蒙版G-缓存</h3><p>调整MyDeferredShading延迟渲染着色器。</p><p>第一步先添加额外的一个G-buffer变量。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sampler2D</span> <span class="n">_CameraGBufferTexture0</span><span class="p">;</span>
<span class="n">sampler2D</span> <span class="n">_CameraGBufferTexture1</span><span class="p">;</span>
<span class="n">sampler2D</span> <span class="n">_CameraGBufferTexture2</span><span class="p">;</span>
<span class="n">sampler2D</span> <span class="n">_CameraGBufferTexture4</span><span class="p">;</span>
</code></pre></div></div><p>第二步，创建一个函数来得到适当的阴影衰减。如果有了阴影蒙版，可通过对纹理采样然后和_unity_OcclusionMaskSelector_进行一次颜色饱和点乘。这个变量是在_UnityShaderVariables.cginc_中定义的，包含了一个用于选择当前正在被渲染的光照通道的向量。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="nf">GetShadowMaskAttenuation</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">float</span> <span class="n">attenuation</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="cp">#if defined (SHADOWS_SHADOWMASK)
</span>        <span class="kt">float4</span> <span class="n">mask</span> <span class="o">=</span> <span class="nb">tex2D</span><span class="p">(</span><span class="n">_CameraGBufferTexture4</span><span class="p">,</span> <span class="n">uv</span><span class="p">);</span>
        <span class="n">attenuation</span> <span class="o">=</span> <span class="nb">saturate</span><span class="p">(</span><span class="nb">dot</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">unity_OcclusionMaskSelector</span><span class="p">));</span>
    <span class="cp">#endif
</span>    <span class="k">return</span> <span class="n">attenuation</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><p>在CreateLight中，即使当前光照没有实时阴影，我们在有阴影蒙版时也要衰减阴影。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UnityLight</span> <span class="nf">CreateLight</span> <span class="p">(</span><span class="kt">float2</span> <span class="n">uv</span><span class="p">,</span> <span class="kt">float3</span> <span class="n">worldPos</span><span class="p">,</span> <span class="n">float</span> <span class="n">viewZ</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(SHADOWS_SHADOWMASK)
</span>        <span class="n">shadowed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="cp">#endif
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">shadowed</span><span class="p">)</span> 
    <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>为了正确地包含烘焙阴影，再次使用UnityMixRealtimeAndBakedShadows代替之前的衰减计算。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">shadowed</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="n">float</span> <span class="n">shadowFadeDistance</span> <span class="o">=</span> <span class="n">UnityComputeShadowFadeDistance</span><span class="p">(</span><span class="n">worldPos</span><span class="p">,</span> <span class="n">viewZ</span><span class="p">);</span>
    <span class="n">float</span> <span class="n">shadowFade</span> <span class="o">=</span> <span class="n">UnityComputeShadowFade</span><span class="p">(</span><span class="n">shadowFadeDistance</span><span class="p">);</span>
<span class="c1">//  shadowAttenuation = saturate(shadowAttenuation + shadowFade);</span>
    <span class="n">shadowAttenuation</span> <span class="o">=</span> <span class="n">UnityMixRealtimeAndBakedShadows</span><span class="p">(</span>
        <span class="n">shadowAttenuation</span><span class="p">,</span> <span class="n">GetShadowMaskAttenuation</span><span class="p">(</span><span class="n">uv</span><span class="p">),</span> <span class="n">shadowFade</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><p>现在也可以使用自定义的延迟光照着色器得到正确的烘焙阴影了。例外，即当我们的优化分支被使用时会跳过阴影混合。该捷径在阴影蒙版被使用时不可用。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">shadowed</span><span class="p">)</span> <span class="p">{</span>
    
    <span class="cp">#if defined(UNITY_FAST_COHERENT_DYNAMIC_BRANCHING) &amp;&amp; defined(SHADOWS_SOFT)
</span>        <span class="cp">#if !defined(SHADOWS_SHADOWMASK)
</span>            <span class="n">UNITY_BRANCH</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">shadowFade</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">.</span><span class="mi">99</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">shadowAttenuation</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="cp">#endif
</span>    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div><h3 id="阴影蒙版-距离模式-distance-shadowmask">阴影蒙版-距离模式 DIstance Shadowmask</h3><p>虽然使用阴影蒙版模式我们可以得到不错的静态物体的烘焙阴影，动态物体却不能从中获利。动态物体只能接收到实时阴影以及光照探头数据。如果我们希望得到动态物体的阴影，那么静态物体必须也要投射实时阴影。这里的混合光照模式我们要用到距离阴影蒙版（Distance Shadowmask）了。</p><center class="half"><img class="fit-picture" loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002327719-433885054.png" width="250" alt="loading failed, need vpn." /></center> <font size="2.5"> <center><i><a>距离阴影蒙版模式.</a></i></center> </font><p><em>在2017及以上，使用哪个阴影蒙版模式是通过质量设置进行控制。</em></p><p>当使用DistanceShadowmask模式时，所有物体都使用实时阴影。第一眼看去，好像和Baked Indirect模式完全一样。</p><center class="half"><img class="fit-picture" loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002329008-1483902900.png" width="250" alt="loading failed, need vpn." /></center> <font size="2.5"> <center><i><a>所有物体都有实时阴影.</a></i></center> </font><p>不过这里仍有一个阴影蒙版。在这个模式中，烘焙阴影和光照探头的使用超出了阴影距离。因此该模式是成本最高的模式，在阴影距离范围内等价于烘焙间接模式，超出该范围则等价于阴影蒙版模式。</p><p>前面已经支持这个模式了，因为我们正在使用UnityMixRealtimeAndBakedShadows。为了正确地混合完全实时阴影和烘焙阴影，它像往常那样衰减实时阴影，然后取其和烘焙阴影的最小值。</p><h3 id="多重光照">多重光照</h3><p>因为阴影蒙版有四个通道，它可以最多同时支持4个光照体积重叠在一起</p><center class="half"><img class="fit-picture" loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002330331-1413395037.png" width="250" alt="loading failed, need vpn." /></center> <font size="2.5"> <center><i><a>四个光源，都是混合光.</a></i></center> </font><p><strong>主方向光源的阴影仍存储在R通道中</strong>。你还能够看到存储在G通道和B通道中的聚光源的阴影，最后一个聚光源的阴影存储在A通道中。</p><p>当光照体积不重叠时，它们使用相同的通道来存储它们的阴影数据。所以你可以有任意多个混合光照。但是你必须<strong>确保至多四个光照体积彼此重叠</strong>。如果有太多个混合光影响同一篇区域，那么一些就会改回到完全烘焙模式。为了说明这一点，下面这张截图显示的是在多加入一个聚光源以后的光照贴图。你可以在强度贴图中清楚地看到其中一个已经变成了烘焙光。</p><center class="half"><img class="fit-picture" loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002332758-586177298.png" width="250" alt="loading failed, need vpn." /> <img class="fit-picture" loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002333778-925731185.png" width="250" alt="loading failed, need vpn." /></center> <font size="2.5"> <center><i><a>5个重叠的光照，其中一个为完全烘焙光.</a></i></center> </font><h3 id="支持多个有蒙版的定向光">支持多个有蒙版的定向光</h3><p>不幸的是，阴影蒙版只有当包含至多一个混合模式的方向光源存在时才能正常工作。对于额外的方向光，阴影衰减会发生错误，至少是在使用前向渲染通道时。延迟渲染倒没有问题。</p><center class="half"><img class="fit-picture" loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002335110-966052747.png" width="250" alt="loading failed, need vpn." /></center> <font size="2.5"> <center><i><a>两个方向光源产生错误的衰减.</a></i></center> </font><p>这是使用UNITY_LIGHT_ATTENUATION的新方法中的一个漏洞：Unity使用通过UNITY_SHADOW_COORDS定义的阴影插值来存储方向阴影的屏幕空间坐标，或者其它拥有阴影蒙版的光源的光照贴图坐标。</p><p>使用阴影蒙版的方向光还需要光照贴图坐标。在forward-render中，这些坐标会被包含，因为LIGHTMAP_ON会在需要的时候被定义。然而，LIGHTMAP_ON在additional-pass中永远不会被定义。这意味着多余的方向光没有可用的光照贴图坐标。结果UNITY_LIGHT_ATTENUATION在这种情况下只会使用0，导致错误的光照贴图采样</p><p>所以我们不能依靠UNITY_LIGHT_ATTENUATION额外获得使用阴影蒙版的方向光源。用屏幕空间的方向阴影</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if defined(FOG_LINEAR) || defined(FOG_EXP) || defined(FOG_EXP2)
</span>    
<span class="cp">#endif
#if !defined(LIGHTMAP_ON) &amp;&amp; defined(SHADOWS_SCREEN)
</span>    <span class="cp">#if defined(SHADOWS_SHADOWMASK) &amp;&amp; !defined(UNITY_NO_SCREENSPACE_SHADOWS)
</span>        <span class="cp">#define ADDITIONAL_MASKED_DIRECTIONAL_SHADOWS 1
</span>    <span class="cp">#endif
#endif
</span></code></pre></div></div><p>接下来，对那些额外有蒙版的定向阴影，我们也要包含光照贴图坐标。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Interpolators</span> <span class="p">{</span>
    
    <span class="cp">#if defined(LIGHTMAP_ON) || ADDITIONAL_MASKED_DIRECTIONAL_SHADOWS
</span>        <span class="kt">float2</span> <span class="n">lightmapUV</span> <span class="o">:</span> <span class="n">TEXCOORD6</span><span class="p">;</span>
    <span class="cp">#endif
</span><span class="p">};</span>

<span class="n">Interpolators</span> <span class="nf">MyVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    
    <span class="cp">#if defined(LIGHTMAP_ON) || ADDITIONAL_MASKED_DIRECTIONAL_SHADOWS
</span>        <span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">uv1</span> <span class="o">*</span> <span class="n">unity_LightmapST</span><span class="p">.</span><span class="n">xy</span> <span class="o">+</span> <span class="n">unity_LightmapST</span><span class="p">.</span><span class="n">zw</span><span class="p">;</span>
    <span class="cp">#endif
</span>    
<span class="p">}</span>
</code></pre></div></div><p>当光照贴图坐标可用时，我们可以再次使用FadeShadows函数进行我们自己控制的衰减。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="nf">FadeShadows</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">,</span> <span class="n">float</span> <span class="n">attenuation</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="cp">#if HANDLE_SHADOWS_BLENDING_IN_GI || ADDITIONAL_MASKED_DIRECTIONAL_SHADOWS
</span>        
    <span class="cp">#endif
</span>    <span class="k">return</span> <span class="n">attenuation</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><p>但是，这仍然不正确，因为我们为其输入了错误的衰减数据。我们必须绕开UNITY_LIGHT_ATTENUATION，只得到烘焙后的衰减，在这个情况中我们可以使用SHADOW_ATTENUATION宏。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="nf">FadeShadows</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">,</span> <span class="n">float</span> <span class="n">attenuation</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="cp">#if HANDLE_SHADOWS_BLENDING_IN_GI || ADDITIONAL_MASKED_DIRECTIONAL_SHADOWS
</span>        <span class="c1">//UNITY_LIGHT_ATTENUATION doesn't fade shadows for us.</span>
        <span class="cp">#if ADDITIONAL_MASKED_DIRECTIONAL_SHADOWS
</span>            <span class="n">attenuation</span> <span class="o">=</span> <span class="n">SHADOW_ATTENUATION</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="cp">#endif
</span>        
    <span class="cp">#endif
</span>    <span class="k">return</span> <span class="n">attenuation</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><center class="half"><img class="fit-picture" loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002336571-896877423.png" width="250" alt="loading failed, need vpn." /></center> <font size="2.5"> <center><i><a>两个定向光源正确的衰减.</a></i></center> </font><h2 id="消减阴影-subtractive-shadows">消减阴影-Subtractive Shadows</h2><p>混合光照很好，但是它不像完全烘焙光照那样成本低廉。如果以低性能硬件为目标，那么混合光照不太可行。烘焙光照会管用，但是事实上你<strong>也许需要动态物体对静态物体投射阴影。那样的话，你可以使用消减混合光照模式</strong>。</p><center class="half"><img class="fit-picture" loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002337701-173459592.png" width="250" alt="loading failed, need vpn." /></center> <font size="2.5"> <center><i><a>消减模式.</a></i></center> </font><p>在切换到消减模式后，场景会亮很多。这是由于静态物体现在同时使用完全烘焙的光照贴图和方向光源。这是因为动态物体仍然会同时使用光照探头和方向光源。</p><center class="half"><img class="fit-picture" loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002338965-1025220581.png" width="250" alt="loading failed, need vpn." /></center> <font size="2.5"> <center><i><a>静态物体受到两次光照.</a></i></center> </font><p><strong>消减模式只可用于前向渲染</strong>。当使用延迟渲染路径时，相关的物体会回到前向渲染路径，就像透明物体那样。</p><h3 id="消减光照">消减光照</h3><p>在消减模式中，静态物体通过光照贴图被照亮，同时还将动态阴影考虑在内。这是通过降低光照贴图在阴影区域的强度来实现的。为此，着色器需要使用光照贴图和实时阴影。它还需要使用实时光照来计算出要将光照贴图调暗多少。这就是为什么我们在切换到这个模式后得到了双重光照。</p><p><strong>消减光照是一个近似，只在一个单一定向光下起作用，因此它只支持主方向光的阴影</strong>。另外，我们必须以某种方式了解在动态着色区域内间接光的环境是什么。由于我们使用的是一个完全烘焙的光照贴图，我们没有这个信息。Unity没有包含一个额外的只有间接光的光照贴图，而是使用了一个统一的颜色对环境光取近似值。即实时阴影颜色（Realtime Shadow Color），你可以在混合光照选项中调整它。</p><p>在着色器中，我们知道_当LIGHTMAP_ON_，<em>SHADOWS_SCREEN</em>，和_LIGHTMAP_SHADOW_MIXING_关键词被定义而_SHADOWS_SHADOWMASK_没有被定义时我们应该使用消减光照。如果这样的话我们定义_SUBTRACTIVE_LIGHTING_，以便更容易使用它。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if !defined(LIGHTMAP_ON) &amp;&amp; defined(SHADOWS_SCREEN)
</span>    <span class="cp">#if defined(SHADOWS_SHADOWMASK) &amp;&amp; !defined(UNITY_NO_SCREENSPACE_SHADOWS)
</span>        <span class="cp">#define ADDITIONAL_MASKED_DIRECTIONAL_SHADOWS 1
</span>    <span class="cp">#endif
#endif
</span>
<span class="cp">#if defined(LIGHTMAP_ON) &amp;&amp; defined(SHADOWS_SCREEN)
</span>    <span class="cp">#if defined(LIGHTMAP_SHADOW_MIXING) &amp;&amp; !defined(SHADOWS_SHADOWMASK)
</span>        <span class="cp">#define SUBTRACTIVE_LIGHTING 1
</span>    <span class="cp">#endif
#endif
</span></code></pre></div></div><p>在做其他事情之前，我们必须去除掉双重阴影。为此我们可以关闭动态光照，就像我们对延迟通道所做的那样。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UnityLight</span> <span class="nf">CreateLight</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">UnityLight</span> <span class="n">light</span><span class="p">;</span>

    <span class="cp">#if defined(DEFERRED_PASS) || SUBTRACTIVE_LIGHTING
</span>        <span class="n">light</span><span class="p">.</span><span class="n">dir</span> <span class="o">=</span> <span class="kt">float3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">light</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="cp">#else
</span>        
    <span class="cp">#endif
</span>
    <span class="k">return</span> <span class="n">light</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><center class="half"><img class="fit-picture" loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002340399-1575340233.png" width="250" alt="loading failed, need vpn." /></center> <font size="2.5"> <center><i><a>静态物体只有烘焙光.</a></i></center> </font><h3 id="为烘焙光打阴影">为烘焙光打阴影</h3><p>为了应用消减阴影，我们创建一个函数以在需要的时候调整间接光。通常它不会做任何事。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">ApplySubtractiveLighting</span> <span class="p">(</span>
    <span class="n">Interpolators</span> <span class="n">i</span><span class="p">,</span> <span class="k">inout</span> <span class="n">UnityIndirect</span> <span class="n">indirectLight</span>
<span class="p">)</span> <span class="p">{</span>

<span class="p">}</span>
</code></pre></div></div><p>我们在获取光照贴图数据后要调用该函数。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UnityIndirect</span> <span class="nf">CreateIndirectLight</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">,</span> <span class="kt">float3</span> <span class="n">viewDir</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if defined(FORWARD_BASE_PASS) || defined(DEFERRED_PASS)
</span>        <span class="cp">#if defined(LIGHTMAP_ON)
</span>            <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">DecodeLightmap</span><span class="p">(</span><span class="n">UNITY_SAMPLE_TEX2D</span><span class="p">(</span><span class="n">unity_Lightmap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">lightmapUV</span><span class="p">));</span>

            <span class="cp">#if defined(DIRLIGHTMAP_COMBINED)
</span>                
            <span class="cp">#endif
</span>
            <span class="n">ApplySubtractiveLighting</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">indirectLight</span><span class="p">);</span>
        <span class="cp">#else
</span>            <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ShadeSH9</span><span class="p">(</span><span class="kt">float4</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="mi">1</span><span class="p">)));</span>
        <span class="cp">#endif
</span>        
    <span class="cp">#endif
</span>
    <span class="k">return</span> <span class="n">indirectLight</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><p>如果有消减光照，那么我们必须获取阴影衰减。我们可以简单地从CreateLight中将代码复制过来。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">ApplySubtractiveLighting</span> <span class="p">(</span>
    <span class="n">Interpolators</span> <span class="n">i</span><span class="p">,</span> <span class="k">inout</span> <span class="n">UnityIndirect</span> <span class="n">indirectLight</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if SUBTRACTIVE_LIGHTING
</span>        <span class="n">UNITY_LIGHT_ATTENUATION</span><span class="p">(</span><span class="n">attenuation</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
        <span class="n">attenuation</span> <span class="o">=</span> <span class="n">FadeShadows</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">attenuation</span><span class="p">);</span>
    <span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div></div><p>下一步，我们要计算出如果使用实时光照的话我们可以接收到多少光。我们假设该信息和烘焙在光照贴图中的信息相吻合。由于光照贴图只包含漫射光，我们只需计算定向光的Lambert。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if SUBTRACTIVE_LIGHTING
</span>    <span class="n">UNITY_LIGHT_ATTENUATION</span><span class="p">(</span><span class="n">attenuation</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
    <span class="n">attenuation</span> <span class="o">=</span> <span class="n">FadeShadows</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">attenuation</span><span class="p">);</span>
    <span class="n">float</span> <span class="n">ndotl</span> <span class="o">=</span> <span class="nb">saturate</span><span class="p">(</span><span class="nb">dot</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="n">_WorldSpaceLightPos0</span><span class="p">.</span><span class="n">xyz</span><span class="p">));</span>
<span class="cp">#endif
</span></code></pre></div></div><p>为了达到阴影光照的强度，我们必须将兰伯特项乘以衰减。但是我们已经有了完全不含阴影的烘焙光照。因此我们估算一下有多少光被阴影挡住了。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float</span> <span class="n">ndotl</span> <span class="o">=</span> <span class="nb">saturate</span><span class="p">(</span><span class="nb">dot</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">,</span> <span class="n">_WorldSpaceLightPos0</span><span class="p">.</span><span class="n">xyz</span><span class="p">));</span>
<span class="kt">float3</span> <span class="n">shadowedLightEstimate</span> <span class="o">=</span> <span class="n">ndotl</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">attenuation</span><span class="p">)</span> <span class="o">*</span> <span class="n">_LightColor0</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
</code></pre></div></div><p>通过从烘焙光中减去该估值，我们最终得到了调整好的光照。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float3</span> <span class="n">shadowedLightEstimate</span> <span class="o">=</span> <span class="n">ndotl</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">attenuation</span><span class="p">)</span> <span class="o">*</span> <span class="n">_LightColor0</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
<span class="kt">float3</span> <span class="n">subtractedLight</span> <span class="o">=</span> <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="err">–</span> <span class="n">shadowedLightEstimate</span><span class="p">;</span>
<span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">subtractedLight</span><span class="p">;</span>
</code></pre></div></div><center class="half"><img class="fit-picture" loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002341952-1577870051.png" width="250" alt="loading failed, need vpn." /></center> <font size="2.5"> <center><i><a>减去后得到的光照.</a></i></center> </font><p>无论在什么环境光场景中，这总会产生纯黑色阴影。为了更好地符合场景的需要，我们可以使用我们的消减阴影颜色，可以通过unity_ShadowColor实现。阴影区域不应比这个颜色更暗，不过它们可以更亮些。所以我们取计算出的光照和阴影颜色的最大值。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float3</span> <span class="n">subtractedLight</span> <span class="o">=</span> <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">-</span> <span class="n">shadowedLightEstimate</span><span class="p">;</span>
<span class="n">subtractedLight</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">subtractedLight</span><span class="p">,</span> <span class="n">unity_ShadowColor</span><span class="p">.</span><span class="n">rgb</span><span class="p">);</span>
<span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">subtractedLight</span><span class="p">;</span>
</code></pre></div></div><p>我们还要考虑到阴影强度被设置为小于1这个情况。为了应用阴影强度，在有阴影和无阴影光照之间基于_LightShadowData的X分量做插值。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">subtractedLight</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">subtractedLight</span><span class="p">,</span> <span class="n">unity_ShadowColor</span><span class="p">.</span><span class="n">rgb</span><span class="p">);</span>
<span class="n">subtractedLight</span> <span class="o">=</span> <span class="nb">lerp</span><span class="p">(</span><span class="n">subtractedLight</span><span class="p">,</span> <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span><span class="p">,</span> <span class="n">_LightShadowData</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
<span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">subtractedLight</span><span class="p">;</span>
</code></pre></div></div><center class="half"><img class="fit-picture" loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002343602-223725225.png" width="250" alt="loading failed, need vpn." /></center> <font size="2.5"> <center><i><a>有颜色的阴影.</a></i></center> </font><p>因为我们的场景的环境强度（ambient intensity）被设置为0，所以默认的阴影颜色和场景不太搭配。但是可以很轻松地发现消减阴影，因此我没有调整它。还有一点非常明显，即阴影颜色现在覆盖了所有的烘焙阴影，而实际不应该这样。它应该只影响那些接收动态阴影的区域，不应该使烘焙阴影变亮。为此，使用消减光照和烘焙光照的最小值。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//indirectLight.diffuse = subtractedLight;</span>
<span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">subtractedLight</span><span class="p">,</span> <span class="n">indirectLight</span><span class="p">.</span><span class="n">diffuse</span><span class="p">);</span>
</code></pre></div></div><center class="half"><img class="fit-picture" loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002345136-2052798411.png" width="250" alt="loading failed, need vpn." /></center> <font size="2.5"> <center><i><a>正确的消减阴影.</a></i></center> </font><p>现在只要我们使用适当的阴影颜色，我们就会得到正确的消减阴影。但是记住这只是一个近似，而且它不太适用于多重光照。例如，其它的烘焙光会产生错误的阴影。</p><center class="half"><img class="fit-picture" loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender17/1692664-20200603002346714-785287043.png" width="250" alt="loading failed, need vpn." /></center> <font size="2.5"> <center><i><a>多重光照错误的消减.</a></i></center> </font></article><hr><div class='like-post'> <a style="color:rgb(112, 40, 85);" id="likeBtn" onclick="likePost(1);"> <i class="fa fa-thumbs-o-up fa-2x" aria-hidden="true"></i> </a> <span id="likeNum">0</span><div class="text-xs text-slate-500 mx-2">真诚点赞，手留余香</div></div><h2 id="similar_posts">Similar Posts</h2><ul><li class="relatedPost"> <a href="/2024/07/10/Unity_Addressable_Editor/">Unity Addressable Editor结构 </a><li class="relatedPost"> <a href="/2018/01/25/Unity_Parallax_Normals_Heightmap/">视差和法线、高度图回顾(翻译二十) </a><li class="relatedPost"> <a href="/2018/01/24/Unity_GPU_Instance/">Unity GPU Instance(翻译十九) </a><li class="relatedPost"> <a href="/2018/01/23/Unity_RealTime_GI_LOD/">Unity 实时 GI & LPPV & LOD(翻译十八) </a><li class="relatedPost"> <a href="/2018/01/19/Unity_Static_Lightting/">Unity 光照烘焙(翻译十六) </a><li class="relatedPost"> <a href="/2018/01/17/Unity_Deferred_Lights/">Unity Deferred Lights-延迟光照(翻译十五) </a></ul><div class="post-recent"><div class="pre"><p><strong>上一篇</strong> <a href="/2018/01/19/Unity_Static_Lightting/">Unity 光照烘焙(翻译十六)</a></p></div><div class="nex"><p><strong>下一篇</strong> <a href="/2018/01/23/Unity_RealTime_GI_LOD/">Unity 实时 GI & LPPV & LOD(翻译十八)</a></p></div></div><h2 id="comments">Comments</h2><div id="vcomments"></div><script type="text/javascript"> /*评论相关*/ function delayLoadValine() { new Valine({ el: '#vcomments', verify: "true", notify: "false", app_id: "JgYk2pcFa3QxhhWPhDjjoPvv-MdYXbMMI", app_key: "fjDLTSUgCNGrSKgCID672IJx", avatar: "monsterid", placeholder: "欢迎评论！", pageSize: "10 || 10", master: "b5586e582cb181c6b0fc8b2ce828bd50", tagMeta: ["博主","小伙伴","访客"], enableQQ: true, requiredFields: [], serverURLs: "https://leanapi.damonc.top", recordIP: "true", visitor: "true", }); $(document).ready(function(){ fetch('https://v1.hitokoto.cn/') .then(response => response.json()) .then(data => { document.getElementById("veditor").setAttribute( "placeholder", data.hitokoto+"—"+data.from ); setTimeout(() => { addPostVisitedTimes(); }, 1000); } ) .catch(console.error); }); } /*点赞相关*/ var curIpVisitRecord = null; var curPost = null; var curUrl = "https://www.damonc.top/2018/01/21/Unity_Mix_Lighting/"; function getVisitorIpAndJudge() { $.getJSON('https://api.ipify.org?format=json', function(data){ saveOrUpdateIpRecord(data.ip) }); } function saveOrUpdateIpRecord(ip) { var Visitor = AV.Object.extend("visitors_record"); var post_url = curUrl; var query = new AV.Query(Visitor); query.equalTo("visitor_ip", ip); query.equalTo("post_url", post_url); query.find().then(function(results) { if (results.length > 0) { /* if(window.console){ console.log('该IP已访问过该文章'); }*/ curIpVisitRecord = results[0]; updateIpRecord(); refreshLikeBtn(); } else { /*if(window.console){ console.log('该IP第一次访问该文章，保存新的访问记录，并增加访问次数'); }*/ addNewIpRecord(ip, post_url); } }, function(error) { addPostVisitedTimes(); }); } function addPostVisitedTimes() { var AV_Posts = AV.Object.extend("Posts"); var url = curUrl; var title = "Unity 混合光照(翻译十七)"; var query = new AV.Query(AV_Posts); query.equalTo("post_url", url); query.find().then(function(results) { if (results.length > 0) { curPost = results[0]; curPost.increment("visited_times"); curPost.save(); loadLikeNums(); } else { curPost = new AV_Posts(); /* Set ACL */ var acl = new AV.ACL(); acl.setPublicReadAccess(true); acl.setPublicWriteAccess(true); curPost.setACL(acl); /* End Set ACL */ curPost.set("post_title", title); curPost.set("post_url", url); curPost.set("visited_times", 1); curPost.set('like_times', 0); curPost.save(); } getVisitorIpAndJudge(); }, function(error) { console.log('Error:' + error.code + " " + error.message); }); } function showPostVisitedTimes() { var AV_Posts = AV.Object.extend("Posts"); var $visitors = $(".leancloud_visitors"); var url = $visitors.attr('id').trim(); var title = $visitors.attr('data-flag-title').trim(); var query = new AV.Query(AV_Posts); query.equalTo("post_url", url); query.find().then(function(results) { if (results.length > 0) { curPost = results[0]; loadLikeNums(); } else { /*if(window.console){ console.log('异常情况，不应该没记录的'); }*/ } }, function(error) { console.log('Error:' + error.code + " " + error.message); }); } function updateIpRecord(){ var lastTime = curIpVisitRecord.updatedAt; var curTime = new Date(); var timePassed = curTime.getTime() - lastTime.getTime(); if(timePassed > 300000) { /*if(window.console){ console.log('距离该IP上一次访问该文章已超过了5分钟，更新访问记录，并增加访问次数'); }*/ addPostVisitedTimes(); curIpVisitRecord.save(); } else { /*console.log('这是该IP 1分钟内重复访问该文章，不更新访问记录，不增加访问次数');*/ } } function addNewIpRecord(ip, post_url){ var Visitor = AV.Object.extend("visitors_record"); curIpVisitRecord = new Visitor(); /* Set ACL */ var acl = new AV.ACL(); acl.setPublicReadAccess(true); acl.setPublicWriteAccess(true); curIpVisitRecord.setACL(acl); curIpVisitRecord.set("visitor_ip", ip); curIpVisitRecord.set("post_url", post_url); curIpVisitRecord.set("like_this_post", 0); curIpVisitRecord.save(); } function loadLikeNums() { var likeTimes = curPost.get('like_times'); $("#likeNum").text(likeTimes); } function refreshLikeBtn() { var likeState = curIpVisitRecord.get('like_this_post'); if(likeState == 1){ $("#likeBtn").css("color", "red"); $("#likeBtn").attr("onclick", "likePost(-1)"); } else { $("#likeBtn").css("color", "rgb(112, 40, 85)"); $("#likeBtn").attr("onclick", "likePost(1)"); } loadLikeNums(); } function likePost(type) { if(curPost == null || curIpVisitRecord == null) { alert('延迟10s后才能点赞, 请稍等...'); return } var newNum; var getlikeTime = curPost.get('like_times'); if(typeof getlikeTime == "undefined" || getlikeTime == null || getlikeTime == "") { newNum = parseInt(type); }else{ newNum = parseInt(type) + parseInt(getlikeTime); } curPost.set('like_times', newNum); curPost.save().then(function(curPost){ var likeThisPost = type == -1 ? 0 : 1; curIpVisitRecord.set("like_this_post", likeThisPost); curIpVisitRecord.save().then(function(){ refreshLikeBtn(); }); },function(error){ console.log('Failed to create visitor record, with error message: ' + error.message); }); } /*启动执行*/ setTimeout(() => { delayLoadValine(); }, 10000); </script></div></div><script> /** * target _blank */ (function() { var aTags = document.querySelectorAll('article a:not([id])'); for (var i = 0; i < aTags.length; i++) { var htps = aTags[i].href; if (htps.startsWith("https://")) aTags[i].setAttribute('target', '_blank'); } }()); </script> <script src="/js/pageContent.js " charset="utf-8"></script><footer class="site-footer"><div class="wrapper"><p class="description"> 云上的日子!</p><p class="contact"> <a href="https://github.com/bitfeng" title="GitHub"><i class="fa fa-github" aria-hidden="true"></i></a> <a href="mailto:damonc@126.com" title="email"><i class="fa fa-envelope-o" aria-hidden="true"></i></a></p><p> 本站总访问量<span id="busuanzi_value_site_pv"></span>次，本站访客数<span id="busuanzi_value_site_uv"></span>人次，本文总阅读量<span id="busuanzi_value_page_pv"></span>次</p></div></footer><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="back-to-top"> <a href="#top" data-scroll> <i class="fa fa-arrow-up" aria-hidden="true"></i> </a></div><script src=" /js/main.js " charset="utf-8"></script> <script src=" /js/smooth-scroll.min.js " charset="utf-8"></script> <script type="text/javascript"> smoothScroll.init({ speed: 500, easing: 'easeInOutCubic', offset: 20, }); function displayWindowSize() { var w = document.documentElement.clientWidth; var h = document.documentElement.clientHeight; var rightDiv = document.querySelector('.right'); var footer = document.querySelector('.site-footer'); if(!rightDiv || !footer){ return; } if(w <= 1700){ rightDiv.style.display='none'; footer.style.display='none'; }else{ rightDiv.style.display='block'; footer.style.display = "block"; } } window.addEventListener("resize", displayWindowSize); displayWindowSize(); </script>
