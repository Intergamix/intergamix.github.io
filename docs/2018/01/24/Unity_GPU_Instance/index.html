<!DOCTYPE html><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="baidu-site-verification" content="code-BGVivWGmxV" /><title>Unity GPU Instance(翻译十九)</title><meta name="description" content="本篇摘要： 渲染大量球体-优化DrawCall 支持GPU-Instance 使用材质属性块 LOD-Groups支持GPU-Instance"><link rel="shortcut icon" href="/favicon.ico?" type="image/x-icon"><link rel="icon" href="/favicon.ico?" type="image/x-icon"><link rel="stylesheet" href="/css/main.css "><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href=" /css/font_8v3czwksspqlg14i.css "><link rel="canonical" href="https://www.damonc.top/2018/01/24/Unity_GPU_Instance/"><link rel="alternate" type="application/rss+xml" title="爱穿拖鞋" href="https://www.damonc.top/feed.xml "> <script type="text/javascript" src=" /js/jquery_3_2_0.min.js " charset="utf-8"></script> <script type="text/javascript" src=" /js/Valine.min.js " charset="utf-8"></script> <script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "//hm.baidu.com/hm.js?8c087101d4768b7aa439cef954b30a8f"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script> <script> (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0], j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src= 'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f); })(window,document,'script','dataLayer','GTM-WN45VXRK'); </script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <scrip type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/js-polyfills/0.1.43/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><body class="custom-background"> <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WN45VXRK" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><header id="top"><div class="wrapper"> <a href="/" class="brand">爱穿拖鞋</a> <small>自由自在🩴</small> <button id="headerMenu" class="menu"><i class="fa fa-bars"></i></button><nav id="headerNav"><ul><li> <a href="/"> <i class="fa fa-home"></i>Home </a><li> <a href="/archive/"> <i class="fa fa-archive"></i>归档 </a><li> <a href="/category/"> <i class="fa fa-th-list"></i>分类 </a><li> <a href="/tag/"> <i class="fa fa-tags"></i>标签 </a></ul></nav></div></header><div class="home-right-bar"> <button class="anchor"><i class="fa fa-anchor"></i></button><div class="right"><div class="wrap"><div class="side content"><div> 目录</div><ul id="content-side" class="content-ul"><li><a href="#comments">Comments</a></ul></div></div></div></div><div class="page clearfix" post><div class="left"><h1>Unity GPU Instance(翻译十九)</h1><div class="label"><div class="label-card"> <i class="fa fa-calendar"></i>2018-01-24</div><div class="label-card"> <i class="fa fa-user"></i>catlikecoding</div><div class="label-card"></div><div class="label-card"> <span class="categories"> <i class="fa fa-th-list"></i> <a href="/category/#翻译" title="Category: 翻译" rel="category">翻译</a> </span></div><div class="label-card"> <span class="pageTag"> <i class="fa fa-tags"></i> <b href="/tag/#Shader" title="Tag: Shader" rel="tag">Shader</b>&nbsp; <b href="/tag/#Unity3d" title="Tag: Unity3d" rel="tag">Unity3d</b> </span></div></div><hr><article><ul id="markdown-toc"><li><a href="#batching-instance-批处理" id="markdown-toc-batching-instance-批处理">Batching Instance-批处理</a><ul><li><a href="#创建大量球体" id="markdown-toc-创建大量球体">创建大量球体</a><li><a href="#支持instance" id="markdown-toc-支持instance">支持Instance</a><li><a href="#instance-ids" id="markdown-toc-instance-ids">Instance IDs</a><li><a href="#批处理大小" id="markdown-toc-批处理大小">批处理大小</a><li><a href="#instance-shadows" id="markdown-toc-instance-shadows">Instance Shadows</a><li><a href="#多光源" id="markdown-toc-多光源">多光源</a></ul><li><a href="#mixing-material-properties" id="markdown-toc-mixing-material-properties">Mixing Material Properties</a><ul><li><a href="#随机着色" id="markdown-toc-随机着色">随机着色</a><li><a href="#材质属性块-material-property-blocks" id="markdown-toc-材质属性块-material-property-blocks">材质属性块-Material Property Blocks</a><li><a href="#property-buffers-属性缓冲区" id="markdown-toc-property-buffers-属性缓冲区">Property Buffers-属性缓冲区</a><li><a href="#阴影" id="markdown-toc-阴影">阴影</a><li><a href="#lod-instance" id="markdown-toc-lod-instance">LOD Instance</a></ul></ul><p>本篇摘要：</p><ul><li>渲染大量球体-优化DrawCall<li>支持GPU-Instance<li>使用材质属性块<li>LOD-Groups支持GPU-Instance</ul><h2 id="batching-instance-批处理">Batching Instance-批处理</h2><p>指示GPU绘制需要花时间；向其传递mesh和material属性也要花时间。<strong>现在已知两种节省Draw Call的方式：static</strong>和<a href="https://docs.unity3d.com/Manual/DrawCallBatching.html"><strong>dynamic batching</strong></a></p><p>Unity可以将多个静态物体的网格合并为一个更大的静态网格，从而减少draw call。 <strong>注意：</strong> 只有使用相同材质的对象才能以这种方式组合。 这是以必须存储更多网格数据为代价的。 启用动态批处理后，Unity在运行时会对视图中的动态对象执行相同的操作。 这仅适用于小型网格物体，否则开销将变得太大。</p><p>还有另一种组合draw call的方法：GPU instance或Geometry instance。与动态批处理一样，此操作在运行时针对可见对象。 它的目标是让GPU一次性渲染同一网格的多个副本。 因此，它不能组合不同的网格或材质，但不仅限于小网格。</p><h3 id="创建大量球体">创建大量球体</h3><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">using</span> <span class="n">UnityEngine</span><span class="p">;</span>

<span class="kr">public</span> <span class="k">class</span> <span class="n">GPUInstancingTest</span> <span class="o">:</span> <span class="n">MonoBehaviour</span> <span class="p">{</span>
    <span class="kr">public</span> <span class="n">Transform</span> <span class="n">prefab</span><span class="p">;</span>
    <span class="kr">public</span> <span class="n">int</span> <span class="n">instances</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">;</span>
    <span class="kr">public</span> <span class="n">float</span> <span class="n">radius</span> <span class="o">=</span> <span class="mi">50</span><span class="n">f</span><span class="p">;</span>
    <span class="c1">//单位圆内随机一点并放大坐标50倍，生成5000个球体</span>
    <span class="c1">//然后查看statistics统计的draw Call信息</span>
    <span class="kt">void</span> <span class="n">Start</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">instances</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Transform</span> <span class="n">t</span> <span class="o">=</span> <span class="n">Instantiate</span><span class="p">(</span><span class="n">prefab</span><span class="p">);</span>
            <span class="n">t</span><span class="p">.</span><span class="n">localPosition</span> <span class="o">=</span> <span class="n">Random</span><span class="p">.</span><span class="n">insideUnitSphere</span> <span class="o">*</span> <span class="n">radius</span><span class="p">;</span>
            <span class="n">t</span><span class="p">.</span><span class="n">SetParent</span><span class="p">(</span><span class="n">transform</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>使用forward render path统计到的draw call，去掉背景和camera Effect两个draw call：</p><center class="half"><img id="fit-picture" loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010902826-821880737.png" width="250" alt="loading failed, need vpn." /></center> <font size="2.5"> <center><i><a>5000 draw call.</a></i></center> </font><p>但是当使用cube代替球体</p><center class="half"><img id="fit-picture" loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010904552-338192039.png" width="250" alt="loading failed, need vpn." /></center> <font size="2.5"> <center><i><a>6 draw call.</a></i></center> </font><h3 id="支持instance">支持Instance</h3><p>默认情况下，GPU Instance不会开启，必须设计shader以支持它。 即使这样，也必须为每种材料显式启用实例化。 Unity的standard着色器有一个开关。像标准着色器的GUI一样，我们将为shader扩展面板创建“高级选项”部分。 可以通过调用MaterialEditor.EnableInstancingField方法来添加切换。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">DoAdvanced</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">GUILayout</span><span class="p">.</span><span class="n">Label</span><span class="p">(</span><span class="s">"Advanced Options"</span><span class="p">,</span> <span class="n">EditorStyles</span><span class="p">.</span><span class="n">boldLabel</span><span class="p">);</span>
    <span class="n">editor</span><span class="p">.</span><span class="n">EnableInstancingField</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div><p>仅当shader实际支持instance时，才会显示该切换。 我们可以通过将#pragma multi_compile_instancing指令添加到着色器base-pass启用此支持。 这将为一些关键字启用着色器变体，自定义关键字_INSTANCING_ON_，其他关键字也可以。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma multi_compile_fwdbase
#pragma multi_compile_fog
#pragma multi_compile_instancing
</span></code></pre></div></div><center class="half"><img id="fit-picture" loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010905493-1524350499.png" width="250" alt="loading failed, need vpn." /> <img id="fit-picture" loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010906722-1492830859.png" width="250" alt="loading failed, need vpn." /></center> <font size="2.5"> <center><i><a>合并了，但是显示有错误.</a></i></center> </font><p>批处理数量已减少到42，这意味着现在仅用40个批处理即可渲染所有5000个球体。帧速率也高达80 fps，但是只有几个球体可见。<strong>错误原因</strong>：虽然5000个球体仍在渲染，但是在合批中同一批次的所有球体的顶点转换时都使用了同一个位置：它们都使用同一批次中第一个球的转换矩阵。 发生这种情况是因为现在同一批中所有球体的矩阵都作为数组发送到GPU。 在不告知着色器要使用哪个数组索引的情况下，它始终使用第一个索引。</p><h3 id="instance-ids">Instance IDs</h3><p>上述错误解决办法：每个Instance相对应的数组索引称为其Instance ID，GPU通过顶点数据将其传递到着色器的vertex程序。在大多数平台上，它是一个无符号整数，名为instanceID，具有SV_InstanceID语义。 我们可以简单地使用_UNITY_VERTEX_INPUT_INSTANCE_ID_宏将其包含在我们的VertexData结构中。 它在UnityCG中包含的_UnityInstancing.cginc_文件中定义。 它为我们提供了实例ID的正确定义，或者在未启用实例化时不提供任何内容。将其添加到VertexData结构。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">VertexData</span> <span class="p">{</span>
    <span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
    <span class="kt">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="nb">POSITION</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div><p>启用instance后，我们现在可以在顶点程序中访问instanceID。 有了它，我们可以在变换顶点位置时使用正确的矩阵。 但是，UnityObjectToClipPos函数没有矩阵参数，它函数内部始终使用unity_ObjectToWorld矩阵。要解决此问题，UnityInstancing包含文件会使用矩阵数组的宏覆盖unity_ObjectToWorld。 <em>这可以被认为是肮脏的宏技巧，但无需更改现有着色器代码即可工作，从而确保了向后兼容性</em>。</p><p>要使它工作，instance的数组索引必须对所有着色器代码全局可用。必须通过_UNITY_SETUP_INSTANCE_ID_宏进行手动设置，该宏必须在vertex程序最先计算，然后再执行其他的代码。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">InterpolatorsVertex</span> <span class="nf">MyVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">InterpolatorsVertex</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">UNITY_INITIALIZE_OUTPUT</span><span class="p">(</span><span class="n">Interpolators</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="n">i</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><center class="half"><img id="fit-picture" loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010908398-221325174.png" width="250" alt="loading failed, need vpn." /></center> <font size="2.5"> <center><i><a>矩阵替换内部实现？.</a></i></center> </font><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//UnityInstancing中的实际代码要复杂得多。 它要处理平台差异，其他使用实例化的方法以及用于立</span>
<span class="c1">//体声渲染的特殊代码，从而导致间接定义的多个步骤。 它还必须重新定义UnityObjectToClipPos，因</span>
<span class="c1">//为UnityCG首先包含UnityShaderUtilities。</span>
<span class="c1">//缓冲区宏将在后面说明。</span>
<span class="k">static</span> <span class="n">uint</span> <span class="n">unity_InstanceID</span><span class="p">;</span>

<span class="n">CBUFFER_START</span><span class="p">(</span><span class="n">UnityDrawCallInfo</span><span class="p">)</span>
    <span class="c1">// Where the current batch starts within the instanced arrays.</span>
    <span class="n">int</span> <span class="n">unity_BaseInstanceID</span><span class="p">;</span>
<span class="n">CBUFFER_END</span>

<span class="cp">#define UNITY_VERTEX_INPUT_INSTANCE_ID uint instanceID : SV_InstanceID;
</span>
<span class="cp">#define UNITY_SETUP_INSTANCE_ID(input) \
    unity_InstanceID = input.instanceID + unity_BaseInstanceID;
</span>
<span class="c1">// Redefine some of the built-in variables</span>
<span class="c1">// macros to make them work with instancing.</span>
<span class="n">UNITY_INSTANCING_CBUFFER_START</span><span class="p">(</span><span class="n">PerDraw0</span><span class="p">)</span>
    <span class="kt">float4x4</span> <span class="n">unity_ObjectToWorldArray</span><span class="p">[</span><span class="n">UNITY_INSTANCED_ARRAY_SIZE</span><span class="p">];</span>
    <span class="kt">float4x4</span> <span class="n">unity_WorldToObjectArray</span><span class="p">[</span><span class="n">UNITY_INSTANCED_ARRAY_SIZE</span><span class="p">];</span>
<span class="n">UNITY_INSTANCING_CBUFFER_END</span>
<span class="cp">#define unity_ObjectToWorld     unity_ObjectToWorldArray[unity_InstanceID]
#define unity_WorldToObject     unity_WorldToObjectArray[unity_InstanceID]
</span></code></pre></div></div><h3 id="批处理大小">批处理大小</h3><p>每台设备不一样，最终得到的批次数量可能与当前实验得到的数量不同。现在这情况下，以40批渲染5000个球体实例，这意味着每批125个球体。</p><p>每个批次都需要自己的矩阵数组。 此数据发送到GPU并存储在内存缓冲区中，在Direct3D中称为常量缓冲区，在OpenGL中称为统一缓冲区。 这些<strong>缓冲区具有最大大小</strong>，这限制了一批中可以容纳多少个实例。 假设台式机GPU每个缓冲区的限制为64KB。</p><p>一个矩阵由16个浮点数组成，每个浮点数均为4个字节。 因此，每个矩阵64个字节。 每个实例都需要一个对象到世界的转换矩阵。 但是，我们还需要一个世界到对象的矩阵来转换法线向量。 因此，最终每个实例有128个字节。 这导致最大批处理大小为“ 64000/128 = 500”，这只能在10个批处理中渲染5000个球体。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>内存单位是2进制，所以1KB表示1024字节，而不是1000。因此，'(64 * 1024)/ 128 = 512 '。UNITY_INSTANCED_ARRAY_SIZE默认定义为500，但您可以使用编译器指令覆盖它。例如，#pragma instancing_options maxcount:512将最大值设置为512。但是，这将导致断言失败错误，因此实际限制为511。到目前为止，500和512之间没有太大的差别。
</code></pre></div></div><p>即使假设台式机的最大容量为64KB成立，但是大多数移动设备的最大容量远远达不到64，可能仅为16KB。 Unity通过在针对OpenGL ES 3，OpenGL Core或Metal时将最大值除以四来解决此问题。 因为我在编辑器中使用的是OpenGL Core，所以最终的最大批处理大小为“ 500/4 = 125”。</p><p>可以通过添加编译器指令#pragma instancing_options force_same_maxcount_for_gl来禁用此自动减少功能。 多个instance选项组合在同一指令中。 但是，这可能会导致在部署到移动设备上时发生故障，因此请小心使用。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>那假设均等缩放选项呢？

可以使用#pragma instancing_options指示所有instance对象具有统一的缩放比例。 这消除了将世界到对象矩阵用于法线转换的需要(少存储一个矩阵)。 设置此选项后，虽然UnityObjectToWorldNormal函数确实会更改其行为，但它不会消除第二个矩阵数组。 因此，至少在Unity 2017.1.0中，此选项实际上没有任何作用。
</code></pre></div></div><h3 id="instance-shadows">Instance Shadows</h3><p>到目前为止，一直没有阴影。 重新打开主阴影的Soft shadow，并确保阴影距离足以包含所有球体</p><center class="half"><img id="fit-picture" loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010909964-776430193.png" width="250" alt="loading failed, need vpn." /></center> <font size="2.5"> <center><i><a>批处理爆炸.</a></i></center> </font><p>为大量物体渲染阴影会增加GPU耗能。但是我们也可以在渲染球体阴影时使用GPU instance。在shadow caster-pass中添加instance指令；同时也增加<code class="language-plaintext highlighter-rouge">UNITY_VERTEX_INPUT_INSTANCE_ID</code> and <code class="language-plaintext highlighter-rouge">UNITY_SETUP_INSTANCE_ID</code></p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma multi_compile_shadowcaster
#pragma multi_compile_instancing
</span><span class="k">struct</span> <span class="n">VertexData</span> <span class="p">{</span>
	<span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
<span class="p">};</span>

<span class="n">InterpolatorsVertex</span> <span class="nf">MyShadowVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">InterpolatorsVertex</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><center class="half"><img id="fit-picture" loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010911627-1161944067.png" width="250" alt="loading failed, need vpn." /></center> <font size="2.5"> <center><i><a>instanced 阴影.</a></i></center> </font><h3 id="多光源">多光源</h3><p>我们仅在base-pass和shadow caster-pass中添加了instance支持。 因此，批处理不适用于其他光源。 要验证这一点，停用主光源并添加一些会影响多个球体的聚光灯或点光源。 不要为它们打开阴影，因为那样会降低帧速率。</p><center class="half"><img id="fit-picture" loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010913312-1389275661.png" width="250" alt="loading failed, need vpn." /></center> <font size="2.5"> <center><i><a>批处理爆炸.</a></i></center> </font><p>上图，完全不支持多光源批处理。 要将instance与多个光源结合使用，只能切换到延迟渲染路径。 为此，请将所需的编译器指令添加到着色器的延迟传递中。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma multi_compile_prepassfinal
#pragma multi_compile_instancing
</span></code></pre></div></div><center class="half"><img id="fit-picture" loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010914967-1310775534.png" width="250" alt="loading failed, need vpn." /></center> <font size="2.5"> <center><i><a>多光源instance.</a></i></center> </font><h2 id="mixing-material-properties">Mixing Material Properties</h2><p>所有批处理都有一个限制：它们仅限于具有相同材料的对象。 当我们希望渲染的对象具有多样性时，此限制就会成为问题。</p><h3 id="随机着色">随机着色</h3><p>随机改变球体的颜色</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">Start</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">instances</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Transform</span> <span class="n">t</span> <span class="o">=</span> <span class="n">Instantiate</span><span class="p">(</span><span class="n">prefab</span><span class="p">);</span>
        <span class="n">t</span><span class="p">.</span><span class="n">localPosition</span> <span class="o">=</span> <span class="n">Random</span><span class="p">.</span><span class="n">insideUnitSphere</span> <span class="o">*</span> <span class="n">radius</span><span class="p">;</span>
        <span class="n">t</span><span class="p">.</span><span class="n">SetParent</span><span class="p">(</span><span class="n">transform</span><span class="p">);</span>
        <span class="n">t</span><span class="p">.</span><span class="n">GetComponent</span><span class="o">&lt;</span><span class="n">MeshRenderer</span><span class="o">&gt;</span><span class="p">().</span><span class="n">material</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span>    <span class="kr">new</span> <span class="n">Color</span><span class="p">(</span><span class="n">Random</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="n">Random</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="n">Random</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><center class="half"><img id="fit-picture" loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010916576-490651101.png" width="250" alt="loading failed, need vpn." /></center> <font size="2.5"> <center><i><a>球体与随机的颜色，没有批量和阴影.</a></i></center> </font><p>即使我们为物料启用了批处理，它也不再起作用。由于每个球体现在都有自己的材质，因此每个球体的着色器状态也必被更改。 这显示在统计面板中为SetPass call 数量。它曾经是所有领域的一体机，但是现在是5000。</p><h3 id="材质属性块-material-property-blocks">材质属性块-Material Property Blocks</h3><p>除了为每个球体创建新的材质实例外，我们还可以使用材质属性块。 这些是小的修改，设置属性块的颜色并将其传递给球体的渲染器，而不是直接分配材质的颜色。</p><p><a href="http://docs.unity3d.com/Documentation/ScriptReference/MaterialPropertyBlock.html">MaterialPropertyBlock</a>;</p><h3 id="property-buffers-属性缓冲区">Property Buffers-属性缓冲区</h3><p>渲染instance对象时，Unity通过将数组传递到GPU内存来使转换矩阵可用于GPU。 Unity对存储在材料属性块中的属性执行相同的操作。 但这要起作用，我们必须在shader中定义一个适当的缓冲区。</p><p>声明instance缓冲区的工作类似于创建诸如插值器之类的结构，但是确切的语法因平台而异。 我们可以使用_UNITY_INSTANCING_CBUFFER_START_和_UNITY_INSTANCING_CBUFFER_END_宏来解决差异。 启用实例化后，它们将不执行任何操作。</p><p>将_Color变量的定义放在instance缓冲区中。 _UNITY_INSTANCING_CBUFFER_START_宏需要一个名称参数。 实际名称无关紧要。 宏以UnityInstancing_为其前缀，以防止名称冲突。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UNITY_INSTANCING_CBUFFER_START</span><span class="p">(</span><span class="n">InstanceProperties</span><span class="p">)</span>
    <span class="kt">float4</span> <span class="n">_Color</span><span class="p">;</span>
<span class="n">UNITY_INSTANCING_CBUFFER_END</span>
</code></pre></div></div><p>像变换矩阵一样，启用instance后，颜色数据作为数组上传到GPU。_UNITY_DEFINE_INSTANCED_PROP_宏会为我们处理正确的声明语法。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UNITY_INSTANCING_CBUFFER_START</span><span class="p">(</span><span class="n">InstanceProperties</span><span class="p">)</span>
    <span class="c1">//float4 _Color;</span>
    <span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="kt">float4</span><span class="p">,</span> <span class="n">_Color</span><span class="p">)</span>
<span class="n">UNITY_INSTANCING_CBUFFER_END</span>
</code></pre></div></div><p>最后要访问fragment程序中的数组，我们还需要在其中知道instanceID。 因此，将其添加到插值器结构中。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">InterpolatorsVertex</span> <span class="p">{</span>
    <span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">Interpolators</span> <span class="p">{</span>
    <span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
<span class="p">};</span>
</code></pre></div></div><p>在vertex顶点程序中，将ID从顶点数据复制到插值器。 启用实例化时，_UNITY_TRANSFER_INSTANCE_ID_宏定义此简单操作，否则不执行任何操作。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">InterpolatorsVertex</span> <span class="nf">MyVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">InterpolatorsVertex</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">UNITY_INITIALIZE_OUTPUT</span><span class="p">(</span><span class="n">Interpolators</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="n">UNITY_TRANSFER_INSTANCE_ID</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><p>在片段程序的开头，使ID全局可用，就像在顶点程序中一样。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">FragmentOutput</span> <span class="nf">MyFragmentProgram</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><p>现在，我们必须在不使用instance时以_Color的形式访问颜色，而在启用实例化时以_Color [unity_InstanceID]的形式访问颜色。 使用_UNITY_ACCESS_INSTANCED_PROP_宏可同时支持上述两种访问。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float3</span> <span class="nf">GetAlbedo</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float3</span> <span class="n">albedo</span> <span class="o">=</span>
        <span class="nb">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span><span class="p">).</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">UNITY_ACCESS_INSTANCED_PROP</span><span class="p">(</span><span class="n">_Color</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">float</span> <span class="nf">GetAlpha</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">UNITY_ACCESS_INSTANCED_PROP</span><span class="p">(</span><span class="n">_Color</span><span class="p">).</span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>新版本如果编译有错误：
从2017.3及以上版本, UNITY_ACCESS_INSTANCED_PROP macro改了.它需要两个参数：buffer名，颜色名使用UNITY_ACCESS_INSTANCED_PROP(InstanceProperties, _Color).
</code></pre></div></div><center class="half"><img id="fit-picture" loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010918398-38688989.png" width="250" alt="loading failed, need vpn." /></center><p>现在，我们的颜色随机的球再次被批处理。 我们<strong>可以用相同的方式使其他属性可变。 对于颜色，浮点数，矩阵和四分量浮点向量，这是可能的</strong>。 <strong>如果要改变纹理，可以使用单独的纹理数组</strong>，并将索引添加到实例化缓冲区。其他属性修改类似。</p><p>可以在同一个缓冲区中组合多个属性，但要牢记大小限制。 还应注意，缓冲区被划分为32位块，因此单个浮点数需要与向量相同的空间。 您也可以使用多个缓冲区，但是也有一个限制，它们不是免费提供的。 启用instance后，每个要缓冲的属性都将成为一个数组，因此仅对需要根据instance变化的属性执行此操作。</p><h3 id="阴影">阴影</h3><p>我们的阴影也取决于颜色。 调整shader阴影以便每个实例也可以支持唯一的颜色。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//float4 _Color;</span>
<span class="n">UNITY_INSTANCING_CBUFFER_START</span><span class="p">(</span><span class="n">InstanceProperties</span><span class="p">)</span>
    <span class="n">UNITY_DEFINE_INSTANCED_PROP</span><span class="p">(</span><span class="kt">float4</span><span class="p">,</span> <span class="n">_Color</span><span class="p">)</span>
<span class="n">UNITY_INSTANCING_CBUFFER_END</span>

<span class="k">struct</span> <span class="n">InterpolatorsVertex</span> <span class="p">{</span>
    <span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">Interpolators</span> <span class="p">{</span>
    <span class="n">UNITY_VERTEX_INPUT_INSTANCE_ID</span>
<span class="p">};</span>
<span class="n">float</span> <span class="nf">GetAlpha</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">UNITY_ACCESS_INSTANCED_PROP</span><span class="p">(</span><span class="n">_Color</span><span class="p">).</span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">InterpolatorsVertex</span> <span class="nf">MyShadowVertexProgram</span> <span class="p">(</span><span class="n">VertexData</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">InterpolatorsVertex</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="n">UNITY_TRANSFER_INSTANCE_ID</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">float4</span> <span class="nf">MyShadowFragmentProgram</span> <span class="p">(</span><span class="n">Interpolators</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_TARGET</span> <span class="p">{</span>
    <span class="n">UNITY_SETUP_INSTANCE_ID</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><h3 id="lod-instance">LOD Instance</h3><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">Start</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">MaterialPropertyBlock</span> <span class="n">properties</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">MaterialPropertyBlock</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">instances</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
    <span class="p">{</span>
        <span class="n">Transform</span> <span class="n">t</span> <span class="p">=</span> <span class="nf">Instantiate</span><span class="p">(</span><span class="n">prefab</span><span class="p">);</span>
        <span class="n">t</span><span class="p">.</span><span class="n">localPosition</span> <span class="p">=</span> <span class="n">Random</span><span class="p">.</span><span class="n">insideUnitSphere</span> <span class="p">*</span> <span class="n">radius</span><span class="p">;</span>
        <span class="n">t</span><span class="p">.</span><span class="nf">SetParent</span><span class="p">(</span><span class="n">transform</span><span class="p">);</span>
        <span class="c1">//MaterialPropertyBlock properties = new MaterialPropertyBlock();</span>
        <span class="n">properties</span><span class="p">.</span><span class="nf">SetColor</span>
        <span class="p">(</span>
            <span class="s">"_Color"</span><span class="p">,</span> <span class="k">new</span> <span class="nf">Color</span><span class="p">(</span><span class="n">Random</span><span class="p">.</span><span class="k">value</span><span class="p">,</span> <span class="n">Random</span><span class="p">.</span><span class="k">value</span><span class="p">,</span> <span class="n">Random</span><span class="p">.</span><span class="k">value</span><span class="p">)</span>
        <span class="p">);</span>
        <span class="c1">//t.GetComponent&lt;MeshRenderer&gt;().SetPropertyBlock(properties);</span>
        <span class="n">MeshRenderer</span> <span class="n">r</span> <span class="p">=</span> <span class="n">t</span><span class="p">.</span><span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">MeshRenderer</span><span class="p">&gt;();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> 
        <span class="p">{</span>
            <span class="n">r</span><span class="p">.</span><span class="nf">SetPropertyBlock</span><span class="p">(</span><span class="n">properties</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> 
        <span class="p">{</span>
            <span class="c1">//对LOD子对象设置颜色</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">ci</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">ci</span> <span class="p">&lt;</span> <span class="n">t</span><span class="p">.</span><span class="n">childCount</span><span class="p">;</span> <span class="n">ci</span><span class="p">++)</span> <span class="p">{</span>
                <span class="n">r</span> <span class="p">=</span> <span class="n">t</span><span class="p">.</span><span class="nf">GetChild</span><span class="p">(</span><span class="n">ci</span><span class="p">).</span><span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">MeshRenderer</span><span class="p">&gt;();</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">r</span><span class="p">.</span><span class="nf">SetPropertyBlock</span><span class="p">(</span><span class="n">properties</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><center class="half"><img id="fit-picture" loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010919954-2006515171.png" width="250" alt="loading failed, need vpn." /></center><p>不幸的是没有有效的批处理。Unity能够对以相同的LOD颜色球体进行批处理，但是如果可以像往常一样进行批处理会更好。 我们可以通过用缓冲数组替换_unity_LODFade_来实现。可以通过为支持实例化的每个过程添加lodfade实例化选项来指示Unity的着色器代码执行此操作。</p><div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma multi_compile_instancing
#pragma instancing_options lodfade
</span></code></pre></div></div><center class="half"><img id="fit-picture" loading="lazy" src="https://damonc-top2.github.io/web-assets/posts/2018/month1/catRender19/1692664-20200612010921540-656727216.png" width="250" alt="loading failed, need vpn." /></center> <font size="2.5"> <center><i><a>instance LOD fading.</a></i></center> </font></article><hr><div class='like-post'> <a style="color:rgb(112, 40, 85);" id="likeBtn" onclick="likePost(1);"> <i class="fa fa-thumbs-o-up fa-2x" aria-hidden="true"></i> </a> <span id="likeNum">0</span><div class="text-xs text-slate-500 mx-2">真诚点赞，手留余香</div></div><h2 id="similar_posts">Similar Posts</h2><ul><li class="relatedPost"> <a href="/2024/07/10/Unity_Addressable_Editor/">Unity Addressable Editor结构 </a><li class="relatedPost"> <a href="/2018/01/25/Unity_Parallax_Normals_Heightmap/">视差和法线、高度图回顾(翻译二十) </a><li class="relatedPost"> <a href="/2018/01/23/Unity_RealTime_GI_LOD/">Unity 实时 GI & LPPV & LOD(翻译十八) </a><li class="relatedPost"> <a href="/2018/01/21/Unity_Mix_Lighting/">Unity 混合光照(翻译十七) </a><li class="relatedPost"> <a href="/2018/01/19/Unity_Static_Lightting/">Unity 光照烘焙(翻译十六) </a><li class="relatedPost"> <a href="/2018/01/17/Unity_Deferred_Lights/">Unity Deferred Lights-延迟光照(翻译十五) </a></ul><div class="post-recent"><div class="pre"><p><strong>上一篇</strong> <a href="/2018/01/23/Unity_RealTime_GI_LOD/">Unity 实时 GI & LPPV & LOD(翻译十八)</a></p></div><div class="nex"><p><strong>下一篇</strong> <a href="/2018/01/25/Unity_Parallax_Normals_Heightmap/">视差和法线、高度图回顾(翻译二十)</a></p></div></div><h2 id="comments">Comments</h2><div id="vcomments"></div><script type="text/javascript"> /*评论相关*/ function delayLoadValine() { new Valine({ el: '#vcomments', verify: "true", notify: "false", app_id: "JgYk2pcFa3QxhhWPhDjjoPvv-MdYXbMMI", app_key: "fjDLTSUgCNGrSKgCID672IJx", avatar: "monsterid", placeholder: "欢迎评论！", pageSize: "10 || 10", master: "b5586e582cb181c6b0fc8b2ce828bd50", tagMeta: ["博主","小伙伴","访客"], enableQQ: true, requiredFields: [], serverURLs: "https://leanapi.damonc.top", recordIP: "true", visitor: "true", }); $(document).ready(function(){ fetch('https://v1.hitokoto.cn/') .then(response => response.json()) .then(data => { document.getElementById("veditor").setAttribute( "placeholder", data.hitokoto+"—"+data.from ); setTimeout(() => { addPostVisitedTimes(); }, 1000); } ) .catch(console.error); }); } /*点赞相关*/ var curIpVisitRecord = null; var curPost = null; var curUrl = "https://www.damonc.top/2018/01/24/Unity_GPU_Instance/"; function getVisitorIpAndJudge() { $.getJSON('https://api.ipify.org?format=json', function(data){ saveOrUpdateIpRecord(data.ip) }); } function saveOrUpdateIpRecord(ip) { var Visitor = AV.Object.extend("visitors_record"); var post_url = curUrl; var query = new AV.Query(Visitor); query.equalTo("visitor_ip", ip); query.equalTo("post_url", post_url); query.find().then(function(results) { if (results.length > 0) { /* if(window.console){ console.log('该IP已访问过该文章'); }*/ curIpVisitRecord = results[0]; updateIpRecord(); refreshLikeBtn(); } else { /*if(window.console){ console.log('该IP第一次访问该文章，保存新的访问记录，并增加访问次数'); }*/ addNewIpRecord(ip, post_url); } }, function(error) { addPostVisitedTimes(); }); } function addPostVisitedTimes() { var AV_Posts = AV.Object.extend("Posts"); var url = curUrl; var title = "Unity GPU Instance(翻译十九)"; var query = new AV.Query(AV_Posts); query.equalTo("post_url", url); query.find().then(function(results) { if (results.length > 0) { curPost = results[0]; curPost.increment("visited_times"); curPost.save(); loadLikeNums(); } else { curPost = new AV_Posts(); /* Set ACL */ var acl = new AV.ACL(); acl.setPublicReadAccess(true); acl.setPublicWriteAccess(true); curPost.setACL(acl); /* End Set ACL */ curPost.set("post_title", title); curPost.set("post_url", url); curPost.set("visited_times", 1); curPost.set('like_times', 0); curPost.save(); } getVisitorIpAndJudge(); }, function(error) { console.log('Error:' + error.code + " " + error.message); }); } function showPostVisitedTimes() { var AV_Posts = AV.Object.extend("Posts"); var $visitors = $(".leancloud_visitors"); var url = $visitors.attr('id').trim(); var title = $visitors.attr('data-flag-title').trim(); var query = new AV.Query(AV_Posts); query.equalTo("post_url", url); query.find().then(function(results) { if (results.length > 0) { curPost = results[0]; loadLikeNums(); } else { /*if(window.console){ console.log('异常情况，不应该没记录的'); }*/ } }, function(error) { console.log('Error:' + error.code + " " + error.message); }); } function updateIpRecord(){ var lastTime = curIpVisitRecord.updatedAt; var curTime = new Date(); var timePassed = curTime.getTime() - lastTime.getTime(); if(timePassed > 300000) { /*if(window.console){ console.log('距离该IP上一次访问该文章已超过了5分钟，更新访问记录，并增加访问次数'); }*/ addPostVisitedTimes(); curIpVisitRecord.save(); } else { /*console.log('这是该IP 1分钟内重复访问该文章，不更新访问记录，不增加访问次数');*/ } } function addNewIpRecord(ip, post_url){ var Visitor = AV.Object.extend("visitors_record"); curIpVisitRecord = new Visitor(); /* Set ACL */ var acl = new AV.ACL(); acl.setPublicReadAccess(true); acl.setPublicWriteAccess(true); curIpVisitRecord.setACL(acl); curIpVisitRecord.set("visitor_ip", ip); curIpVisitRecord.set("post_url", post_url); curIpVisitRecord.set("like_this_post", 0); curIpVisitRecord.save(); } function loadLikeNums() { var likeTimes = curPost.get('like_times'); $("#likeNum").text(likeTimes); } function refreshLikeBtn() { var likeState = curIpVisitRecord.get('like_this_post'); if(likeState == 1){ $("#likeBtn").css("color", "red"); $("#likeBtn").attr("onclick", "likePost(-1)"); } else { $("#likeBtn").css("color", "rgb(112, 40, 85)"); $("#likeBtn").attr("onclick", "likePost(1)"); } loadLikeNums(); } function likePost(type) { if(curPost == null || curIpVisitRecord == null) { alert('延迟10s后才能点赞, 请稍等...'); return } var newNum; var getlikeTime = curPost.get('like_times'); if(typeof getlikeTime == "undefined" || getlikeTime == null || getlikeTime == "") { newNum = parseInt(type); }else{ newNum = parseInt(type) + parseInt(getlikeTime); } curPost.set('like_times', newNum); curPost.save().then(function(curPost){ var likeThisPost = type == -1 ? 0 : 1; curIpVisitRecord.set("like_this_post", likeThisPost); curIpVisitRecord.save().then(function(){ refreshLikeBtn(); }); },function(error){ console.log('Failed to create visitor record, with error message: ' + error.message); }); } /*启动执行*/ setTimeout(() => { delayLoadValine(); }, 10000); </script></div></div><script> /** * target _blank */ (function() { var aTags = document.querySelectorAll('article a:not([id])'); for (var i = 0; i < aTags.length; i++) { var htps = aTags[i].href; if (htps.startsWith("https://")) aTags[i].setAttribute('target', '_blank'); } }()); </script> <script src="/js/pageContent.js " charset="utf-8"></script><footer class="site-footer"><div class="wrapper"><p class="description"> 云上的日子!</p><p class="contact"> <a href="https://github.com/bitfeng" title="GitHub"><i class="fa fa-github" aria-hidden="true"></i></a> <a href="mailto:damonc@126.com" title="email"><i class="fa fa-envelope-o" aria-hidden="true"></i></a></p><p> 本站总访问量<span id="busuanzi_value_site_pv"></span>次，本站访客数<span id="busuanzi_value_site_uv"></span>人次，本文总阅读量<span id="busuanzi_value_page_pv"></span>次</p></div></footer><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="back-to-top"> <a href="#top" data-scroll> <i class="fa fa-arrow-up" aria-hidden="true"></i> </a></div><script src=" /js/main.js " charset="utf-8"></script> <script src=" /js/smooth-scroll.min.js " charset="utf-8"></script> <script type="text/javascript"> smoothScroll.init({ speed: 500, easing: 'easeInOutCubic', offset: 20, }); function displayWindowSize() { var w = document.documentElement.clientWidth; var h = document.documentElement.clientHeight; var rightDiv = document.querySelector('.right'); var footer = document.querySelector('.site-footer'); if(!rightDiv || !footer){ return; } if(w <= 1700){ rightDiv.style.display='none'; footer.style.display='none'; }else{ rightDiv.style.display='block'; footer.style.display = "block"; } } window.addEventListener("resize", displayWindowSize); displayWindowSize(); </script><meta name="viewport" content="width=device-width, initial-scale=1.0"><div id="myModal" class="modal" onclick="closeModal()"> <span class="modal-content"> <img id="modalImg" src="" alt="Modal Image"><div class="prev-div" onclick="prevImage()" ><button class="btn-s prev-btn"></button></div><div class="next-div" onclick="nextImage()" ><button class="btn-s next-btn"></button></div></span></div><script> var images = document.getElementsByTagName("img"); var currentImageIndex = 0; /*为每个图片标签添加点击事件*/ for (var i = 0; i < images.length; i++) { if(images[i].id.startsWith("fit-picture")){ images[i].onclick = function () { openModal(this); }; } } /*打开模态框并显示放大的图片*/ function openModal(img) { console.log(img.src); var modal = document.getElementById("myModal"); var modalImg = document.getElementById("modalImg"); modal.style.display = "block"; modalImg.src = img.src; } /*关闭模态框*/ function closeModal() { var modal = document.getElementById("myModal"); modal.style.display = "none"; } /*上一张图片*/ function prevImage() { event.stopPropagation(); /*阻止事件冒泡*/ currentImageIndex--; if (currentImageIndex < 0) { currentImageIndex = images.length - 1; } var modalImg = document.getElementById("modalImg"); modalImg.src = images[currentImageIndex].src; } /*下一张图片*/ function nextImage() { event.stopPropagation(); /*阻止事件冒泡*/ currentImageIndex++; if (currentImageIndex >= images.length) { currentImageIndex = 0; } var modalImg = document.getElementById("modalImg"); modalImg.src = images[currentImageIndex].src; } </script>
