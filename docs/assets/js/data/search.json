[ { "title": "Unity Transform&Matrix(翻译一)", "url": "/posts/Unity-Matrix&Transform/", "categories": "Unity3D, Shader", "tags": "Unity3D, Shader", "date": "2018-01-01 09:00:00 +0800", "snippet": "可视空间Unity Shader是怎么知道一个像素该画在哪个位置？下面是先展示一组Cube，一步步分析下去 cube array 操控一组3维坐标创建一组10*10*10的3维Cube数组，并作为UnityMatrices对象的成员变量，接下来显示这些Cube在空间中的位置void InitCubeArray(){ for (int i =0 , z = 0; z &lt; generalCount; z++) { for (int y = 0; y &lt; generalCount; y++) { for (int x = 0; x &lt; generalCount; x++) { cubes[i++] = CreateCubesPoint(x, y, z); } } }}Transform CreateCubesPoint(int x, int y, int z){ GameObject cube = GameObject.CreatePrimitive(PrimitiveType.Cube); cube.transform.localScale = new Vector3(0.5f, 0.5f, 0.5f); cube.transform.localPosition = CreateCoordinate(x, y, z); cube.GetComponent&lt;MeshRenderer&gt;().material.color = CreateColor(x, y, z); return cube.transform;}设置每个Cube的位置，都以(0,0,0)为原点，(10-1)*0.5为Center左右两边对称Vector3 CreateCoordinate(int x, int y, int z){ return new Vector3( x - center, y - center, z - center );}然后再用自身坐标xyz分量与center的比率初始化颜色rgb。效果如上图Color CreateColor(int x, int y, int z){ return new Color( (float)x / generalCount, (float)y / generalCount, (float)z / generalCount );}空间变换positionning, rotating, and scalingCube数组中每个元素在空间中的变换有可能会有差异，虽然每个Cube变换的细节不同，但它们都需要经过某个方法来变换到空间中的某个坐标点。为此我们可以为所有变换创建一个abstract 基类，包含一个抽象的_Applay()_成员方法，由具体的变换组件去实现这个方法。public abstract class Transformation : MonoBehaviour{ public abstract Vector3 Apply(Vector3 point);}我们给这个UnityMatrices对象添加Transformation组件，同时检索Cube数组每个对象，将其坐标传入这个组件的_Apply()_方法进行计算得到新坐标并应用，这里始终以(0，0，0)作为每个Cube对象的原点坐标，而不能依赖其实际坐标，因为会每帧实时计算并改变。最后我们用泛型列表存储这种一系列变换组件方便统一计算。private void Update(){ GetComponents&lt;Transformation&gt;(transformations); // for (int i = 0; i &lt; cubes.Length; i++) // { // cubes[i].localPosition = TransformPoint(cubes[i].localPosition); // } for (int i =0 , z = 0; z &lt; generalCount; z++) { for (int y = 0; y &lt; generalCount; y++) { for (int x = 0; x &lt; generalCount; x++) { cubes[i++].localPosition = TransformPoint(x, y, z); } } }}Vector3 TransformPoint(int x, int y, int z){ Vector3 coordinates = CreateCoordinate(x, y, z); for (int i = 0; i &lt; transformations.Count; i++) { coordinates = transformations[i].Apply(coordinates); } return coordinates; }位移现在来做第一种变换：translation位移，这很简单。首先创建一个继承自Transformation组件子类，并定义一个表示自身位置属性的变量，并实现基类的抽象方法。然后添加给Cube数组对象public class PositionTransformation : Transformation{ public Vector3 position; public override Vector3 Apply(Vector3 point) { return point + position; }}现在可以向UnityMatrices对象添加PositionTransformation组件。这允许我们在不移动UnityMatrices对象的情况下移动数组中每个对象的坐标，所有的变换都发生在cube的局部空间。 位移 缩放接下来做第二种变换：Scaling缩放。public class ScaleTransformation : Transformation{ public Vector3 scale = new Vector3(1, 1, 1); public override Vector3 Apply(Vector3 point) { point.x *= scale.x; point.y *= scale.y; point.z *= scale.z; return point; }} 缩放 这里有一个问题：当进行缩放时，缩放会改变每个Cube对象的position。这是因为我们先计算了空间坐标，然后才缩放的它。而Unity中Transform组件是先缩放后位移。所以正确的计算顺序是：先缩放后位移。旋转(二维)第三种变换：Rotation旋转。public class RotationTransform : Transformation{ public Vector3 rotation; public override Vector3 Apply(Vector3 point) { return point;//先占位 }}旋转该如何工作呢？现在先假定在2维空间下一点P，绕Z轴旋转。Unity使用了左手坐标系，正向旋转是逆时针方向，如下图： 2维空间下绕Z轴旋转 旋转一个点坐标后会发什么吗？先简单的考虑一个以原点为中心的单位圆上的一点P，设p初始位置为(1,0)，然后再以每90°增量进行一次旋转，如下图： 0°旋转到90°和180°变化 由上图可知，点p(1,0)旋转一次(90°)变为了(0,1)，再旋转一次(180°)变为了(-1,0)，再往下旋转会变为(0,-1)，最后回到原位置(1,0). 那如果用点(0,1)作为初始位置，其变换顺序(0,1)$\\rightarrow$(-1,0)$\\rightarrow$(0,-1)$\\rightarrow$(1,0)$\\rightarrow$(0,1). 因此这个点坐标始终围绕0，1，0，-1进行循环，唯一得区别是起始点位置不同。那如果以45°增量进行旋转呢?它会在XY平面对角线上产生一点，其坐标为($\\pm \\sqrt{1 \\over 2},\\pm \\sqrt{1 \\over 2}$)，这些点到原点的距离始终是一致的。而这个循环顺序也类似上面，是$0, \\sqrt{1 \\over 2}, 1, \\sqrt{1 \\over 2}, 0, −\\sqrt{1 \\over 2}, −1, −\\sqrt{1 \\over 2}$。如果继续减小增量值，我们就可以得到一个Sine曲线。 Sine 和 Cosine曲线 结合上面两张图，Sine曲线代表了Y分量，Cosine曲线代表了X分量，坐标用曲线表示就是$(\\cos z, \\sin z)$，若起始点为(1,0)则结果为$(cosz,sinz)$，逆时针旋转90°后(根据$sin(-z) = –sin z, cos(-z) = cos z$的对称性质)则结果为$(−sin z,cos z)$。因此我们可以用绕Z轴计算sine和cosine曲线，由于提供的是角度，但实际上sin及cos只能作用于弧度，所以我们需要转化它:public override Vector3 Apply(Vector3 point){ float radz = rotation.z * Mathf.Deg2Rad; float sinz = Mathf.Sin(radz); float cosz = Mathf.Cos(radz); return point;} 什么是弧度? 像度数一样，可以用作旋转的度量。使用单位圆时，弧度与圆周行进的距离相等。由于圆周的长度等于2π乘以圆的半径，因此1度等于2π/360 = π/180弧度。π 是圆的周长与其直径之间的比率。上述方法对于旋转(1,0)或(0,1)或许很好，那有米有旋转任意点的方式呢？ 这些点都是由X和Y定义的，我们可以把2维点(x,y)拆分为一个公式$xX+yY$，那么$x(1,0)+y(0,1)=(x, y)$是成立的。当旋转之后，可以用$x(cos z, sin z)+y(-sin z, cos z)$来得到经过正确旋转后的点。组合为坐标就变成了$(xcosZ−ysinZ,xsinZ+ycosZ)$.public override Vector3 Apply(Vector3 point){ float radz = rotation.z * Mathf.Deg2Rad; float sinz = Mathf.Sin(radz); float cosz = Mathf.Cos(radz); //return point; return new Vector3( point.x * cosz - point.y * sinz, point.x * sinz + point.y * cosz, point.z );}按照上述分析的缩放、旋转、位移的先后计算顺序，再在Unity内对比Transform的拖动旋转缩放的显示，二者的效果是一致的。void Start (){ //... gameObject.AddComponent&lt;ScaleTransformation&gt;(); gameObject.AddComponent&lt;RotationTransform&gt;(); gameObject.AddComponent&lt;PositionTransformation&gt;();} 最终变换效果 旋转完全体现在我们只能绕Z轴旋转，但是为了能够复刻Unity的Transform组件那样的旋转，现在就得要支持绕X轴和绕Y轴旋转。虽然分别绕这些轴旋转与绕Z轴旋转的方法相似，但是当一次同时绕多个轴旋转时这就很复杂了。目标：一次同时绕多个轴旋转，迎难而上。2D矩阵现在开始，我们要把坐标书写格式由水平式替代为垂直式。把(x,y)被改写为\\(\\begin{bmatrix} x\\\\ y\\\\\\end{bmatrix}\\)把$(xcosZ−ysinZ,xsinZ+ycosZ)$也同样被拆分为\\(\\begin{bmatrix} xcosZ-ysinZ\\\\ xsinZ+ycosZ\\\\\\end{bmatrix}\\)，再把这个表达式进一步拆分：\\(\\begin{bmatrix} cosZ&amp;-sinZ\\\\ sinZ&amp;cosZ\\\\\\end{bmatrix}\\)\\(\\begin{bmatrix} x\\\\ y\\\\\\end{bmatrix}\\)这就是矩阵乘法，2x2矩阵的第一列值代表X轴，第二列值代表了Y轴，计算公式如下：\\(\\begin{bmatrix} Xx&amp;Yx\\\\ Xy&amp;Yy\\\\\\end{bmatrix}\\)\\(\\begin{bmatrix} a\\\\ b\\\\\\end{bmatrix}\\)=\\(\\begin{bmatrix} aXx + bYx\\\\ aXy + bYy\\\\\\end{bmatrix}\\) 由于Unity是采用左手法则，在上文中单位圆上一点绕Z轴旋转的增量度不同，cos代表X轴，sin代表Y轴，在结合本文的矩阵可得\\(\\begin{bmatrix} cos\\theta&amp;-sin\\theta\\\\ sin\\theta&amp;cos\\theta\\\\\\end{bmatrix}\\)$=cos\\theta$\\(\\begin{bmatrix} 1&amp;0\\\\ 0&amp;1\\\\\\end{bmatrix}\\)$+sin\\theta$\\(\\begin{bmatrix} 0&amp;-1\\\\ 1&amp;0\\\\\\end{bmatrix}\\)数学上定义，当两个矩阵相乘时，只有在第一个矩阵的列数（column）和第二个矩阵的行数（row）相同时才有意义。结果矩阵的每项元素等于第一个矩阵行元素与第二个矩阵列元素的乘积之和\\(\\begin{bmatrix} 1&amp;2\\\\ 3&amp;4\\\\\\end{bmatrix}\\)\\(\\begin{bmatrix} a&amp;c\\\\ b&amp;d\\\\\\end{bmatrix}\\)=\\(\\begin{bmatrix} 1a+2b&amp;1c+2d\\\\ 3a+4b&amp;3c+4d\\\\\\end{bmatrix}\\) A矩阵 * B矩阵 = A矩阵的行 * B矩阵的列；只有当A矩阵列数 = B矩阵行数时，矩阵相乘才有效。因此结果矩阵的行数等于第一个矩阵的行，列数等于第二个矩阵的列相同。3D矩阵到目前为止，我们有了一个2x2阶矩阵，可以用这个矩阵来绕Z轴旋转一个2D点。但我们实际上使用的是3D坐标。若试图用这个矩阵乘法\\(\\begin{bmatrix} cosZ&amp;-sinZ\\\\ sinZ&amp;cosZ\\\\\\end{bmatrix}\\)\\(\\begin{bmatrix} x\\\\ y\\\\ z\\\\\\end{bmatrix}\\)就是错误的，因为这两个矩阵的行与列的个数不匹配。为确保满足矩阵相乘，我们就需要填充这个第三维Z轴，先用0填充第一个矩阵第三行：\\(\\begin{bmatrix} cosZ&amp;-sinZ&amp;0\\\\ sinZ&amp;cosZ&amp;0\\\\ 0&amp;0&amp;0\\\\\\end{bmatrix}\\)\\(\\begin{bmatrix} x\\\\ y\\\\ z\\\\\\end{bmatrix}\\)=\\(\\begin{bmatrix} xcosZ-ysinZ+0z\\\\ xsinZ+ycosZ+0z\\\\ 0x+0y+0z\\\\\\end{bmatrix}\\)=\\(\\begin{bmatrix} xcosZ-ysinZ\\\\ xsinZ+ycosZ\\\\ 0\\\\\\end{bmatrix}\\)得到的结果中X轴和Y轴是正确的，但是Z轴结果总是为0。为了确保绕Z旋转而不改变Z轴的值，我们先插入一个数字1在旋转矩阵的右下角位置。简化理解，这个第三列值就是代表了Z轴：\\(\\begin{bmatrix} cosZ&amp;-sinZ&amp;0\\\\ sinZ&amp;cosZ&amp;0\\\\ 0&amp;0&amp;1\\\\\\end{bmatrix}\\)\\(\\begin{bmatrix} x\\\\ y\\\\ z\\\\\\end{bmatrix}\\)=\\(\\begin{bmatrix} xcosZ-ysinZ\\\\ xsinZ+ycosZ\\\\ z\\\\\\end{bmatrix}\\) 由数学上定义，任何矩阵与单位矩阵相乘都等于本身，单位矩阵如同乘法中的1\\(\\begin{bmatrix} 1&amp;0&amp;0\\\\ 0&amp;1&amp;0\\\\ 0&amp;0&amp;1\\\\\\end{bmatrix}\\)\\(\\begin{bmatrix} x\\\\ y\\\\ z\\\\\\end{bmatrix}\\)=\\(\\begin{bmatrix} x\\\\ y\\\\ z\\\\\\end{bmatrix}\\)绕X轴和Y轴的旋转矩阵推导根据绕Z轴旋转的方式推理可以得出绕X轴和Y轴的旋转矩阵。以绕Y轴为例，首先，X轴是以\\(\\begin{bmatrix} 1\\\\ 0\\\\ 0\\\\\\end{bmatrix}\\)开始，经过逆时针旋转90°后以\\(\\begin{bmatrix} 0\\\\ 0\\\\ -1\\\\\\end{bmatrix}\\)结束。那么经过旋转后的X轴可以表示为\\(\\begin{bmatrix} cosY\\\\ 0\\\\ -sinY\\\\\\end{bmatrix}\\)而Z轴与X轴垂直，所以Z轴就是\\(\\begin{bmatrix} sinY\\\\ 0\\\\ cosY\\\\\\end{bmatrix}\\)而Y轴始终保持不变，最后绕Y轴的旋转矩阵：\\(\\begin{bmatrix} cosY&amp;0&amp;sinY\\\\ 0&amp;1&amp;0\\\\ -sinY&amp;0&amp;cosY\\\\\\end{bmatrix}\\)同理绕X轴的旋转矩阵， X轴不变：\\(\\begin{bmatrix} 1&amp;0&amp;0\\\\ 0&amp;cosX&amp;-sinX\\\\ 0&amp;sinX&amp;cosX\\\\\\end{bmatrix}\\)那么就此可以得出三个矩阵： 绕X轴旋转矩阵\\(\\begin{bmatrix} 1&amp;0&amp;0\\\\ 0&amp;cos\\alpha&amp;sin\\alpha\\\\ 0&amp;-sin\\alpha&amp;cos\\alpha\\\\\\end{bmatrix}\\) 绕Y轴旋转矩阵\\(\\begin{bmatrix} cos\\theta&amp;0&amp;-sin\\theta\\\\ 0&amp;1&amp;0\\\\ sin\\theta&amp;0&amp;cos\\theta\\\\\\end{bmatrix}\\) 绕Z轴旋转矩阵\\(\\begin{bmatrix} cos\\theta&amp;sin\\theta&amp;0\\\\ -sin\\theta&amp;cos\\theta&amp;0\\\\ 0&amp;0&amp;1\\\\\\end{bmatrix}\\)统一的旋转矩阵通过上文我们分别得到了单独绕某个轴的旋转矩阵，现在开始我们要组合起来使用。这里的同时旋转本质上也是分步进行的，先绕Z轴旋转，然后绕Y轴，最后是绕X轴。这里有两种算法：第一种：先计算坐标点绕Z旋转，得出的结果坐标再计算绕Y轴旋转，再得出的结果坐标计算绕X轴旋转，最后得到最终的旋转坐标。第二种：把每个旋转矩阵相乘得到一个最终的新的旋转矩阵，这将同时作用与三个轴旋转。首先计算Y乘Z，这个结果矩阵的第一项的值是$cosYcosZ−0sinZ−0sinY=cosYcosZ$，最终矩阵\\(\\begin{bmatrix} cosYcosZ&amp;-cosYsinZ&amp;sinY\\\\ sinZ&amp;cosZ&amp;0\\\\ -sinYcosZ&amp;sinYsinZ&amp;cosY\\\\\\end{bmatrix}\\)最后计算X × (Y × Z)得出最终矩阵：\\(\\begin{bmatrix} cosYcosZ&amp;-cosYsinZ&amp;sinY\\\\ cosXsinZ+sinXsinYcosZ&amp;cosXcosZ-sinXsinYsinZ&amp;-sinXcosY\\\\ sinXsinZ-cosXsinYcosZ&amp;sinXcosZ+cosXsinYsinZ&amp;cosXcosY\\\\\\end{bmatrix}\\)public Vector3 rotation;//每个分量表示角度public int rotDelta; private void Update(){ rotation = new Vector3(rotDelta, rotDelta, rotDelta);} public override Vector3 Apply(Vector3 point){ float radx = rotation.x * Mathf.Deg2Rad; float rady = rotation.y * Mathf.Deg2Rad; float radz = rotation.z * Mathf.Deg2Rad; float sinx = Mathf.Sin(radx); float cosx = Mathf.Cos(radx); float siny = Mathf.Sin(rady); float cosy = Mathf.Cos(rady); float sinz = Mathf.Sin(radz); float cosz = Mathf.Cos(radz); Vector3 xRot = new Vector3( cosy * cosz, cosx * sinz + sinx * siny * cosz, sinx * sinz - cosx * siny * cosz ); Vector3 yRot = new Vector3( -cosy * sinz, cosx * cosz - sinx * siny * sinz, sinx * cosz + cosx * siny * sinz ); Vector3 zRot = new Vector3( siny, -sinx * cosy, cosx * cosy ); return xRot * point.x + yRot * point.y + zRot * point.z;}矩阵变换实现一个矩阵完成缩放、旋转、位移的计算为了实现这个目标，所以借鉴3.4旋转矩阵组合的方式，先对缩放和位移组合，即位移 x 缩放。缩放，根据单位矩阵的性质，任何矩阵与单位矩阵相乘的结果都是本身。那么对单位矩阵进行缩放即可：\\(\\begin{bmatrix} 2&amp;0&amp;0\\\\ 0&amp;3&amp;0\\\\ 0&amp;0&amp;4\\\\\\end{bmatrix}\\)\\(\\begin{bmatrix} x\\\\ y\\\\ z\\\\\\end{bmatrix}\\)=\\(\\begin{bmatrix} 2x\\\\ 3y\\\\ 4z\\\\\\end{bmatrix}\\)位移，不是对三个分量完全重新计算，而是在现有的坐标之上进行偏移。因此现在不能简单的重新表示为3x3阶矩阵，而是需要额外增加一列表示偏移。\\(\\begin{bmatrix} 1&amp;0&amp;0&amp;2\\\\ 0&amp;1&amp;0&amp;3\\\\ 0&amp;0&amp;1&amp;4\\\\\\end{bmatrix}\\)\\(\\begin{bmatrix} x\\\\ y\\\\ z\\\\\\end{bmatrix}\\)=\\(\\begin{bmatrix} x+2\\\\ y+3\\\\ z+4\\\\\\end{bmatrix}\\)但是，又由于矩阵乘法规定，第一个矩阵的列数等于第二个矩阵的行数才有意义。上图就是错误的。所以我们需要给坐标矩阵增加第四个元素，偏移矩阵增加一行。当它们增加的这个分量进行矩阵相乘时，其结果为1(我们先保留下这个数字1，以备后续使用).那就变成了4x4阶矩阵样式和一个4D点。\\(\\begin{bmatrix} 1&amp;0&amp;0&amp;2\\\\ 0&amp;1&amp;0&amp;3\\\\ 0&amp;0&amp;1&amp;4\\\\ 0&amp;0&amp;0&amp;0\\\\\\end{bmatrix}\\)\\(\\begin{bmatrix} x\\\\ y\\\\ z\\\\ 1\\\\\\end{bmatrix}\\)=\\(\\begin{bmatrix} x+2\\\\ y+3\\\\ z+4\\\\ 1\\\\\\end{bmatrix}\\)根据位移矩阵，所以我们要统一用4×4的变换矩阵。缩放和旋转矩阵会额外增加一行一列，其右下角是1。所有的点都带有一个第四维坐标分量，它总是1——其次坐标。其次坐标(Homogeneous Coordinates)不知道就问： 这个坐标的第四分量坐标是个啥？ 它有啥用啊？ 我们只知道上文提到位移时有用，那么缩放、旋转有用吗？ 当它的值为0，1，-1时会发生什么呢？有这样一个东西不叫坐标而叫向量，它可以被缩放和旋转，但不能被移动。向量描述了相对于某个点的偏移，具有方向和长度属性，没有位置属性。它\\(\\begin{bmatrix}x\\\\y\\\\z\\\\1\\\\\\end{bmatrix}\\)表示为一个点，而它\\(\\begin{bmatrix}x\\\\y\\\\z\\\\0\\\\\\end{bmatrix}\\)表示为一个向量。这样区分非常有用，因为我们可以使用相同的矩阵来变换一个点的位置、法线和切线。当第四个坐标值是0或1或其他数值时会发生什么？答案是什么也不会，准确的说是没有差异。这个坐标的术语叫做其次坐标，它的意思是空间中每个点都可以用一个无穷数量坐标集和来表示。而现在普遍做法的形式是使用1作为第四个坐标值，所有其他的数字都能通过使用整个集合乘以任意数来找到\\(\\begin{bmatrix}x\\\\y\\\\z\\\\1\\\\\\end{bmatrix}\\)\\(\\begin{bmatrix}2x\\\\2y\\\\2z\\\\2\\\\\\end{bmatrix}\\)\\(\\begin{bmatrix}3x\\\\3y\\\\3z\\\\3\\\\\\end{bmatrix}\\)\\(\\begin{bmatrix}wx\\\\wy\\\\wz\\\\w\\\\\\end{bmatrix}\\)=$w$\\(\\begin{bmatrix}x\\\\y\\\\z\\\\1\\\\\\end{bmatrix}\\)当我们知道了一个其次坐标时，需要转为3D坐标，只需要把第四个坐标化为1，怎么做呢？没错，就是把每个坐标除以第四个坐标，然后再舍弃第四个坐标\\(\\begin{bmatrix}x\\\\y\\\\z\\\\w\\\\\\end{bmatrix}\\)=$1 \\over w$\\(\\begin{bmatrix}x\\\\y\\\\z\\\\w\\\\\\end{bmatrix}\\)=\\(\\begin{bmatrix}x \\over w\\\\y \\over w\\\\z \\over w\\\\1\\\\\\end{bmatrix}\\)$\\rightarrow$\\(\\begin{bmatrix}x \\over w\\\\y \\over w\\\\z \\over w\\\\\\end{bmatrix}\\)所以当第四个坐标为0时是不能做上面的除法的，因此当第四个坐标值为0时，表示为向量，这就是为什么它们像方向一样。使用矩阵我们能用Unity的Matrix4x4结构体来完成矩阵乘法。从现在开始，我们将用它来代替上面的3D旋转方法。在Transformation增加一个抽象只读属性以检索变换矩阵。public abstract Matrix4x4 Matrix { get; }Transformation组件的Apply方法不再需要设为抽象，它将获取到矩阵并执行乘法运算。public Vector3 Apply (Vector3 point) { return Matrix.MultiplyPoint(point);}注意这个Matrix4x4.MultiplyPoint需要一个3D坐标参数，坐标参数假定了第四个值为1.该方法会负责把得到的其次坐标转为3D坐标，若只想计算方向向量可以使用Matrix4x4.MultiplyVector.该方法会忽略第四个坐标。public Vector3 MultiplyPoint(Vector3 v){ Vector3 vector; vector.x = (((this.m00 * v.x) + (this.m01 * v.y)) + (this.m02 * v.z)) + this.m03; vector.y = (((this.m10 * v.x) + (this.m11 * v.y)) + (this.m12 * v.z)) + this.m13; vector.z = (((this.m20 * v.x) + (this.m21 * v.y)) + (this.m22 * v.z)) + this.m23; float num = (((this.m30 * v.x) + (this.m31 * v.y)) + (this.m32 * v.z)) + this.m33;//其次坐标 num = 1f / num; vector.x *= num;//转换计算 vector.y *= num;//转换计算 vector.z *= num;//转换计算 return vector;} public Vector3 MultiplyVector(Vector3 v){ Vector3 vector; vector.x = ((this.m00 * v.x) + (this.m01 * v.y)) + (this.m02 * v.z); vector.y = ((this.m10 * v.x) + (this.m11 * v.y)) + (this.m12 * v.z); vector.z = ((this.m20 * v.x) + (this.m21 * v.y)) + (this.m22 * v.z); return vector;}具体的Transformation类现在必须将其Apply()方法更改为Matrix属性。首先是PositionTransformation组件，Matrix4x4.SetRow接口能很简易地填充这个矩阵。public override Matrix4x4 Matrix { get { Matrix4x4 matrix = new Matrix4x4(); matrix.SetRow(0, new Vector4(1f, 0f, 0f, position.x)); matrix.SetRow(1, new Vector4(0f, 1f, 0f, position.y)); matrix.SetRow(2, new Vector4(0f, 0f, 1f, position.z)); matrix.SetRow(3, new Vector4(0f, 0f, 0f, 1f)); return matrix; }}其次是ScaleTransformation.public override Matrix4x4 Matrix { get { Matrix4x4 matrix = new Matrix4x4(); matrix.SetRow(0, new Vector4(scale.x, 0f, 0f, 0f)); matrix.SetRow(1, new Vector4(0f, scale.y, 0f, 0f)); matrix.SetRow(2, new Vector4(0f, 0f, scale.z, 0f)); matrix.SetRow(3, new Vector4(0f, 0f, 0f, 1f)); return matrix; }}最后是RotationTransformation, 它设置行与列就更简单了，把之前的方法改改就能用。public override Matrix4x4 Matrix { get { float radx = rotation.x * Mathf.Deg2Rad; float rady = rotation.y * Mathf.Deg2Rad; float radz = rotation.z * Mathf.Deg2Rad; float sinx = Mathf.Sin(radx); float cosx = Mathf.Cos(radx); float siny = Mathf.Sin(rady); float cosy = Mathf.Cos(rady); float sinz = Mathf.Sin(radz); float cosz = Mathf.Cos(radz); Matrix4x4 matrix = new Matrix4x4(); matrix.SetColumn(0, new Vector4( cosy * cosz, cosx * sinz + sinx * siny * cosz, sinx * sinz - cosx * siny * cosz, 0f )); matrix.SetColumn(1, new Vector4( -cosy * sinz, cosx * cosz - sinx * siny * sinz, sinx * cosz + cosx * siny * sinz, 0f )); matrix.SetColumn(2, new Vector4( siny, -sinx * cosy, cosx * cosy, )); matrix.SetColumn(3, new Vector4(0f,0f,0f,1f)); return matrix; }}合并矩阵现在我们把上述所有变换矩阵合并为一个矩阵。 为此先在UnityMatrices类增加一个矩阵类型字段transformation。我们将在Update函数每帧更新该变量值，该步骤为先获取到第一个Transformation组件的矩阵，并依次与其他矩阵相乘，需要确保这块正确的相乘顺序。private void Update() { UpdateTransformation(); for (int i =0 , z = 0; z &lt; generalCount; z++) { //... } }void UpdateTransformation() { GetComponents&lt;Transformation&gt;(transformations); if(transformations.Count &gt; 0) { transformation = transformations[0].Matrix; for (int i = 1; i &lt; transformations.Count; i++) { transformation = transformations[i].Matrix * transformation; } }}最后不再执行Apply方法，而改用矩阵乘法代替：Vector3 TransformPoint(int x, int y, int z){ Vector3 coordinates = CreateCoordinate(x, y, z); // for (int i = 0; i &lt; transformations.Count; i++) // { // coordinates = transformations[i].Apply(coordinates); // } return transformation.MultiplyPoint(coordinates);;}这个新方法是非常有效的，因为我们之前使用的方法是分别给每个点乘一个变换矩阵。而现在我们只需要一次创建一个统一的变换矩阵作用与所有点。Unity使用类似的方案将每个对象的变换层次结构简化为单个变换矩阵。在这个例子中，我们可以使它更有效。所有的变换矩阵都有一个相同的行——[0 0 0 1]。知道了这一点，我们可以忽略这一行，跳过所有0的计算和最后的除法转换。Matrix4x4.MultiplayPoint3x4方法就是这样做的。public Vector3 MultiplyPoint3x4(Vector3 v){ Vector3 vector; vector.x = (((this.m00 * v.x) + (this.m01 * v.y)) + (this.m02 * v.z)) + this.m03; vector.y = (((this.m10 * v.x) + (this.m11 * v.y)) + (this.m12 * v.z)) + this.m13; vector.z = (((this.m20 * v.x) + (this.m21 * v.y)) + (this.m22 * v.z)) + this.m23; return vector;}这个方法有时候有用，有时候不能用。因为有时我们需要的一些变换矩阵会改变这最后一行。到目前为止只有位移变换需要第四行。所以缩放、旋转使用Matrix4x4.MultiplayPoint3x4计算速度会更快。现在就把Apply()方法改为虚方法，再由旋转、缩放组件重写，代码就不贴了。3D到2D投影矩阵到目前为止，我们能够把一个点的坐标从一个3D空间变换到另一个3D空间。但是这些点又如何展示到2D空间呢？这肯定需要一个从3D到2D的变换矩阵。那么我们开始寻找这个矩阵吧！先构造一个新的继承自Transformation的实体变换组件作用于摄像机的投影，默认值为单位矩阵。public class CameraTransformation : Transformation{ public override Matrix4x4 Matrix { get { Matrix4x4 matrix = new Matrix4x4(); matrix.SetRow(0, new Vector4(1f, 0f, 0f, 0f)); matrix.SetRow(1, new Vector4(0f, 1f, 0f, 0f)); matrix.SetRow(2, new Vector4(0f, 0f, 1f, 0f)); matrix.SetRow(3, new Vector4(0f, 0f, 0f, 1f)); return matrix; } }}正交相机Orthographic Camera从3D变换到2D空间最直接粗暴的方式是丢弃一个维度数据。就好像把3维空间压缩到2维平面，这个平面就像一个画布，用来渲染屏幕。现在我们把Z轴丢弃，试试看会发生什么\\[\\begin{bmatrix} 1&amp;0&amp;0&amp;0\\\\ 0&amp;1&amp;0&amp;0\\\\ 0&amp;0&amp;0&amp;0\\\\ 0&amp;0&amp;0&amp;1\\\\\\end{bmatrix}\\]把代码修改为public class CameraTransformation : Transformation{ public override Matrix4x4 Matrix { get { Matrix4x4 matrix = new Matrix4x4(); matrix.SetRow(0, new Vector4(1f, 0f, 0f, 0f)); matrix.SetRow(1, new Vector4(0f, 1f, 0f, 0f)); matrix.SetRow(2, new Vector4(0f, 0f, 0f, 0f)); matrix.SetRow(3, new Vector4(0f, 0f, 0f, 1f)); return matrix; } }}$\\rightarrow$ $\\rightarrow$ cube array 实际上，这种粗暴的方法还蛮像那么回事，确实变成了2D了。其他的X、Y轴同理，就不演示了。这就是正交投影。不管相机如何缩放、旋转、位移，始终呈现的2D效果。移动相机的视觉效果和移动世界的相反方向是一致的，也就是3个变换组件的变量与摄像机的缩放、旋转、位移变量是互为正负关系。透视相机Perspective Camera正交相机不能模拟3D世界就很尴尬。所以我们需要一个透视相机，由于视角的原因，呈现一个原小近大的视觉。那么基于此，我们可以根据点到摄像机的距离重建这个视觉效果。以Z轴为例，把单位矩阵代表Z轴的列元素全部置0，再把单位矩阵最后一行改为[0,0,1,0]，这步改变将确保结果坐标的第四个值等于Z坐标，最后所有坐标都除以Z\\(\\begin{bmatrix} 1&amp;0&amp;0&amp;0\\\\ 0&amp;1&amp;0&amp;0\\\\ 0&amp;0&amp;0&amp;0\\\\ 0&amp;0&amp;1&amp;0\\\\\\end{bmatrix}\\)\\(\\begin{bmatrix} x\\\\ y\\\\ z\\\\ 1\\\\\\end{bmatrix}\\)=\\(\\begin{bmatrix} x\\\\ y\\\\ 0\\\\ z\\\\\\end{bmatrix}\\)$\\rightarrow$\\(\\begin{bmatrix} x \\over z\\\\ y \\over z\\\\ 0\\\\\\end{bmatrix}\\)public override Matrix4x4 Matrix { get { Matrix4x4 matrix = new Matrix4x4(); matrix.SetRow(0, new Vector4(1f, 0f, 0f, 0f)); matrix.SetRow(1, new Vector4(0f, 1f, 0f, 0f)); matrix.SetRow(2, new Vector4(0f, 0f, 0f, 0f)); matrix.SetRow(3, new Vector4(0f, 0f, 1f, 0f)); return matrix; }}与正交投影最大的不同是这些点不会直接移向到平面，而是他们会移向摄像机的位置，当然这只对位于摄像机前面的点有效，而在摄像机后面的点就不会正确的投影。先确保所有点都能位于摄像机的前方，把摄像机的Unity.Transform组件Position.Z值调好，保证所有点都先可见。$\\rightarrow$ 透视投影 设置一个点到平面的投影距离，它也会影响投影视觉效果。它就像相机的焦距，值越大视野就越小。现在我们先定义一个变量focalLength值默认为1，这能产生90°的视野。public float focalLength = 1f;当这个focalLength值越大就像相机在进行聚焦，这有效地增加了所有点的比例(想象一下相机变焦)。当我们压缩Z轴时，是不必进行缩放的\\(\\begin{bmatrix} fl&amp;0&amp;0&amp;0\\\\ 0&amp;fl&amp;0&amp;0\\\\ 0&amp;0&amp;0&amp;0\\\\ 0&amp;0&amp;1&amp;0\\\\\\end{bmatrix}\\)\\(\\begin{bmatrix} x\\\\ y\\\\ z\\\\ 1\\\\\\end{bmatrix}\\)=\\(\\begin{bmatrix} xfl\\\\ yfl\\\\ 0\\\\ z\\\\\\end{bmatrix}\\)$\\rightarrow$\\(\\begin{bmatrix} xfl \\over z\\\\ yfl \\over z\\\\ 0\\\\\\end{bmatrix}\\)public override Matrix4x4 Matrix { get { Matrix4x4 matrix = new Matrix4x4(); matrix.SetRow(0, new Vector4(focalLength, 0f, 0f, 0f)); matrix.SetRow(1, new Vector4(0f, focalLength, 0f, 0f)); matrix.SetRow(2, new Vector4(0f, 0f, 0f, 0f)); matrix.SetRow(3, new Vector4(0f, 0f, 1f, 0f)); return matrix; }}现在有了一个简单的透视相机，如果要完全模拟Unity的透视相机，我们还必须处理近平面和远平面。这将需要处理投影到一个立方体而不是一个平面，因此需要保留深度信息。然后还有视野裁切方面的问题。此外，Unity的摄像头是在负Z方向上拍摄的，这需要对一些数字进行求负。矩阵不可怕。" }, { "title": "CG函数标准库", "url": "/posts/CG-function-library/", "categories": "Unity3D, Shader", "tags": "CG", "date": "2017-10-03 20:17:00 +0800", "snippet": "数学函数（Mathematical Functions）下表中列举了 Cg 标准函数库中所有的数学函数， 这些数学函数用于执行数学上常用计算，包括：三角函数、幂函数、园函数、向量和矩阵的操作函数。这些函数都被重载，以支持标量数据和不同长度的向量作为输入参数。 函数 功能 abs(x) 返回输入参数的绝对值 all(x) 如果输入参数均不为 0，则返回 ture；否则返回 flase。 &amp;&amp;运算 any(x) 输入参数只要有其中一个不为 0，则返回true。 clamp(x,a,b) 如果 x 值小于 a，则返回 a；如果 x 值大于 b，返回 b；否则返回 x degrees(x) 输入参数为弧度值(radians)， 函数将其转换为角度值(degrees) determinant(m) 计算矩阵的行列式因子 cross(A,B) 返回两个三元向量的叉积(cross product)。注意，输入参数必须是三元向量！ dot(A,B) 返回 A 和 B 的点积(dot product)。参数 A 和 B可以是标量，也可以是向量（输入参数方面，点积和叉积函数有很大不同） exp(x) 计算 ex 的值， e= 2.71828182845904523536 exp2(x) 计算 2x 的值 floor(x) 向下取整。例如 floor(float(1.3))返回的值为 1.0；但是floor(float(-1.3))返回的值为-2.0。该函数与 ceil(x)函数相对应 ceil(x) 对输入参数向上取整。 例如：ceil(float(1.3)) ，返回值为2.0 fmod(x,y) 返回 x/y 的余数。如果 y 为 0， 结果不可预料 frac(x) 返回标量或每个向量分量的小数部分 frexp(x, out exp) 将浮点数 x 分解为尾数和指数，即x = m* 2^exp， 返回 m， 并将指数存入exp 中；如果 x 为 0，则尾数和指数都返回 0 isfinite(x) 判断标量或者向量中的每个数据是否是有限数，如果是返回true；否则返回 false;无限的或者非数据(not-a-number NaN) isinf(x) 判断标量或者向量中的每个数据是否是无限，如果是返回 true；否则返回 false isnan(x) 判断标量或者向量中的每个数据是否是非数据(not-a-number NaN)，如果是返回 true；否则返回 false ldexp(x, n) 计算$x*2n$的值 lerp(a, b, f) 计算$ a+(b-a)f $ 或者$ (1-f)a+f*b $ 的值。即在下限 a 和上限 b 之间进行插值， f 表示权值。注意，如果 a 和 b 是向量，则权值f必须是标量或者等长的向量 lit(N•dot•L,N•dot•H, m) Blinn–Phong反射公式,N表示法向量，L表示入射光向量；H表示半角向量；m表示高光系数；N • L代表散射光的贡献，如果其值 &lt; 0 ，则为 0。Z 位代表镜面光的贡献，如果 N • L &lt; 0 或者N•H &lt; 0 ，则位 0；否则为 (N • L)m。函数计算环境光、散射光、镜面光的贡献，返回的 4 元向量 log(x) 计算 ln( x) 的值， x 必须大于 0 log2(x) 计算 log2(x) 的值， x 必须大于 0 log10(x) 计算 log10 (x) 的值， x 必须大于 0 max(a, b) 比较两个标量或等长向量元素，返回最大值 min(a,b) 比较两个标量或等长向量元素，返回最小值 modf(x, out ip) 将浮点数num分解成整数部分和小数部分，返回小数部分，将整数部分存入ip。不常用 mul(M, N) 计算两个矩阵相乘，如果 M 为 AxB 阶矩阵，N 为 BxC 阶矩阵，则返回AxC 阶矩阵。下面两个函数为其重载函数 mul(M, v) 计算矩阵和向量相乘 mul(v, M) 计算向量和矩阵相乘 noise(x) 噪声函数，返回值始终在 0， 1 之间；对于同样的输入，始终返回相同的值（也就是说，并不是真正意义上的随机噪声） pow(x, y) $ x^y $ radians(x) 函数将角度值转换为弧度值 round(x) 即四舍五入 sqrt(x) 求 x 的平方根， x ， x 必须大于 0 rsqrt(x) 平方根倒数$ y= \\frac{1}{\\sqrt{x}} $，x 必须大于 0 saturate(x) 如果 x 小于 0，返回 0；如果 x 大于 1，返回1；否则，返回 x sign(x) 如果 x 大于 0，返回 1；如果 x 小于 0，返回01；否则返回 0 sin(x) 输入参数为弧度，计算正弦值，返回值范围为[-1,1] cos(x) 返回弧度 x 的余弦值。返回值范围为[-1,1] tan(x) 输入参数为弧度，计算正切值 acos(x) 反余切函数，输入参数范围为[-1,1]，返回[0,π ]区间的角度值 asin(x) 反正弦函数,输入参数取值区间为[-1,1]，返回角度值范围为 atan(x) 反正切函数，返回角度值范围为 atan2(y,x) 计算$\\frac{y}{x}$ 的反正切值。实际上和 atan(x)函数功能完全一样，至少输入参数不同。 atan(x)= atan2(x, float(1)) sincos(float x,out s, out c) 该函数是同时计算 x 的 sin 值和 cos 值，其中s=sin(x)，c=cos(x)。该函数用于”同时需要计算 sin 值和 cos 值的情况”，比分别运算要快很多 sinh(x) 计算双曲正弦（hyperbolic sine）值 cosh(x) 双曲余弦（hyperbolic cosine）函数，计算 x的双曲余弦值 tanh(x) 计算双曲正切值 smoothstep(min,max, x) 值 x 位于 min、 max 区间中。如果x=min，返回 0；如果x=max，返回 1；如果 x 在两者之间，按照下列公式返回数据 step(a, x) 如果 x&lt;a，返回 0；否则，返回 1 transpose(M) M 为矩阵，计算其转置矩阵 几何函数（Geometric Functions）如下表所示，几何函数用于执行和解析几何相关的计算，例如根据入射光向量和顶点法向量，求取反射光和折射光方向向量。 Cg 语言标准函数库中有3个几何函数会经常被使用到分别是 normalize 函数，对向量进行归一化 reflect函数，计算反射光方向向量 refract 函数，计算折射光方向向量 着色程序中的向量最好进行归一化之后再使用，否则会出现难以预料的错误. reflect 函数和 refract 函数都存在以”入射光方向向量”作为输入参数，注意这两个函数中使用的入射光方向向量，是从外指向几何顶点的；平时我们在着色程序中或者在课本上都是将入射光方向向量作为从顶点出发. 函数 功能 distance( pt1, pt2) 两点之间的欧几里德距离（Euclidean distance） faceforward(N,I,Ng) 如果 Ng • I &lt; 0 ，返回 N；否则返回-N length(v) 返回一个向量的模，即 sqrt(dot(v,v)) normalize( v) 归一化向量 reflect(I, N) 根据入射光方向向量 I，和顶点法向量N，计算反射光方向向量。其中 I 和 N必须被归一化，需要非常注意的是，这个 I 是指向顶点；函数只对三元向量有效。 refract(I,N,eta) 计算折射向量， I 为入射光线， N 为法向量， eta 为折射系数；其中 I 和 N 必须被归一化， 如果 I 和 N 之间的夹角太大，则返回（0， 0， 0），也就是没有折射光线； I 是指向顶点的；函数只对三元向量有效 纹理映射函数（texture Map Functions）下表提供 Cg 标准函数库中的纹理映射函数。这些函数被 ps_2_0、 ps_2_x、arbfp1、 fp30 和fp40 等 profiles 完全支持（fully supported）。所有的这些函数返回四元向量值。 函数 功能 tex1D (sampler1D tex, float s)一维纹理查询 tex1D(sampler1D tex, float s, float dsdx, float dsdy) 使用导数值（derivatives）查询一维纹理 tex1D(sampler1D tex, float2 sz) 一维纹理查询，并进行深度值比较 tex1D(sampler1D tex, float2 sz, float dsdx,float dsdy) 使用导数值（derivatives）查询一维纹理， 并进行深度值比较 tex1Dproj(sampler1D tex, float2 sq) 一维投影纹理查询 tex1Dproj(sampler1D tex, float3 szq) 一维投影纹理查询，并比较深度值 tex2D(sampler2D tex, float2 s) 二维纹理查询—采样 tex2D(sampler2D tex, float2 s, float2 dsdx, float2 dsdy) 使用导数值（derivatives）查询二维纹理 tex2D(sampler2D tex, float3 sz) 二维纹理查询，并进行深度值比较 tex2D(sampler2D tex, float3 sz, float2 dsdx,float2 dsdy) 使用导数值（derivatives）查询二维纹理，并进行深度值比较 tex2Dproj(sampler2D tex, float3 sq) 二维投影纹理查询 tex2Dproj(sampler2D tex, float4 szq) 二维投影纹理查询，并进行深度值比较 texRECT(samplerRECT tex, float2 s) 二维非投影矩形纹理查询（OpenGL独有） texRECT (samplerRECT tex, float2 s, float2 dsdx, float2 dsdy) 二维非投影使用导数的矩形纹理查询（OpenGL独有） texRECT (samplerRECT tex, float3 sz) 二维非投影深度比较矩形纹理查询（OpenGL独有） texRECT (samplerRECT tex, float3 sz, float2 dsdx,float2 dsdy) 二维非投影深度比较并使用导数的矩形纹理查询（OpenGL独有） texRECT proj(samplerRECT tex, float3 sq) 二维投影矩形纹理查询（OpenGL独有） texRECT proj(samplerRECT tex, float3 szq) 二维投影矩形纹理查询（OpenGL独有） tex3D(sampler3D tex, float s) 三维纹理查询 tex3D(sampler3D tex, float3 s, float3 dsdx, float3 dsdy) 结合导数值（derivatives）查询三维纹理 tex3Dproj(sampler3D tex, float4 szq) 查询三维投影纹理，并进行深度值比较 texCUBE(samplerCUBE tex, float3 s) 查询立方体纹理 texCUBE(samplerCUBE tex, float3 s, float3 dsdx, float3 dsdy) 结合导数值（derivatives）查询立方体纹理 texCUBEproj(samplerCUBE tex, float4 sq) 查询投影立方体纹理 偏导函数（Derivative Functions） 函数 功能 ddx(a) 参数 a 对应一个像素位置， 返回该像素值在 X 轴上的偏导数 ddy(a) 参数 a 对应一个像素位置， 返回该像素值在 X 轴上的偏导数 调试函数（Debugging Function） 函数 功能 void debug(float4 x) 如果在编译时设置了DEBUG，片段着色程序中调用该函数可以将值x作为COLOR 语义的最终输出；否则该函数什么也不做 " }, { "title": "Markdown语法集合速查表", "url": "/posts/markdown-cheat-sheet/", "categories": "随笔, Markdown", "tags": "Markdown", "date": "2016-03-17 11:17:00 +0800", "snippet": "Thanks for visiting The Markdown Guide!This Markdown cheat sheet provides a quick overview of all the Markdown syntax elements. It can’t cover every edge case, so if you need more information about any of these elements, refer to the reference guides for basic syntax and extended syntax.Basic SyntaxThese are the elements outlined in John Gruber’s original design document. All Markdown applications support these elements.HeadingH1H2H3Boldbold textItalicitalicized textBlockquote blockquoteOrdered List First item Second item Third itemUnordered List First item Second item Third itemCodecodeHorizontal RuleLinkMarkdown GuideImage&lt;center class=\"half\"&gt; &lt;img src=\"\" width=\"15%\" /&gt; **&lt;/center&gt; *居中描述*Extended SyntaxThese elements extend the basic syntax by adding additional features. Not all Markdown applications support these elements.Table Syntax Description Header Title Paragraph Text :— 或者| 代表左对齐:–: 代表居中对齐—: 代表右对齐Fenced Code Block{ \"firstName\": \"John\", \"lastName\": \"Smith\", \"age\": 25}FootnoteHere’s a sentence with a footnote. 1Heading IDMy Great HeadingDefinition List term definitionStrikethroughThe world is flat.Task List Write the press release Update the website Contact the mediaEmojiThat is so funny! :joy:(See also Copying and Pasting Emoji)HighlightI need to highlight these ==very important words==.SubscriptH~2~OSuperscriptX^2^MathematicsThe mathematics powered by MathJax:数学公式符号两个$$包围，公式会另起一行$$ a + b = c$$例如：\\(a + b = c\\)例如：\\[{\\sum_{n=1}^\\infty} {1 \\over n^2} = \\frac{\\pi^2}{6}\\]一个$包围，公式与文字同一行When $a \\ne 0$, there are two solutions to $ax^2 + bx + c = 0$ and they are例如：When $a \\ne 0$, there are two solutions to $ax^2 + bx + c = 0$ and they are\\[x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}\\] 两个$$ xxx $$包围住，数学公式会换行. 一个$ xxx $包围住，数学公式不换行，如When $a \\ne 0$.&gt; 一个红色提示{: .prompt-danger } 一个红色提示- gem \"jekyll-theme-chirpy\", \"~&gt; 3.2\", \"&gt;= 3.2.1\"+ gem \"jekyll-theme-chirpy\", \"~&gt; 3.3\", \"&gt;= 3.3.0\"矩阵公式1、矩阵 数学公式放在 $$ 之间 起始标记 \\begin{matrix}，结束标记 \\end{matrix} 每一行末尾标记 \\，行间元素之间用 &amp; 分隔$$\\begin{matrix}0&amp;1&amp;1\\\\1&amp;1&amp;0\\\\1&amp;0&amp;1\\\\\\end{matrix}$$表现如下：\\(\\begin{matrix}0&amp;1&amp;1\\\\1&amp;1&amp;0\\\\1&amp;0&amp;1\\\\\\end{matrix}\\)2、矩阵边框 在起始、结束标记用下列词替换 matrix pmatrix：小括号边框 bmatrix：中括号边框$\\begin{bmatrix}0&amp;1&amp;11&amp;1&amp;01&amp;0&amp;1\\end{bmatrix}$ Bmatrix：大括号边框 vmatrix：单竖线边框 Vmatrix：双竖线边框表现如下：\\(\\begin{pmatrix}0&amp;1&amp;1\\\\1&amp;1&amp;0\\\\1&amp;0&amp;1\\\\\\end{pmatrix}\\)\\[\\begin{bmatrix}0&amp;1&amp;1\\\\1&amp;1&amp;0\\\\1&amp;0&amp;1\\\\\\end{bmatrix}\\]\\[\\begin{Bmatrix}0&amp;1&amp;1\\\\1&amp;1&amp;0\\\\1&amp;0&amp;1\\\\\\end{Bmatrix}\\]\\[\\begin{vmatrix}0&amp;1&amp;1\\\\1&amp;1&amp;0\\\\1&amp;0&amp;1\\\\\\end{vmatrix}\\]\\[\\begin{Vmatrix}0&amp;1&amp;1\\\\1&amp;1&amp;0\\\\1&amp;0&amp;1\\\\\\end{Vmatrix}\\]3、省略元素 横省略号：\\cdots 竖省略号：\\vdots 斜省略号：\\ddots$$\\begin{bmatrix}{a_{11}}&amp;{a_{12}}&amp;{\\cdots}&amp;{a_{1n}}\\\\{a_{21}}&amp;{a_{22}}&amp;{\\cdots}&amp;{a_{2n}}\\\\{\\vdots}&amp;{\\vdots}&amp;{\\ddots}&amp;{\\vdots}\\\\{a_{m1}}&amp;{a_{m2}}&amp;{\\cdots}&amp;{a_{mn}}\\\\\\end{bmatrix}$$表现如下：\\(\\begin{bmatrix}{a_{11}}&amp;{a_{12}}&amp;{\\cdots}&amp;{a_{1n}}\\\\{a_{21}}&amp;{a_{22}}&amp;{\\cdots}&amp;{a_{2n}}\\\\{\\vdots}&amp;{\\vdots}&amp;{\\ddots}&amp;{\\vdots}\\\\{a_{m1}}&amp;{a_{m2}}&amp;{\\cdots}&amp;{a_{mn}}\\\\\\end{bmatrix}\\)4、阵列 需要array环境：起始、结束处以{array}声明 对齐方式：在{array}后以{}逐行统一声明 左对齐：l；居中：c；右对齐：r 竖直线：在声明对齐方式时，插入 建立竖直线 插入水平线：\\hline$$\\begin{array}{c|lll}{↓}&amp;{a}&amp;{b}&amp;{c}\\\\\\hline{R_1}&amp;{c}&amp;{b}&amp;{a}\\\\{R_2}&amp;{b}&amp;{c}&amp;{c}\\\\\\end{array}$$表现如下：\\[\\begin{array}{c|lll}{↓}&amp;{a}&amp;{b}&amp;{c}\\\\\\hline{R_1}&amp;{c}&amp;{b}&amp;{a}\\\\{R_2}&amp;{b}&amp;{c}&amp;{c}\\\\\\end{array}\\]5、方程组 需要cases环境：起始、结束处以{cases}声明 $$\\begin{cases}a_1x+b_1y+c_1z=d_1\\\\a_2x+b_2y+c_2z=d_2\\\\a_3x+b_3y+c_3z=d_3\\\\\\end{cases}$$ \\(\\begin{cases}a_1x+b_1y+c_1z=d_1\\\\a_2x+b_2y+c_2z=d_2\\\\a_3x+b_3y+c_3z=d_3\\\\\\end{cases}\\) 30^\\circ\t30∘” role=”presentation”&gt;30∘30∘\t\\bot\t⊥” role=”presentation”&gt;⊥⊥\t\\angle A\t∠A” role=”presentation”&gt;∠A∠A\\sin\tsin” role=”presentation”&gt;sinsin\t\\cos\tcos” role=”presentation”&gt;coscos\t\\tan\ttan” role=”presentation”&gt;tantan\\csc\tcsc” r箭头 短箭头形状 MarkDown $\\uparrow$ $\\uparrow$ $\\Uparrow$ $\\Uparrow$ $\\downarrow$ $\\downarrow$ $\\Downarrow$ $\\Downarrow$ $\\leftarrow$ $\\leftarrow$ $\\Leftarrow$ $\\Leftarrow$ $\\rightarrow$ $\\rightarrow$ $\\Rightarrow$ $\\Rightarrow$ $\\updownarrow$ $\\updownarrow$ $\\Updownarrow$ $\\Updownarrow$ $\\leftrightarrow$ $\\leftrightarrow$ $\\Leftrightarrow$ $\\Leftrightarrow$ 长箭头形状 MarkDown $\\longleftarrow$ $\\longleftarrow$ $\\Longleftarrow$ $\\Longleftarrow$ $\\longrightarrow$ $\\longrightarrow$ $\\Longrightarrow$ $\\Longrightarrow$ $\\longleftrightarrow$ $\\longleftrightarrow$ $\\Longleftrightarrow$ $\\Longleftrightarrow$ 给字体加颜色&lt;font color=red&gt;想变成红色的内容&lt;/font&gt;想变成红色的内容加边框&lt;kbd&gt;2 3&lt;/kbd&gt;2 3创建脚注格式类似这样 2。查看代码 &nbsp;这里写需要被折叠的代码&nbsp; This is the footnote. &#8617; 菜鸟教程 – 学的不仅是技术，更是梦想！！！ &#8617; " } ]
